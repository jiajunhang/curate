[
    {
        "question": "Which was the first purely object oriented programming language developed?",
        "options": [
            "Java",
            "C++",
            "SmallTalk",
            "Kotlin"
        ],
        "explanation": "Explanation: SmallTalk was the first programming language developed which was purely object oriented. It was developed by Alan Kay. OOP concept came into the picture in 1970\u2019s.",
        "index": 1,
        "difficulty": -2.9960637879316057,
        "correct": 3
    },
    {
        "question": "Which of the following best defines a class?",
        "options": [
            "Parent of an object",
            "Instance of an object",
            "Blueprint of an object",
            "Scope of an object"
        ],
        "explanation": "Explanation: A class is Blueprint of an object which describes/ shows all the functions and data that are provided by an object of a specific class. It can\u2019t be called as parent or instance of an object. Class in general describes all the properties of an object.",
        "index": 2,
        "difficulty": -2.9905525692084485,
        "correct": 3
    },
    {
        "question": "Who invented OOP?",
        "options": [
            "Alan Kay",
            "Andrea Ferro",
            "Dennis Ritchie",
            "Adele Goldberg"
        ],
        "explanation": "Explanation: Alan Kay invented OOP, Andrea Ferro was a part of SmallTalk Development. Dennis invented C++ and Adele Goldberg was in team to develop SmallTalk but Alan actually had got rewarded for OOP.",
        "index": 3,
        "difficulty": -2.971037267945458,
        "correct": 1
    },
    {
        "question": "What is the additional feature in classes that was not in structures?",
        "options": [
            "Data members",
            "Member functions",
            "Static data allowed",
            "Public access specifier"
        ],
        "explanation": "Explanation: Member functions are allowed inside a class but were not present in structure concept.  Data members, static data and public access specifiers were present in structures too.",
        "index": 4,
        "difficulty": -2.962906052474378,
        "correct": 2
    },
    {
        "question": "Which is not feature of OOP in general definitions?",
        "options": [
            "Code reusability",
            "Modularity",
            "Duplicate/Redundant data",
            "Efficient Code"
        ],
        "explanation": "Explanation: Duplicate/Redundant data is dependent on programmer and hence can\u2019t be guaranteed by OOP. Code reusability is done using inheritance. Modularity is supported by using different code files and classes. Codes are more efficient because of features of OOP.",
        "index": 5,
        "difficulty": -2.9592294140016087,
        "correct": 3
    },
    {
        "question": "Pure OOP can be implemented without using class in a program. (True or False)",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: It\u2019s false because for a program to be pure OO, everything must be written inside classes. If this rule is violated, the program can\u2019t be labelled as purely OO.",
        "index": 6,
        "difficulty": -2.957725936282146,
        "correct": 2
    },
    {
        "question": "Which Feature of OOP illustrated the code reusability?",
        "options": [
            "Polymorphism",
            "Abstraction",
            "Encapsulation",
            "Inheritance"
        ],
        "explanation": "Explanation: Using inheritance we can reuse the code already written and also can avoid creation of many new functions or variables, as that can be done one time and be reused, using classes.",
        "index": 7,
        "difficulty": -2.9553824037511847,
        "correct": 4
    },
    {
        "question": "Which language does not support all 4 types of inheritance?",
        "options": [
            "C++",
            "Java",
            "Kotlin",
            "Small Talk"
        ],
        "explanation": "Explanation: Java doesn\u2019t support all 4 types of inheritance. It doesn\u2019t support multiple inheritance. But the multiple inheritance can be implemented using interfaces in Java.",
        "index": 8,
        "difficulty": -2.943413897737371,
        "correct": 2
    },
    {
        "question": "How many classes can be defined in a single program?",
        "options": [
            "Only 1",
            "Only 100",
            "Only 999",
            "As many as you want"
        ],
        "explanation": "Explanation: Any number of classes can be defined inside a program, provided that their names are different. In java, if public class is present then it must have the same name as that of file.",
        "index": 9,
        "difficulty": -2.9257271597490364,
        "correct": 4
    },
    {
        "question": "When OOP concept did first came into picture?",
        "options": [
            "1970\u2019s",
            "1980\u2019s",
            "1993",
            "1995"
        ],
        "explanation": "Explanation: OOP first came into picture in 1970\u2019s by Alan and his team. Later it was used by some programming languages and got implemented successfully, SmallTalk was first language to use pure OOP and followed all rules strictly.",
        "index": 10,
        "difficulty": -2.912338271656825,
        "correct": 1
    },
    {
        "question": "Why Java is Partially OOP language?",
        "options": [
            "It supports usual declaration of primitive data types",
            "It doesn\u2019t support all types of inheritance",
            "It allows code to be written outside classes",
            "It does not support pointers"
        ],
        "explanation": "Explanation: As Java supports usual declaration of data variables, it is partial implementation of OOP. Because according to rules of OOP, object constructors must be used, even for declaration of variables.",
        "index": 11,
        "difficulty": -2.905184715061196,
        "correct": 1
    },
    {
        "question": "Which concept of OOP is false for C++?",
        "options": [
            "Code can be written without using classes",
            "Code must contain at least one class",
            "A class must have member functions",
            "At least one object should be declared in code"
        ],
        "explanation": "Explanation: In C++, it\u2019s not necessary to use classes, and hence codes can be written without using OOP concept. Classes may or may not contain member functions, so it\u2019s not a necessary condition in C++. And, an object can only be declared in a code if its class is defined/included via header file.",
        "index": 12,
        "difficulty": -2.902838541706301,
        "correct": 2
    },
    {
        "question": "Which header file is required in C++ to use OOP?",
        "options": [
            "iostream.h",
            "stdio.h",
            "stdlib.h",
            "OOP can be used without using any header file"
        ],
        "explanation": "Explanation: We need not include any specific header file to use OOP concept in C++, only specific functions used in code need their respective header files to be included or classes should be defined if needed.",
        "index": 13,
        "difficulty": -2.9021793251197456,
        "correct": 4
    },
    {
        "question": "Which of the two features match each other?",
        "options": [
            "Inheritance and Encapsulation",
            "Encapsulation and Polymorphism",
            "Encapsulation and Abstraction",
            "Abstraction and Polymorphism"
        ],
        "explanation": "Explanation: Encapsulation and Abstraction are similar features. Encapsulation is actually binding all the properties in a single class or we can say hiding all the features of object inside a class. And Abstraction is hiding unwanted data (for user) and showing only the data required by the user of program.",
        "index": 14,
        "difficulty": -2.8700202906237835,
        "correct": 3
    },
    {
        "question": "Which feature allows open recursion, among the following?",
        "options": [
            "Use of this pointer",
            "Use of pointers",
            "Use of pass by value",
            "Use of parameterized constructor"
        ],
        "explanation": "Explanation: Use of this pointer allows an object to call data and methods of itself whenever needed. This helps us call the members of an object recursively, and differentiate the variables of different scopes.",
        "index": 15,
        "difficulty": -2.8577096576411902,
        "correct": 1
    },
    {
        "question": "Which of the following is not type of class?",
        "options": [
            "Abstract Class",
            "Final Class",
            "Start Class",
            "String Class"
        ],
        "explanation": "Explanation: Only 9 types of classes are provided in general, namely, abstract, final, mutable, wrapper, anonymous, input-output, string, system, network. We may further divide the classes into parent class and subclass if inheritance is used.",
        "index": 16,
        "difficulty": -2.8518135973949863,
        "correct": 3
    },
    {
        "question": "Class is pass by _______",
        "options": [
            "Value",
            "Reference",
            "Value or Reference, depending on program",
            "Copy"
        ],
        "explanation": "Explanation: Classes are pass by reference, and the structures are pass by copy. It doesn\u2019t depend on the program.",
        "index": 17,
        "difficulty": -2.833478772835602,
        "correct": 2
    },
    {
        "question": "What is default access specifier for data members or member functions declared within a class without any specifier, in C++?",
        "options": [
            "Private",
            "Protected",
            "Public",
            "Depends on compiler"
        ],
        "explanation": "Explanation: The data members and member functions are Private by default in C++ classes, if none of the access specifier is used. It is actually made to increase the privacy of data.",
        "index": 18,
        "difficulty": -2.79661120004401,
        "correct": 1
    },
    {
        "question": "Which definition best describes an object?",
        "options": [
            "Instance of a class",
            "Instance of itself",
            "Child of a class",
            "Overview of a class"
        ],
        "explanation": "Explanation: An object is instance of its class. It can be declared in the same way that a variable is declared, only thing is you have to use class name as the data type.",
        "index": 19,
        "difficulty": -2.7908454627747,
        "correct": 1
    },
    {
        "question": "How many objects can be declared of a specific class in a single program?",
        "options": [
            "32768",
            "127",
            "1",
            "As many as you want"
        ],
        "explanation": "Explanation: You can create as many objects of a specific class as you want, provided enough memory is available.",
        "index": 20,
        "difficulty": -2.787258071429947,
        "correct": 4
    },
    {
        "question": "Which among the following is false?",
        "options": [
            "Object must be created before using members of a class",
            "Memory for an object is allocated only after its constructor is called",
            "Objects can\u2019t be passed by reference",
            "Objects size depends on its class data members"
        ],
        "explanation": "Explanation: Objects can be passed by reference. Objects can be passed by value also. If the object of a class is not created, we can\u2019t use members of that class.",
        "index": 21,
        "difficulty": -2.7710961776295684,
        "correct": 3
    },
    {
        "question": "Which of the following is incorrect?",
        "options": [
            "class student{  }s;",
            "class student{  };   student s;",
            "class student{  }s[];",
            "class student{  }; student s[5];"
        ],
        "explanation": "Explanation: The array must be specified with a size. You can\u2019t declare object array, or any other linear array without specifying its size. It\u2019s a mandatory field.",
        "index": 22,
        "difficulty": -2.760230650679147,
        "correct": 3
    },
    {
        "question": "The object can\u2019t be __________",
        "options": [
            "Passed by reference",
            "Passed by value",
            "Passed by copy",
            "Passed as function"
        ],
        "explanation": "Explanation: Object can\u2019t be passed as function as it is an instance of some class, it\u2019s not a function. Object can be passed by reference, value or copy. There is no term defined as pass as function for objects.",
        "index": 23,
        "difficulty": -2.755332855482308,
        "correct": 4
    },
    {
        "question": "Which feature of OOP indicates code reusability?",
        "options": [
            "Encapsulation",
            "Inheritance",
            "Abstraction",
            "Polymorphism"
        ],
        "explanation": "Explanation: Inheritance indicates the code reusability. Encapsulation and abstraction are meant to hide/group data into one element. Polymorphism is to indicate different tasks performed by a single entity.",
        "index": 24,
        "difficulty": -2.7527782809728145,
        "correct": 2
    },
    {
        "question": "If a function can perform more than 1 type of tasks, where the function name remains same, which feature of OOP is used here?",
        "options": [
            "Encapsulation",
            "Inheritance",
            "Polymorphism",
            "Abstraction"
        ],
        "explanation": "Explanation: For the feature given above, the OOP feature used is Polymorphism. Example of polymorphism in real life is a kid, who can be a student, a son, a brother depending on where he is.",
        "index": 25,
        "difficulty": -2.744562322289951,
        "correct": 3
    },
    {
        "question": "If different properties and functions of a real world entity is grouped or embedded into a single element, what is it called in OOP language?",
        "options": [
            "Inheritance",
            "Polymorphism",
            "Abstraction",
            "Encapsulation"
        ],
        "explanation": "Explanation: It is Encapsulation, which groups different properties and functions of a real world entity into single element. Abstraction, on other hand, is hiding of functional or exact working of codes and showing only the things which are required by the user.",
        "index": 26,
        "difficulty": -2.742267957360871,
        "correct": 4
    },
    {
        "question": "Which of the following is not a feature of pure OOP?",
        "options": [
            "Classes must be used",
            "Inheritance",
            "Data may/may not be declared using object",
            "Functions Overloading"
        ],
        "explanation": "Explanation: Data must be declared using objects. Object usage is mandatory because it in turn calls its constructors, which in turn must have a class defined. If object is not used, it is a violation of pure OOP concept.",
        "index": 27,
        "difficulty": -2.727655392293321,
        "correct": 3
    },
    {
        "question": "Which among the following doesn\u2019t come under OOP concept?",
        "options": [
            "Platform independent",
            "Data binding",
            "Message passing",
            "Data hiding"
        ],
        "explanation": "Explanation: Platform independence is not feature of OOP. C++ supports OOP but it\u2019s not a platform independent language. Platform independence depends on programming language.",
        "index": 28,
        "difficulty": -2.6846482753940046,
        "correct": 1
    },
    {
        "question": "Which among the following best describes polymorphism?",
        "options": [
            "It is the ability for a message/data to be processed in more than one form",
            "It is the ability for a message/data to be processed in only 1 form",
            "It is the ability for many messages/data to be processed in one way",
            "It is the ability for undefined message/data to be processed in at least one way"
        ],
        "explanation": "Explanation: It is actually the ability for a message / data to be processed in more than one form. The word polymorphism indicates many-forms. So if a single entity takes more than one form, it is known as polymorphism.",
        "index": 29,
        "difficulty": -2.680133605725112,
        "correct": 1
    },
    {
        "question": "What do you call the languages that support classes but not polymorphism?",
        "options": [
            "Class based language",
            "Procedure Oriented language",
            "Object-based language",
            "If classes are supported, polymorphism will always be supported"
        ],
        "explanation": "Explanation: The languages which support classes but doesn\u2019t support polymorphism, are known as object-based languages. Polymorphism is such an important feature, that is a language doesn\u2019t support this feature, it can\u2019t be called as a OOP language.",
        "index": 30,
        "difficulty": -2.678815550641681,
        "correct": 3
    },
    {
        "question": "Which among the following is the language which supports classes but not polymorphism?",
        "options": [
            "SmallTalk",
            "Java",
            "C++",
            "Ada"
        ],
        "explanation": "Explanation: Ada is the language which supports the concept of classes but doesn\u2019t support the polymorphism feature. It is an object-based programming language. Note that it\u2019s not an OOP language.",
        "index": 31,
        "difficulty": -2.673708648691626,
        "correct": 4
    },
    {
        "question": "If same message is passed to objects of several different classes and all of those can respond in a different way, what is this feature called?",
        "options": [
            "Inheritance",
            "Overloading",
            "Polymorphism",
            "Overriding"
        ],
        "explanation": "Explanation: The feature defined in question defines polymorphism features. Here the different objects are capable of responding to the same message in different ways, hence polymorphism.",
        "index": 32,
        "difficulty": -2.67128133803458,
        "correct": 3
    },
    {
        "question": "Which among the following best describes encapsulation?",
        "options": [
            "It is a way of combining various data members into a single unit",
            "It is a way of combining various member functions into a single unit",
            "It is a way of combining various data members and member functions into a single unit which can operate on any data",
            "It is a way of combining various data members and member functions that operate on those data members into a single unit"
        ],
        "explanation": "Explanation: It is a way of combining both data members and member functions, which operate on those data members, into a single unit. We call it a class in OOP generally. This feature have helped us modify the structures used in C language to be upgraded into class in C++ and other languages.",
        "index": 33,
        "difficulty": -2.655537792561992,
        "correct": 4
    },
    {
        "question": "If data members are private, what can we do to access them from the class object?",
        "options": [
            "Create public member functions to access those data members",
            "Create private member functions to access those data members",
            "Create protected member functions to access those data members",
            "Private data members can never be accessed from outside the class"
        ],
        "explanation": "Explanation: We can define public member functions to access those private data members and get their value for use or alteration. They can\u2019t be accessed directly but is possible to be access using member functions. This is done to ensure that the private data doesn\u2019t get modified accidentally.",
        "index": 34,
        "difficulty": -2.64659945650589,
        "correct": 1
    },
    {
        "question": "While using encapsulation, which among the following is possible?",
        "options": [
            "Code modification can be additional overhead",
            "Data member\u2019s data type can be changed without changing any other code",
            "Data member\u2019s type can\u2019t be changed, or whole code have to be changed",
            "Member functions can be used to change the data type of data members"
        ],
        "explanation": "Explanation: Data member\u2019s data type can be changed without changing any further code. All the members using that data can continue in the same way without any modification. Member functions can never change the data type of same class data members.",
        "index": 35,
        "difficulty": -2.6427950652354353,
        "correct": 2
    },
    {
        "question": "Which feature can be implemented using encapsulation?",
        "options": [
            "Inheritance",
            "Abstraction",
            "Polymorphism",
            "Overloading"
        ],
        "explanation": "Explanation: Data abstraction can be achieved by using encapsulation. We can hide the operation and structure of actual program from the user and can show only required information by the user.",
        "index": 36,
        "difficulty": -2.641314865554441,
        "correct": 2
    },
    {
        "question": "Find which of the following uses encapsulation?",
        "options": [
            "void main(){  int a;  void fun( int a=10;  cout<<a); fun(); }",
            "class student{ int a;   public: int b;};",
            "class student{int a; public: void disp(){ cout<<a;} };",
            "struct topper{ char name[10]; public : int marks; }"
        ],
        "explanation": "Explanation: It is the class which uses both the data members and member functions being declared inside a single unit. Only data members can be there in structures also. And the encapsulation can only be illustrated if some data/operations are associated within class.",
        "index": 37,
        "difficulty": -2.623371979860193,
        "correct": 3
    },
    {
        "question": "Encapsulation helps in writing ___________ classes in java.",
        "options": [
            "Mutable",
            "Abstract",
            "Wrapper",
            "Immutable"
        ],
        "explanation": "Explanation: Immutable classes are used for caching purpose generally. And it can be created by making the class as final and making all its members private.",
        "index": 38,
        "difficulty": -2.593235239509618,
        "correct": 4
    },
    {
        "question": "Which among the following should be encapsulated?",
        "options": [
            "The data which is prone to change is near future",
            "The data prone to change in long terms",
            "The data which is intended to be changed",
            "The data which belongs to some other class"
        ],
        "explanation": "Explanation: The data prone to change in near future is usually encapsulated so that it doesn\u2019t get changed accidentally. We encapsulate the data to hide the critical working of program from outside world.",
        "index": 39,
        "difficulty": -2.5863039205323783,
        "correct": 1
    },
    {
        "question": "How can Encapsulation be achieved?",
        "options": [
            "Using Access Specifiers",
            "Using only private members",
            "Using inheritance",
            "Using Abstraction"
        ],
        "explanation": "Explanation: Using access specifiers we can achieve encapsulation. Using this we can in turn implement data abstraction. It\u2019s not necessary that we only use private access.",
        "index": 40,
        "difficulty": -2.5767097842948217,
        "correct": 1
    },
    {
        "question": "Which among the following violates the principle of encapsulation almost always?",
        "options": [
            "Local variables",
            "Global variables",
            "Public variables",
            "Array variables"
        ],
        "explanation": "Explanation: Global variables almost always violates the principles of encapsulation. Encapsulation says the data should be accessed only by required set of elements. But global variable is accessible everywhere, also it is most prone to changes. It doesn\u2019t hide the internal working of program.",
        "index": 41,
        "difficulty": -2.574349984993857,
        "correct": 2
    },
    {
        "question": "Which among the following would destroy the encapsulation mechanism if it was allowed in programming?",
        "options": [
            "Using access declaration for private members of base class",
            "Using access declaration for public members of base class",
            "Using access declaration for local variable of main() function",
            "Using access declaration for global variables"
        ],
        "explanation": "Explanation: If using access declaration for private members of base class was allowed in programming, it would have destroyed whole concept of encapsulation. As if it was possible, any class which gets inherited privately, would have been able to inherit the private members of base class, and hence could access each and every member of base class.",
        "index": 42,
        "difficulty": -2.566493095928634,
        "correct": 1
    },
    {
        "question": "Which among the following can be a concept against encapsulation rules?",
        "options": [
            "Using function pointers",
            "Using char* string pointer to be passed to non-member function",
            "Using object array",
            "Using any kind of pointer/array address in passing to another function"
        ],
        "explanation": "Explanation: If we use any kind of array or pointer as data member which should not be changed, but in some case its address is passed to some other function or similar variable. There are chances to modify its whole data easily. Hence Against encapsulation.",
        "index": 43,
        "difficulty": -2.5591510989976634,
        "correct": 4
    },
    {
        "question": "Which among the following best defines abstraction?",
        "options": [
            "Hiding the implementation",
            "Showing the important data",
            "Hiding the important data",
            "Hiding the implementation and showing only the features"
        ],
        "explanation": "Explanation: It includes hiding the implementation part and showing only the required data and features to the user. It is done to hide the implementation complexity and details from the user. And to provide a good interface in programming.",
        "index": 44,
        "difficulty": -2.556770798702103,
        "correct": 4
    },
    {
        "question": "Hiding the implementation complexity can ____________",
        "options": [
            "Make the programming easy",
            "Make the programming complex",
            "Provide more number of features",
            "Provide better features"
        ],
        "explanation": "Explanation: It can make programming easy. The programming need not know how the inbuilt functions are working but can use those complex functions directly in the program. It doesn\u2019t provide more number of features or better features.",
        "index": 45,
        "difficulty": -2.549803463737663,
        "correct": 1
    },
    {
        "question": "Class is _________ abstraction.",
        "options": [
            "Object",
            "Logical",
            "Real",
            "Hypothetical"
        ],
        "explanation": "Explanation: Class is logical abstraction because it provides a logical structure for all of its objects. It gives an overview of the features of an object.",
        "index": 46,
        "difficulty": -2.5404747477797223,
        "correct": 2
    },
    {
        "question": "Object is ________ abstraction.",
        "options": [
            "Object",
            "Logical",
            "Real",
            "Hypothetical"
        ],
        "explanation": "Explanation: Object is real abstraction because it actually contains those features of class. It is the implementation of overview given by class. Hence the class is logical abstraction and its object is real.",
        "index": 47,
        "difficulty": -2.5394227363784774,
        "correct": 3
    },
    {
        "question": "Abstraction gives higher degree of ________",
        "options": [
            "Class usage",
            "Program complexity",
            "Idealized interface",
            "Unstable interface"
        ],
        "explanation": "Explanation: It is to idealize the interface. In this way the programmer can use the programming features more efficiently and can code better. It can\u2019t increase the program complexity, as the feature itself is made to hide it.",
        "index": 48,
        "difficulty": -2.536658446016042,
        "correct": 3
    },
    {
        "question": "Abstraction can apply to ____________",
        "options": [
            "Control and data",
            "Only data",
            "Only control",
            "Classes"
        ],
        "explanation": "Explanation: Abstraction applies to both. Control abstraction involves use of subroutines and control flow abstraction. Data abstraction involves handling pieces of data in meaningful ways.",
        "index": 49,
        "difficulty": -2.5364544571663834,
        "correct": 1
    },
    {
        "question": "Which among the following can be viewed as combination of abstraction of data and code.",
        "options": [
            "Class",
            "Object",
            "Inheritance",
            "Interfaces"
        ],
        "explanation": "Explanation: Object can be viewed as abstraction of data and code. It uses data members and their functioning as data abstraction. Code abstraction as use of object of inbuilt class.",
        "index": 50,
        "difficulty": -2.5348072697435597,
        "correct": 2
    },
    {
        "question": "Abstraction principle includes___________",
        "options": [
            "Use abstraction at its minimum",
            "Use abstraction to avoid longer codes",
            "Use abstraction whenever possible to avoid duplication",
            "Use abstraction whenever possible to achieve OOP"
        ],
        "explanation": "Explanation: Abstraction principle includes use of abstraction to avoid duplication (usually of code). It this way the program doesn\u2019t contain any redundant functions and make the program efficient.",
        "index": 51,
        "difficulty": -2.529996180323744,
        "correct": 3
    },
    {
        "question": "Higher the level of abstraction, higher are the details.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: Higher the level of abstraction, lower are the details. The best way to understand this is to consider a whole system that is highest level of abstraction as it hides everything inside. And next lower level would contain few of the computer components and so on.",
        "index": 52,
        "difficulty": -2.5132522543427456,
        "correct": 2
    },
    {
        "question": "Encapsulation and abstraction differ as ____________",
        "options": [
            "Binding and Hiding respectively",
            "Hiding and Binding respectively",
            "Can be used any way",
            "Hiding and hiding respectively"
        ],
        "explanation": "Explanation: Abstraction is hiding the complex code. For example, we directly use cout object in C++ but we don\u2019t know how is it actually implemented. Encapsulation is data binding, as in, we try to combine a similar type of data and functions together.",
        "index": 53,
        "difficulty": -2.5074524124667437,
        "correct": 1
    },
    {
        "question": "In terms of stream and files ____________",
        "options": [
            "Abstraction is called a stream and device is called a file",
            "Abstraction is called a file and device is called a stream",
            "Abstraction can be called both file and stream",
            "Abstraction can\u2019t be defined in terms of files and stream"
        ],
        "explanation": "Explanation: Abstraction is called stream to provide a level of complexity hiding, for how the files operations are actually done. Actual devices are called file because in one way or another, those can be considered as single entity and there is nothing hidden.",
        "index": 54,
        "difficulty": -2.499807865043426,
        "correct": 1
    },
    {
        "question": "If two classes combine some private data members and provides public member functions to access and manipulate those data members. Where is abstraction used?",
        "options": [
            "Using private access specifier for data members",
            "Using class concept with both data members and member functions",
            "Using public member functions to access and manipulate the data members",
            "Data is not sufficient to decide what is being used"
        ],
        "explanation": "Explanation: It is the concept of hiding program complexity and actual working in background. Hence use of public member functions illustrates abstraction here.",
        "index": 55,
        "difficulty": -2.492456176267666,
        "correct": 3
    },
    {
        "question": "A phone is made up of many components like motherboard, camera, sensors and etc. If the processor represents all the functioning of phone, display shows the display only, and the phone is represented as a whole. Which among the following have highest level of abstraction?",
        "options": [
            "Motherboard",
            "Display",
            "Camera",
            "Phone"
        ],
        "explanation": "Explanation: Phone as a whole have the highest level of abstraction. This is because the phone being a single unit represents the whole system. Whereas motherboard, display and camera are its components.",
        "index": 56,
        "difficulty": -2.4874720481930748,
        "correct": 4
    },
    {
        "question": "Which among the following is not a level of abstraction?",
        "options": [
            "Logical level",
            "Physical level",
            "View level",
            "External level"
        ],
        "explanation": "Explanation: Abstraction is generally divided into 3 different levels, namely, logical, physical and view level. External level is not defined in terms of abstraction.",
        "index": 57,
        "difficulty": -2.4837215569515445,
        "correct": 4
    },
    {
        "question": "Using higher degree of abstraction __________",
        "options": [
            "May get unsafe",
            "May reduce readability",
            "Can be safer",
            "Can increase vulnerability"
        ],
        "explanation": "Explanation: It will make the code safer. One may think it reduces the readability, but the fact is, it actually helps us understand the code better. We don\u2019t have to read the complex code which is of no use in understanding the program.",
        "index": 58,
        "difficulty": -2.4769527096466897,
        "correct": 3
    },
    {
        "question": "Which among the following is called first, automatically, whenever an object is created?",
        "options": [
            "Class",
            "Constructor",
            "New",
            "Trigger"
        ],
        "explanation": "Explanation: Constructors are the member functions which are called automatically whenever an object is created. It is a mandatory functions to be called for an object to be created as this helps in initializing the object to a legal initial value for the class.",
        "index": 59,
        "difficulty": -2.4578560554584366,
        "correct": 2
    },
    {
        "question": "Which among the following is not a necessary condition for constructors?",
        "options": [
            "Its name must be same as that of class",
            "It must not have any return type",
            "It must contain a definition body",
            "It can contains arguments"
        ],
        "explanation": "Explanation: Constructors are predefined implicitly, even if the programmer doesn\u2019t define any of them. Even if the programmer declares a constructor, it\u2019s not necessary that it must contain some definition.",
        "index": 60,
        "difficulty": -2.4483032208480893,
        "correct": 3
    },
    {
        "question": "Which among the following is correct?",
        "options": [
            "class student{ public: int student(){} };",
            "class student{ public: void student (){} };",
            "class student{ public: student{}{}  };",
            "class student{ public: student(){} };"
        ],
        "explanation": "Explanation: The constructors must not have any return type. Also, the body may or may not contain any body. Defining default constructor is optional, if you are not using any other constructor.",
        "index": 61,
        "difficulty": -2.446266455070928,
        "correct": 4
    },
    {
        "question": "In which access should a constructor be defined, so that object of the class can be created in any function?",
        "options": [
            "Public",
            "Protected",
            "Private",
            "Any access specifier will work"
        ],
        "explanation": "Explanation: Constructor function should be available to all the parts of program where the object is to be created. Hence it is advised to define it in public access, so that any other function is able to create objects.",
        "index": 62,
        "difficulty": -2.438775696114382,
        "correct": 1
    },
    {
        "question": "How many types of constructors are available for use in general (with respect to parameters)?",
        "options": [
            "2",
            "3",
            "4",
            "5"
        ],
        "explanation": "Explanation: Two types of constructors are defined generally, namely, default constructor and parameterized constructor. Default constructor is not necessary to be defined always.",
        "index": 63,
        "difficulty": -2.4364003976336415,
        "correct": 1
    },
    {
        "question": "If a programmer defines a class and defines a default value parameterized constructor inside it.",
        "options": [
            "He has not defined any default constructor. And then he try to create the object without passing arguments, which among the following will be correct?",
            "It will not create the object (as parameterized constructor is used)",
            "It will create the object (as the default arguments are passed)",
            "It will not create the object (as the default constructor is not defined)",
            "It will create the object (as at least some constructor is defined)"
        ],
        "explanation": "Explanation: It will create the object without any problem, because the default arguments use the default value if no value is passed. Hence it is equal to default constructor with zero parameters. But it will not create the object if signature doesn\u2019t match.",
        "index": 64,
        "difficulty": -2.425757994328837,
        "correct": 2
    },
    {
        "question": "Default constructor must be defined, if parameterized constructor is defined and the object is to be created without arguments.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: If the object is create without arguments and only parameterized constructors are used, compiler will give an error as there is no default constructor defined. And some constructor must be called so as to create an object in memory.",
        "index": 65,
        "difficulty": -2.4181641833670566,
        "correct": 1
    },
    {
        "question": "If class C inherits class B. And B has inherited class A. Then while creating the object of class C, what will be the sequence of constructors getting called?",
        "options": [
            "Constructor of C then B, finally of A",
            "Constructor of A then C, finally of B",
            "Constructor of C then A, finally B",
            "Constructor of A then B, finally C"
        ],
        "explanation": "Explanation: While creating the object of class C, its constructor would be called by default. But, if the class is inheriting some other class, firstly the parent class constructor will be called so that all the data is initialized that is being inherited.",
        "index": 66,
        "difficulty": -2.414951336152501,
        "correct": 4
    },
    {
        "question": "How many types of constructors are available, in general, in any language?",
        "options": [
            "2",
            "3",
            "4",
            "5"
        ],
        "explanation": "Explanation: There are 3 types of constructors in general, namely, default constructors, parameterized constructors and copy constructors. Default one is called whenever an object is created without arguments.",
        "index": 67,
        "difficulty": -2.412710896042081,
        "correct": 2
    },
    {
        "question": "Copy constructor is a constructor which ________________",
        "options": [
            "Creates an object by copying values from any other object of same class",
            "Creates an object by copying values from first object created for that class",
            "Creates an object by copying values from another object of another class",
            "Creates an object by initializing it with another previously created object of same class"
        ],
        "explanation": "Explanation: The object that has to be copied to new object must be previously created. The new object gets initialized with the same values as that of the object mentioned for being copied. The exact copy is made with values.",
        "index": 68,
        "difficulty": -2.4119546774402325,
        "correct": 4
    },
    {
        "question": "The copy constructor can be used to ____________",
        "options": [
            "Initialize one object from another object of same type",
            "Initialize one object from another object of different type",
            "Initialize more than one object from another object of same type at a time",
            "Initialize all the objects of a class to another object of another class"
        ],
        "explanation": "Explanation: The copy constructor has the most basic function to initialize the members of an object with same values as that of some previously created object. The object must be of same class.",
        "index": 69,
        "difficulty": -2.391116114684095,
        "correct": 1
    },
    {
        "question": "If two classes have exactly same data members and member function and only they differ by class name. Can copy constructor be used to initialize one class object with another class object?",
        "options": [
            "Yes, possible",
            "Yes, because the members are same",
            "No, not possible",
            "No, but possible if constructor is also same"
        ],
        "explanation": "Explanation: The restriction for copy constructor is that it must be used with the object of same class. Even if the classes are exactly same the constructor won\u2019t be able to access all the members of another class. Hence we can\u2019t use object of another class for initialization.",
        "index": 70,
        "difficulty": -2.3570917200836154,
        "correct": 3
    },
    {
        "question": "The copy constructors can be used to ________",
        "options": [
            "Copy an object so that it can be passed to a class",
            "Copy an object so that it can be passed to a function",
            "Copy an object so that it can be passed to another primitive type variable",
            "Copy an object for type casting"
        ],
        "explanation": "Explanation: When an object is passed to a function, actually its copy is made in the function. To copy the values, copy constructor is used. Hence the object being passed and object being used in function are different.",
        "index": 71,
        "difficulty": -2.3538722000338095,
        "correct": 2
    },
    {
        "question": "Which returning an object, we can use ____________",
        "options": [
            "Default constructor",
            "Zero argument constructor",
            "Parameterized constructor",
            "Copy constructor"
        ],
        "explanation": "Explanation: While returning an object we can use the copy constructor. When we assign the return value to another object of same class then this copy constructor will be used. And all the members will be assigned the same values as that of the object being returned.",
        "index": 72,
        "difficulty": -2.351788266767252,
        "correct": 4
    },
    {
        "question": "If programmer doesn\u2019t define any copy constructor then _____________",
        "options": [
            "Compiler provides an implicit copy constructor",
            "Compiler gives an error",
            "The objects can\u2019t be assigned with another objects",
            "The program gives run time error if copying is used"
        ],
        "explanation": "Explanation: The compiler provides an implicit copy constructor. It is not mandatory to always create an explicit copy constructor. The values are copied using implicit constructor only.",
        "index": 73,
        "difficulty": -2.351237547349569,
        "correct": 1
    },
    {
        "question": "If a class implements some dynamic memory allocations and pointers then _____________",
        "options": [
            "Copy constructor must be defined",
            "Copy constructor must not be defined",
            "Copy constructor can\u2019t be defined",
            "Copy constructor will not be used"
        ],
        "explanation": "Explanation: In the case where dynamic memory allocation is used, the copy constructor definition must be given. The implicit copy constructor is not capable of manipulating the dynamic memory and pointers. Explicit definition allows to manipulate the data as required.",
        "index": 74,
        "difficulty": -2.337637174042284,
        "correct": 1
    },
    {
        "question": "What is the syntax of copy constructor?",
        "options": [
            "classname (classname &obj){ /*constructor definition*/ }",
            "classname (cont classname obj){ /*constructor definition*/ }",
            "classname (cont classname &obj){ /*constructor definition*/ }",
            "classname (cont &obj){ /*constructor definition*/ }"
        ],
        "explanation": "Explanation: The syntax must contain the class name first, followed by the classname as type and &object within parenthesis. Then comes the constructor body. The definition can be given as per requirements.",
        "index": 75,
        "difficulty": -2.331232242647861,
        "correct": 3
    },
    {
        "question": "Object being passed to a copy constructor ___________",
        "options": [
            "Must be passed by reference",
            "Must be passed by value",
            "Must be passed with integer type",
            "Must not be mentioned in parameter list"
        ],
        "explanation": "Explanation: This is mandatory to pass the object by reference. Otherwise, the object will try to create another object to copy its values, in turn a constructor will be called, and this will keep on calling itself. This will cause the compiler to give out of memory error.",
        "index": 76,
        "difficulty": -2.32180945417626,
        "correct": 1
    },
    {
        "question": "Out of memory error is given when the object _____________ to the copy constructor.",
        "options": [
            "Is passed with & symbol",
            "Is passed by reference",
            "Is passed as <classname &obj>",
            "Is not passed by reference"
        ],
        "explanation": "Explanation: All the options given, directly or indirectly indicate that the object is being passed by reference. And if object is not passed by reference then the out of memory error is produced. Due to infinite constructor call of itself.",
        "index": 77,
        "difficulty": -2.3208168124004667,
        "correct": 4
    },
    {
        "question": "Copy constructor will be called whenever the compiler __________",
        "options": [
            "Generates implicit code",
            "Generates member function calls",
            "Generates temporary object",
            "Generates object operations"
        ],
        "explanation": "Explanation: Whenever the compiler creates a temporary object, copy constructor is used to copy the values from existing object to the temporary object.",
        "index": 78,
        "difficulty": -2.3086926465741673,
        "correct": 3
    },
    {
        "question": "The deep copy is possible only with the help of __________",
        "options": [
            "Implicit copy constructor",
            "User defined copy constructor",
            "Parameterized constructor",
            "Default constructor"
        ],
        "explanation": "Explanation: While using explicit copy constructor, the pointers of copied object point to the intended memory location. This is assured since the programmers themselves manipulate the addresses.",
        "index": 79,
        "difficulty": -2.300179607434144,
        "correct": 2
    },
    {
        "question": "Can a copy constructor be made private?",
        "options": [
            "Yes, always",
            "Yes, if no other constructor is defined",
            "No, never",
            "No, private members can\u2019t be accessed"
        ],
        "explanation": "Explanation: The copy constructor can be defined as private. If we make it private then the objects of the class can\u2019t be copied. It can be used when a class used dynamic memory allocation.",
        "index": 80,
        "difficulty": -2.297189490829992,
        "correct": 1
    },
    {
        "question": "The arguments to a copy constructor _____________",
        "options": [
            "Must be const",
            "Must not be cosnt",
            "Must be integer type",
            "Must be static"
        ],
        "explanation": "Explanation: The object should not be modified in the copy constructor. Because the object itself is being copied. When the object is returned from a function, the object must be a constant otherwise the compiler creates a temporary object which can die anytime.",
        "index": 81,
        "difficulty": -2.2931822987418364,
        "correct": 1
    },
    {
        "question": "Copy constructors are overloaded constructors.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The copy constructors are always overloaded constructors. They have to be. All the classes have a default constructor and other constructors are basically overloaded constructors.",
        "index": 82,
        "difficulty": -2.2869318183529344,
        "correct": 1
    },
    {
        "question": "Which among the following best describes constructor overloading?",
        "options": [
            "Defining one constructor in each class of a program",
            "Defining more than one constructor in single class",
            "Defining more than one constructor in single class with different signature",
            "Defining destructor with each constructor"
        ],
        "explanation": "Explanation: If more than one constructors are defined in a class with same signature, then that results in error. The signatures must be different. So that the constructors can be differentiated.",
        "index": 83,
        "difficulty": -2.2674009734187894,
        "correct": 3
    },
    {
        "question": "Can constructors be overloaded in derived class?",
        "options": [
            "Yes, always",
            "Yes, if derived class has no constructor",
            "No, programmer can\u2019t do it",
            "No, never"
        ],
        "explanation": "Explanation: The constructor must be having the same name as that of a class. Hence a constructor of one class can\u2019t even be defined in another class. Since the constructors can\u2019t be defined in derived class, it can\u2019t be overloaded too, in derived class.",
        "index": 84,
        "difficulty": -2.2558361620527707,
        "correct": 4
    },
    {
        "question": "Does constructor overloading include different return types for constructors to be overloaded?",
        "options": [
            "Yes, if return types are different, signature becomes different",
            "Yes, because return types can differentiate two functions",
            "No, return type can\u2019t differentiate two functions",
            "No, constructors doesn\u2019t have any return type"
        ],
        "explanation": "Explanation: The constructors doesn\u2019t have any return type. When we can\u2019t have return type of a constructor, overloading based on the return type is not possible. Hence only parameters can be different.",
        "index": 85,
        "difficulty": -2.2530961410543133,
        "correct": 4
    },
    {
        "question": "Which among the following is possible way to overload constructor?",
        "options": [
            "Define default constructor, 1 parameter constructor and 2 parameter constructor",
            "Define default constructor, zero argument constructor and 1 parameter constructor",
            "Define default constructor, and 2 other parameterized constructors with same signature",
            "Define 2 default constructors"
        ],
        "explanation": "Explanation: All the constructors defined in a class must have a different signature in order to be overloaded. Here one default and other parameterized constructors are used, wherein one is of only one parameter and other accepts two. Hence overloading is possible.",
        "index": 86,
        "difficulty": -2.2414381889613275,
        "correct": 1
    },
    {
        "question": "Which among the following best describes the constructors?",
        "options": [
            "A function which is called whenever an object is referenced",
            "A function which is called whenever an object is created to initialize the members",
            "A function which is called whenever an object is assigned to copy the values",
            "A function which is called whenever an object is to be given values for members"
        ],
        "explanation": "Explanation: The constructors are special type of functions which are called whenever an object is created. This is to initialize the data members of the class. The constructor allocates memory space for all the data members.",
        "index": 87,
        "difficulty": -2.2341833729325042,
        "correct": 2
    },
    {
        "question": "Which among the following best describes destructor?",
        "options": [
            "A function which is called just before the objects are destroyed",
            "A function which is called after each reference to the object",
            "A function which is called after termination of the program",
            "A function which is called before calling any member function"
        ],
        "explanation": "Explanation: The Destructors are special functions which are called just before an object is destroyed. This functions is responsible to free all the allocated resources to the object. Objects are destroyed whenever those go out of scope.",
        "index": 88,
        "difficulty": -2.230751132482501,
        "correct": 1
    },
    {
        "question": "Which among the following represents correct constructor?",
        "options": [
            "()classname",
            "~classname()",
            "\u2013classname()",
            "classname()"
        ],
        "explanation": "Explanation: The constructors must contain only the class name. The class name is followed by the blank parenthesis or we can have parameters if some values are to be passed.",
        "index": 89,
        "difficulty": -2.2256001503399476,
        "correct": 4
    },
    {
        "question": "Which among the following is correct syntax for the destructors?",
        "options": [
            "classname()",
            "()classname",
            "~classname()",
            "-classname()"
        ],
        "explanation": "Explanation: The destructor must have same name as that of the corresponding class. The class name should be preceded by the tilde symbol (~).",
        "index": 90,
        "difficulty": -2.210937759172004,
        "correct": 3
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "First the constructor of parent classes are called in sequence of inheritance",
            "First the constructor of child classes are called in the sequence of inheritance",
            "First constructor called is of the object being created",
            "Constructors are called randomly"
        ],
        "explanation": "Explanation: First the constructor of parent class are called. The order in which the parent class constructors are called is same in the sequence of inheritance used.",
        "index": 91,
        "difficulty": -2.2008826148838634,
        "correct": 1
    },
    {
        "question": "What is the sequence of destructors call?",
        "options": [
            "Same order as that of the constructors call",
            "Random order",
            "According to the priority",
            "Revere of the order of constructor call"
        ],
        "explanation": "Explanation: The destructors are called in the reverse order as that of the constructors being called. This is done to ensure that all the resources are released in sequence. That is, the derived class destructors will be called first.",
        "index": 92,
        "difficulty": -2.1837803506455318,
        "correct": 4
    },
    {
        "question": "The destructors _____________________",
        "options": [
            "Can have maximum one argument",
            "Can\u2019t have any argument",
            "Can have more than one argument",
            "Can\u2019t have more than 3 arguments"
        ],
        "explanation": "Explanation: The destructors doesn\u2019t have any arguments. The destructors have to be called implicitly whenever an object goes out of scope. The user can\u2019t pass argument to the implicit call.",
        "index": 93,
        "difficulty": -2.1830069411285127,
        "correct": 2
    },
    {
        "question": "Destructor calls ________________ (C++)",
        "options": [
            "Are only implicit",
            "Are only explicit",
            "Can be implicit or explicit",
            "Are made at end of program only"
        ],
        "explanation": "Explanation: The destructors are usually called implicitly whenever an object goes out of scope. The destructors can also be called explicitly if required. The call must be made, implicitly or explicitly.",
        "index": 94,
        "difficulty": -2.178636866939625,
        "correct": 3
    },
    {
        "question": "Number of destructors called are ____________",
        "options": [
            "Always equal to number of constructors called",
            "Always less than the number of constructors called",
            "Always greater than the number of constructors called",
            "Always less than or equal to number of constructors"
        ],
        "explanation": "Explanation: Destructor will be called only to free the resources allocated for an object. The resources are allocated only the constructor for an object is called.",
        "index": 95,
        "difficulty": -2.1780046597120117,
        "correct": 1
    },
    {
        "question": "For explicit call _________________",
        "options": [
            "The destructor must be private",
            "The destructor must be public",
            "The destructor must be protected",
            "The destructor must be defined outside the class"
        ],
        "explanation": "Explanation: The destructor must be public for explicit calls. If it is made private or protected then it won\u2019t be accessible outside the class. There is no restriction of definition the destructor outside the class.",
        "index": 96,
        "difficulty": -2.177140265370995,
        "correct": 2
    },
    {
        "question": "If a class have 4 constructors then it must have 4 destructors also.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: Even if the class have 4 constructors, only one would be used. And only one destructor is allowed.",
        "index": 97,
        "difficulty": -2.166079911422666,
        "correct": 2
    },
    {
        "question": "Which among the following is true for destructors?",
        "options": [
            "Destructors can be overloaded",
            "Destructors can be define more than one time",
            "Destructors can\u2019t be overloaded",
            "Destructors are overloaded in derived classes"
        ],
        "explanation": "Explanation: The destructors can never be overloaded. The destructors doesn\u2019t have arguments. And to get overloaded, they must have different signature. This is not possible if arguments are not allowed.",
        "index": 98,
        "difficulty": -2.150871986549075,
        "correct": 3
    },
    {
        "question": "The constructor _____________",
        "options": [
            "Have a return type",
            "May have a return type",
            "Of derived classes have return type",
            "Doesn\u2019t have a return type"
        ],
        "explanation": "Explanation: The constructors doesn\u2019t have any return type. The constructors are intended to allocate the resources for the object. Memory spaces are to be finalized.",
        "index": 99,
        "difficulty": -2.146561680197632,
        "correct": 4
    },
    {
        "question": "The destructors ____________",
        "options": [
            "Have a return type",
            "May have a return type",
            "Of derived classes have return type",
            "Doesn\u2019t have a return type"
        ],
        "explanation": "Explanation: The destructors are intended to free the memory space. And all the resources that were allocated for the object. The return value is not supported since only memory has to be made free.",
        "index": 100,
        "difficulty": -2.1361685771253844,
        "correct": 4
    },
    {
        "question": "The destructor can be called before the constructor if required.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The destructors can be called only after the constructor calls. It is not a mandatory rule but the deletion can only take place if there is something created using the constructor.",
        "index": 101,
        "difficulty": -2.1249993550828488,
        "correct": 2
    },
    {
        "question": "Which among the following describes a destructor?",
        "options": [
            "A special function that is called to free the resources, acquired by the object",
            "A special function that is called to delete the class",
            "A special function that is called anytime to delete an object",
            "A special function that is called to delete all the objects of a class"
        ],
        "explanation": "Explanation: It is used to free the resources that the object might had used in its lifespan. The destructors are called implicitly whenever an object\u2019s life ends.",
        "index": 102,
        "difficulty": -2.1131309935338614,
        "correct": 1
    },
    {
        "question": "When a destructor is called?",
        "options": [
            "After the end of object life",
            "Anytime in between object\u2019s lifespan",
            "At end of whole program",
            "Just before the end of object life"
        ],
        "explanation": "Explanation: The destructor is called just before the object go out of scope or just before its life ends. This is done to ensure that all the resources reserved for the object are used and at last, are made free for others.",
        "index": 103,
        "difficulty": -2.079877856477012,
        "correct": 4
    },
    {
        "question": "Which among the following is correct for abstract class destructors?",
        "options": [
            "It doesn\u2019t have destructors",
            "It has destructors",
            "It may or may not have destructors",
            "It contains an implicit destructor"
        ],
        "explanation": "Explanation: It doesn\u2019t have destructors. Since an abstract class don\u2019t have constructors, and hence can\u2019t have instances. Having this case, the abstract classes don\u2019t have destructors too, because that would be of no use here.",
        "index": 104,
        "difficulty": -2.057957551293105,
        "correct": 1
    },
    {
        "question": "If in multiple inheritance, class C inherits class B, and Class B inherits class A. In which sequence are their destructors called if an object of class C was declared?",
        "options": [
            "~C() then ~B() then ~A()",
            "~B() then ~C() then ~A()",
            "~A() then ~B() then ~C()",
            "~C() then ~A() then ~B()"
        ],
        "explanation": "Explanation: The destructors are always called in the reverse order of how the constructors were called. Here class A constructor would have been created first if Class C object is declared. Hence class A destructor is called at last.",
        "index": 105,
        "difficulty": -2.045084103466844,
        "correct": 1
    },
    {
        "question": "How many types of access specifiers are provided in OOP (C++)?",
        "options": [
            "1",
            "2",
            "3",
            "4"
        ],
        "explanation": "Explanation: Only 3 types of access specifiers are available. Namely, private, protected and public. All these three can be used according to the need of security of members.",
        "index": 106,
        "difficulty": -2.0440123329467683,
        "correct": 3
    },
    {
        "question": "Which among the following can be used together in a single class?",
        "options": [
            "Only private",
            "Private and Protected together",
            "Private and Public together",
            "All three together"
        ],
        "explanation": "Explanation: All the classes can use any of the specifiers as needed. There is no restriction on how many of them can be used together.",
        "index": 107,
        "difficulty": -2.039593113906543,
        "correct": 4
    },
    {
        "question": "Which among the following can restrict class members to get inherited?",
        "options": [
            "Private",
            "Protected",
            "Public",
            "All three"
        ],
        "explanation": "Explanation: Private members of a class can\u2019t be inherited. These members can only be accessible from members of its own class only. It is used to secure the data.",
        "index": 108,
        "difficulty": -2.028306796934725,
        "correct": 1
    },
    {
        "question": "Which access specifier is used when no access specifier is used with a member of class (java)?",
        "options": [
            "Private",
            "Default",
            "Protected",
            "Public"
        ],
        "explanation": "Explanation: Default access is used if the programmer doesn\u2019t specify the specifier. This acts in a similar way as that of private. But since nothing is specified we call it to default access.",
        "index": 109,
        "difficulty": -2.025630907748069,
        "correct": 2
    },
    {
        "question": "Which specifier allows a programmer to make the private members which can be inherited?",
        "options": [
            "Private",
            "Default",
            "Protected",
            "Protected and default"
        ],
        "explanation": "Explanation: Protected access is used to make the members private. But those members can be inherited. This gives both security and code reuse capability to a program.",
        "index": 110,
        "difficulty": -2.004098532063491,
        "correct": 3
    },
    {
        "question": "Which among the following is false?",
        "options": [
            "Private members can be accessed using friend functions",
            "Member functions can be made private",
            "Default members can\u2019t be inherited",
            "Public members are accessible from other classes also"
        ],
        "explanation": "Explanation: The default members can be inherited. Provided that they are in same package. It works in a little different way from private access specifier.",
        "index": 111,
        "difficulty": -2.002601562001057,
        "correct": 3
    },
    {
        "question": "If a class has all the private members, which specifier will be used for its implicit constructor?",
        "options": [
            "Private",
            "Public",
            "Protected",
            "Default"
        ],
        "explanation": "Explanation: The implicit constructor will always be public. Otherwise the class wouldn\u2019t be able to have instances. In turn, no objects will be created and the class can only be used for inheritance.",
        "index": 112,
        "difficulty": -1.9984835157378518,
        "correct": 2
    },
    {
        "question": "If class A has add() function with protected access, and few other members in public. Then class B inherits class A privately. Will the user will not be able to call _________ from the object of class B.",
        "options": [
            "Any function of class A",
            "The add() function of class A",
            "Any member of class A",
            "Private, protected and public members of class A"
        ],
        "explanation": "Explanation: Class B object will not be able to call any of the private, protected and public members of class A. It is not only about the function add(), but all the members of class A will become private members of class B.",
        "index": 113,
        "difficulty": -1.9977930765586116,
        "correct": 4
    },
    {
        "question": "Which access specifier should be used in a class where the instances can\u2019t be created?",
        "options": [
            "Private default constructor",
            "All private constructors",
            "Only default constructor to be public",
            "Only default constructor to be protected"
        ],
        "explanation": "Explanation: All the constructors must be made private. This will restrict the instance of class to be made anywhere in the program. Since the constructors are private, no instance will be able to call them and hence won\u2019t be allocated with any memory space.",
        "index": 114,
        "difficulty": -1.9660725123732052,
        "correct": 2
    },
    {
        "question": "On which specifier\u2019s data, does the size of a class\u2019s object depend?",
        "options": [
            "All the data members are added",
            "Only private members are added",
            "Only public members are added",
            "Only default data members are added"
        ],
        "explanation": "Explanation: All the data members are counted to calculate the size of an object of a class. The data member access specifier doesn\u2019t play any role here. Hence all the data size will be added.",
        "index": 115,
        "difficulty": -1.9560316722686948,
        "correct": 1
    },
    {
        "question": "If class B inherits class A privately. And class B has a friend function. Will the friend function be able to access the private member of class A?",
        "options": [
            "Yes, because friend function can access all the members",
            "Yes, because friend function is of class B",
            "No, because friend function can only access private members of friend class",
            "No, because friend function can access private member of class A also"
        ],
        "explanation": "Explanation: The friend function of class B will not be able to access private members of class A. Since B is inheriting class A privately, the members will become private in class B. But private members of class A won\u2019t be inherited at all. Hence it won\u2019t be accessible.",
        "index": 116,
        "difficulty": -1.952493644000929,
        "correct": 3
    },
    {
        "question": "If an abstract class has all the private members, then _________",
        "options": [
            "No class will be able to implement members of abstract class",
            "Only single inheritance class can implement its members",
            "Only other enclosing classes will be able to implement those members",
            "No class will be able to access those members but can implement."
        ],
        "explanation": "Explanation: The classes which inherit the abstract class, won\u2019t be able to implement the members of abstract class. The private members will not be inherited. This will restrict the subclasses to implement those members.",
        "index": 117,
        "difficulty": -1.9422385290826856,
        "correct": 1
    },
    {
        "question": "Which access specifier should be used so that all the parent class members can be inherited and accessed from outside the class?",
        "options": [
            "Private",
            "Default or public",
            "Protected or private",
            "Public"
        ],
        "explanation": "Explanation: All the members must be of public access. So that the members can be inherited easily. Also, the members will be available from outside the class.",
        "index": 118,
        "difficulty": -1.9394078551381801,
        "correct": 4
    },
    {
        "question": "Which access specifier is usually used for data members of a class?",
        "options": [
            "Private",
            "Default",
            "Protected",
            "Public"
        ],
        "explanation": "Explanation: All the data members should be made private to ensure the highest security of data. In special cases we can use public or protected access, but it is advised to keep the data members private always.",
        "index": 119,
        "difficulty": -1.9191974754141161,
        "correct": 1
    },
    {
        "question": "Which specifier should be used for member functions of a class?",
        "options": [
            "Private",
            "Default",
            "Protected",
            "Public"
        ],
        "explanation": "Explanation: It is always advised that the member functions should be kept public so that those functions can be used from out of the class. This is usually done to ensure that the features provided by the class can be used at its maximum.",
        "index": 120,
        "difficulty": -1.9133699467927923,
        "correct": 4
    },
    {
        "question": "If a function has to be called only by using other member functions of the class, what should be the access specifier used for that function?",
        "options": [
            "Private",
            "Protected",
            "Public",
            "Default"
        ],
        "explanation": "Explanation: The function should be made private. In this way, the function will be available to be called only from the class member functions. Hence the function will be secure from the outside world.",
        "index": 121,
        "difficulty": -1.909599509839632,
        "correct": 1
    },
    {
        "question": "Which among the following best describes the protected specifier?",
        "options": [
            "Members are most secure and can\u2019t be used outside class",
            "Members are secure but can be used outside the class",
            "Members are secure as private, but can be inherited",
            "Members are secure like private, but can\u2019t be inherited"
        ],
        "explanation": "Explanation: The members which are made protected, are most secure if inheritance is not used. But, this facility is provided to keep those members private and with that, they can be inherited by other classes. This is done to make the code more flexible.",
        "index": 122,
        "difficulty": -1.895341257091682,
        "correct": 3
    },
    {
        "question": "If a constructor is defined in protected access, then?",
        "options": [
            "It\u2019s instance can be created inside the subclasses",
            "It\u2019s instance can be created anywhere in the program",
            "It\u2019s instance can be created inside the subclasses and main() function",
            "It\u2019s instance can be created inside the parent class only"
        ],
        "explanation": "Explanation: The instances will be allowed to be created only inside the sub classes. This is because the protected members will be inherited and hence the constructor too. This will allow the subclasses to call the constructor whenever an object is created.",
        "index": 123,
        "difficulty": -1.8898083407342783,
        "correct": 1
    },
    {
        "question": "What is the term used to indicate the variable and constants of a class?",
        "options": [
            "Data members",
            "Variables of class",
            "Data characters",
            "Constants"
        ],
        "explanation": "Explanation: The variables inside a class are termed data members of the class. It is not a mandatory rule but variables are used to refer to usual variables used in functions or globally. The term is given because the values stored in those variables represent some kind of data related to class.",
        "index": 124,
        "difficulty": -1.879594160747739,
        "correct": 1
    },
    {
        "question": "Data members ________________ (C++)",
        "options": [
            "Can be initialized with declaration in classes",
            "Can be initialized only with help of constructors",
            "Can be initialized either in declaration or by constructor",
            "Can\u2019t be initialized"
        ],
        "explanation": "Explanation: The data members are not property of class, those are property of the instances of the class. And the memory for the data members are not reserved until a constructor is called. Hence we use constructors for their initialization after the memory is reserved.",
        "index": 125,
        "difficulty": -1.8768735852709357,
        "correct": 2
    },
    {
        "question": "Which among the following is true for data members?",
        "options": [
            "Private data members can be initialized with declaration in class",
            "Static members are initialized in constructors",
            "Protected data members can be initialized in class directly",
            "Static data members are defined outside class, not in constructor"
        ],
        "explanation": "Explanation: Static members are not property of instances of classes. Those are shared by all the object of classes. Hence those are defined outside the constructor, so as to make them common for all the objects.",
        "index": 126,
        "difficulty": -1.863519085802114,
        "correct": 4
    },
    {
        "question": "What should be done for data member to be of user defined structure type?",
        "options": [
            "The structure must have been defined before class.",
            "The structure must have been defined after the class definition",
            "The structure must be predefined",
            "The structure type data members can\u2019t be used"
        ],
        "explanation": "Explanation: The structure must have been defined prior to its use. If the structure is not defined, then the memory space will not be allocated for its members. This leads to undefined use of new data types.",
        "index": 127,
        "difficulty": -1.8497183386187963,
        "correct": 1
    },
    {
        "question": "How many data members can a class contain?",
        "options": [
            "27",
            "255",
            "1024",
            "As many as required"
        ],
        "explanation": "Explanation: Any class can have as many data members as required. The only restriction that may arise is when there is not enough memory space. This gives flexibility to define a class with best properties possible.",
        "index": 128,
        "difficulty": -1.8393648376502714,
        "correct": 4
    },
    {
        "question": "How to access data members of a class?",
        "options": [
            "Dot operator",
            "Arrow operator",
            "Dot or arrow as required",
            "Dot, arrow or direct call"
        ],
        "explanation": "Explanation: The data members can never be called directly. Dot operator is used to access the members with help of object of class. Arrow is usually used if pointers are used.",
        "index": 129,
        "difficulty": -1.8389515242725192,
        "correct": 3
    },
    {
        "question": "To create a pointer to a private data member of a class, outside the class, which among the following is correct?",
        "options": [
            "Return the address of the private data member using a member function",
            "Access the private member using a pointer outside class",
            "Declare the member as pointer inside the class",
            "Not possible to create pointer to a private member"
        ],
        "explanation": "Explanation: We can call a public member function and return the address of any private data member. Though the pointer being returned must be defined inside class itself. And the returned address can be stored in a pointer.",
        "index": 130,
        "difficulty": -1.8374727960190962,
        "correct": 1
    },
    {
        "question": "Which among the following is true for use of setter() and getter() function?",
        "options": [
            "Considered best for manipulating data values",
            "Considered the only proper way to manipulate the values",
            "Considered specially for private members manipulation",
            "Considered a red flag, and not recommended for large scale use"
        ],
        "explanation": "Explanation: This concept of getter and setter functions is not acceptable if used too much. This is considered to be inappropriate in OOP perspective. Though it is commonly used, it doesn\u2019t work according to OOP concepts at some higher level of understanding.",
        "index": 131,
        "difficulty": -1.8371196678233055,
        "correct": 4
    },
    {
        "question": "Which among the following best describes member functions?",
        "options": [
            "Functions which are defined within the class",
            "Functions belonging a class",
            "Functions in public access of a class",
            "Functions which are private to class"
        ],
        "explanation": "Explanation: We can\u2019t say that only functions that are defined inside class are member functions. There can be some inherited functions. Though they doesn\u2019t belong to the class but are property of the objects once inheritance is used. So the nearest definition is functions belonging to a class.",
        "index": 132,
        "difficulty": -1.8342470739220975,
        "correct": 2
    },
    {
        "question": "How many types of member functions are generally there in C++?",
        "options": [
            "2",
            "3",
            "4",
            "5"
        ],
        "explanation": "Explanation: There are 5 types of member functions that are generally provided in C++. Namely, simple, static, const, inline and friend member functions. Member functions are specific to classes.",
        "index": 133,
        "difficulty": -1.824879726133462,
        "correct": 4
    },
    {
        "question": "How can a static member function be called in the main function?",
        "options": [
            "Using dot operator",
            "Using arrow operator",
            "Using dot or arrow operator",
            "Using dot, arrow or using scope resolution operator with class name"
        ],
        "explanation": "Explanation: The member functions can be called using only the dot operator or the arrow operator. But the static members can be called using directly the class name followed by the scope resolution operator and static member function name. This is useful when you don\u2019t have any object to call the member.",
        "index": 134,
        "difficulty": -1.819247467215577,
        "correct": 4
    },
    {
        "question": "What are inline member functions?",
        "options": [
            "Member functions which can be called without object",
            "Member functions whose definition is expanded in place of its call",
            "Member functions whose definition is faster than simple function",
            "Member function which is defined in single line"
        ],
        "explanation": "Explanation: The member functions whose definition is expanded at the call, and no jump to function and return happened, are termed as inline functions. This is used to make the program faster and more efficient.",
        "index": 135,
        "difficulty": -1.8053310235240194,
        "correct": 2
    },
    {
        "question": "What happens if non static members are used in static member function?",
        "options": [
            "Compile time error",
            "Runtime error",
            "Executes fine",
            "Executes if that member function is not used"
        ],
        "explanation": "Explanation: There must be specific memory space allocated for the data members before the static member functions uses them. But the space is not reserved if object is not declared. Hence only if static members are not used, it leads to compile time error.",
        "index": 136,
        "difficulty": -1.8037975549278498,
        "correct": 1
    },
    {
        "question": "Static member functions _____________",
        "options": [
            "Contains \u201cthis\u201d pointer for data members",
            "Contains \u201cthis\u201d pointer if used for member functions",
            "Doesn\u2019t contain \u201cthis\u201d pointer",
            "Doesn\u2019t contain \u201cthis\u201d pointer if member functions are referred"
        ],
        "explanation": "Explanation: The static member functions doesn\u2019t contain \u201cthis\u201d pointer. Static member functions can\u2019t be defined as const or volatile also. These are restrictions on static member functions.",
        "index": 137,
        "difficulty": -1.8029949027248247,
        "correct": 3
    },
    {
        "question": "How to access members of the class inside a member function?",
        "options": [
            "Using this pointer only",
            "Using dot operator",
            "Using arrow operator",
            "Used directly or with this pointer"
        ],
        "explanation": "Explanation: The members of a class can be used directly inside a member function. We can use this pointer when there is a conflict between data members of class and arguments/local function variable names.",
        "index": 138,
        "difficulty": -1.791972337323842,
        "correct": 4
    },
    {
        "question": "For overloading \u201c( )\u201d, \u201c[ ]\u201d or \u201c->\u201d operators, a class __________",
        "options": [
            "Must use static member functions",
            "Must use non-static member functions",
            "Must be non-static member and should not be friend of class",
            "Must use static member function or a friend member function"
        ],
        "explanation": "Explanation: For overloading those operators for a class, the class must use non-static member function so that doesn\u2019t remain common to all the objects, and each object can use it independently. The friend functions is also restricted so as to keep the security of data.",
        "index": 139,
        "difficulty": -1.7903756307442147,
        "correct": 3
    },
    {
        "question": "If a virtual member function is defined ___________",
        "options": [
            "It should not contain any body and defined by subclasses",
            "It must contain body and overridden by subclasses",
            "It must contain body and be overloaded",
            "It must not contain any body and should not be derived"
        ],
        "explanation": "Explanation: The virtual functions are defined using virtual keyword. These are made in order to make all the classes to define them as the class gets inherited. Increases code understanding.",
        "index": 140,
        "difficulty": -1.7753714514278547,
        "correct": 1
    },
    {
        "question": "Member functions of a generic class are _____________",
        "options": [
            "Not generic",
            "Automatically generic",
            "To be made generic explicitly",
            "Given default type as double"
        ],
        "explanation": "Explanation: When generic type is used in a class, the functions are automatically generic. This is so because the functions would use the same type as defined to make the class generic. The functions will get to know the type of data as soon as the generic class is used. It\u2019s inbuilt feature.",
        "index": 141,
        "difficulty": -1.7733718252664223,
        "correct": 2
    },
    {
        "question": "Member function of a class can ____________",
        "options": [
            "Access all the members of the class",
            "Access only Public members of the class",
            "Access only the private members of the class",
            "Access subclass members"
        ],
        "explanation": "Explanation: The member functions has access to all the members of the class. Whenever data members of a class, which might be private, have to be modified, we make use of these member functions. This is more secure way to manipulate data.",
        "index": 142,
        "difficulty": -1.770634742542112,
        "correct": 1
    },
    {
        "question": "What are local classes?",
        "options": [
            "Classes declared inside a package",
            "Classes declared inside a function",
            "Classes declared inside a class",
            "Classes declared inside structure"
        ],
        "explanation": "Explanation: The classes declared inside a package are available to all the functions and classes, hence can\u2019t be called local. This is somewhat similar concept that we use to denote variables of a function. The classes declared inside functions will be local to them.",
        "index": 143,
        "difficulty": -1.7660667505369518,
        "correct": 2
    },
    {
        "question": "All member functions of a local class must be ___________",
        "options": [
            "Defined outside class body",
            "Defined outside the function definition",
            "Defined inside the class body",
            "Defined at starting of program"
        ],
        "explanation": "Explanation: There is a restriction on where the member functions of the local class should be define. Those must be defined inside the class body only. This is to reduce the ambiguity and complexity of program.",
        "index": 144,
        "difficulty": -1.7617455019905839,
        "correct": 3
    },
    {
        "question": "Can local class members access/use the general local variables (except static, abstract etc.) of the function in which it is defined?",
        "options": [
            "Yes, it can access with arrow operator",
            "No, it can\u2019t access with dot operator",
            "Yes, it can access using dot operator",
            "No, it can\u2019t access In anyway"
        ],
        "explanation": "Explanation: The local variables of the functions are not available to the member functions of the class. This is done to reduce the ambiguity in variables and their access rules.",
        "index": 145,
        "difficulty": -1.7604970422646593,
        "correct": 4
    },
    {
        "question": "Which type of data can a local class access from the function in which it is defined?",
        "options": [
            "Static and extern",
            "Abstract and static",
            "Void and extern",
            "Const and static"
        ],
        "explanation": "Explanation: The local classes have this feature to access the static and extern variables of the function in which those are defined. This feature is available since these type of data are common to the program and is created only one time. Run time creation and destruction of these variables is not done. The only restriction that may apply is those members must be constants.",
        "index": 146,
        "difficulty": -1.7521399622643232,
        "correct": 1
    },
    {
        "question": "Local classes can access the type names and enumerators defined by the enclosing function.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: This is a little tricky part with local classes. Though the local class can\u2019t access the general variables of the function but can access the types that are defined inside the function. This is because the whole definition of that type would be existing inside the class.",
        "index": 147,
        "difficulty": -1.7381282275651764,
        "correct": 1
    },
    {
        "question": "Can static variables be declared inside a local class?",
        "options": [
            "Yes, with public access specifier",
            "Yes, anywhere as required",
            "No, not possible in private access specifier",
            "No, not possible anyway"
        ],
        "explanation": "Explanation: No, the static variables can\u2019t be declared inside a local class. This is because each time the function is called, all the variables get created again and are destroyed as soon as the function is returned. This would have been possible id the static variable was of function.",
        "index": 148,
        "difficulty": -1.7359203292631802,
        "correct": 4
    },
    {
        "question": "All the member functions of local classes are __________ by default.",
        "options": [
            "Static",
            "Inline",
            "Abstract",
            "Virtual"
        ],
        "explanation": "Explanation: All the members are defined inside the class body. And when the member functions are defined inside the class body, they are made inline by default. If the definition is too complex, those are made normal functions.",
        "index": 149,
        "difficulty": -1.73047655985452,
        "correct": 3
    },
    {
        "question": "The enclosing function has no special access to the members of the local class.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: This is a rule that the enclosing function doesn\u2019t have any special access to the members of the local class. This is done to maintain the security of class members. And to adhere to the rules of OOP.",
        "index": 150,
        "difficulty": -1.7176235538948286,
        "correct": 1
    },
    {
        "question": "Which language can use inheritance with local classes?",
        "options": [
            "Kotlin",
            "Java",
            "SmallTalk",
            "SAP ABAP"
        ],
        "explanation": "Explanation: Other language might support inheritance with local classes but those doesn\u2019t provide all the proper features of inheritance. Language SAP ABAP provides a way to implement inheritance with local classes efficiently.",
        "index": 151,
        "difficulty": -1.7119954130108974,
        "correct": 4
    },
    {
        "question": "How many local classes can be defined inside a single function?",
        "options": [
            "Only 1",
            "Only 3",
            "Only 5",
            "As many as required"
        ],
        "explanation": "Explanation: The local classes can be defined as required. There is no restriction on the number of local classes that can be defined inside a function. But all those classes must follow the rules and restrictions.",
        "index": 152,
        "difficulty": -1.6851229456576402,
        "correct": 4
    },
    {
        "question": "All the data members of local class must be ___________",
        "options": [
            "Defined with declaration",
            "Defined in constructor",
            "Declared and defined in constructor",
            "Declared using a member function"
        ],
        "explanation": "Explanation: The data members follow the same rules as of simple classes. Hence the data members must be declared first. Then their definition must be given using the constructors.",
        "index": 153,
        "difficulty": -1.6803078613237068,
        "correct": 2
    },
    {
        "question": "Can two different functions have local class with same name?",
        "options": [
            "Yes, since local",
            "No, names must be different",
            "No, scope doesn\u2019t work here",
            "No, ambiguity arises"
        ],
        "explanation": "Explanation: The local classes can have same name if they belong to different functions. The classes would be local to those specific functions and hence can have same name. This is same as that of local variables concept.",
        "index": 154,
        "difficulty": -1.6660898878224204,
        "correct": 1
    },
    {
        "question": "What is the scope of local class?",
        "options": [
            "Within the class only",
            "Within the function",
            "Within the program",
            "One time creation and live till end of program"
        ],
        "explanation": "Explanation: The scope of a local class is limited only within the function definition. The function can use the class as usual as local variables. The class gets destroyed as soon as the function is returned.",
        "index": 155,
        "difficulty": -1.6576524526461431,
        "correct": 2
    },
    {
        "question": "Can a function, other than the enclosing function of local class, access the class members?",
        "options": [
            "Yes, using object",
            "Yes, using direct call",
            "Yes, using pointer",
            "No, can\u2019t access"
        ],
        "explanation": "Explanation: The local classes are local to the specific enclosing function. Other functions can\u2019t access the class. Even if the pointers are used, the class must be alive when the pointer is used. But this will not happen if the enclosing function is returned.",
        "index": 156,
        "difficulty": -1.651220787504475,
        "correct": 4
    },
    {
        "question": "Which among the following is the main advantage of using local classes?",
        "options": [
            "Make program more efficient",
            "Makes program execution faster",
            "Helps to add extra functionality to a function",
            "Helps to add more members to a function"
        ],
        "explanation": "Explanation: The closest answer is to add more functionalities to a function or to make some specific functions to be generic. Adding more members to a function can be done directly but to add some special functionality that are encapsulated, can be done using local classes.",
        "index": 157,
        "difficulty": -1.6485336275500921,
        "correct": 3
    },
    {
        "question": "Which among the following best describes a nested class?",
        "options": [
            "Class inside a class",
            "Class inside a function",
            "Class inside a package",
            "Class inside a structure"
        ],
        "explanation": "Explanation: If a class is defined inside another class, the inner class is termed as nested class. The inner class is local to the enclosing class. Scope matters a lot here.",
        "index": 158,
        "difficulty": -1.6313781164553578,
        "correct": 1
    },
    {
        "question": "Which feature of OOP reduces the use of nested classes?",
        "options": [
            "Encapsulation",
            "Inheritance",
            "Binding",
            "Abstraction"
        ],
        "explanation": "Explanation: Using inheritance we can have the security of the class being inherited. The subclass can access the members of parent class. And have more feature than a nested class being used.",
        "index": 159,
        "difficulty": -1.6299452109081163,
        "correct": 2
    },
    {
        "question": "How many categories are nested classes divided into?",
        "options": [
            "2",
            "3",
            "4",
            "5"
        ],
        "explanation": "Explanation: The nested classes are divided into two main categories. Namely, Static and non-static. The categories define how the classes can be used inside another class.",
        "index": 160,
        "difficulty": -1.6136296086734458,
        "correct": 1
    },
    {
        "question": "Non-static nested classes have access to _____________ from enclosing class.",
        "options": [
            "Private members",
            "Protected members",
            "Public members",
            "All the members"
        ],
        "explanation": "Explanation: The non-static nested class can access all the members of the enclosing class. All the data members and member functions can be accessed from the nested class. Even if the members are private, they can be accessed.",
        "index": 161,
        "difficulty": -1.60588107038367,
        "correct": 4
    },
    {
        "question": "Static nested classes doesn\u2019t have access to _________________ from enclosing class.",
        "options": [
            "Private members",
            "Protected members",
            "Public members",
            "Any other members"
        ],
        "explanation": "Explanation: The static nested class doesn\u2019t have access to any other members of the enclosing class. This is a rule that is made to ensure that only the data which can be common to all the object is being accessed by the static nested class.",
        "index": 162,
        "difficulty": -1.6039038458888566,
        "correct": 4
    },
    {
        "question": "The nested class can be declared ___________________",
        "options": [
            "Public",
            "Private",
            "Protected",
            "Public, Protected, Private or Package private"
        ],
        "explanation": "Explanation: The nested class can be declared with any specifier, unlike the outer classes which can only be declared public or package private. This is flexibility given for the nested class being a member of enclosing class.",
        "index": 163,
        "difficulty": -1.589505969693812,
        "correct": 4
    },
    {
        "question": "Use of nested class ____________ encapsulation.",
        "options": [
            "Increases",
            "Decreases",
            "Doesn\u2019t affect",
            "Slightly decreases"
        ],
        "explanation": "Explanation: The use of nested class increases encapsulation as the inner class is getting even more grouped into the enclosing class. Firstly the class encapsulate the data, having nested classes can increase the encapsulation even further.",
        "index": 164,
        "difficulty": -1.5804639776117815,
        "correct": 1
    },
    {
        "question": "Which among the following is the correct advantage/disadvantage of nested classes?",
        "options": [
            "Makes the code more complex",
            "Makes the code unreadable",
            "Makes the code efficient and readable",
            "Makes the code multithreaded"
        ],
        "explanation": "Explanation: The use of nested classes makes the code more streamed towards a single concept. This allows to group the most similar and related classes together and makes it even more efficient and readable.",
        "index": 165,
        "difficulty": -1.5793043766907604,
        "correct": 3
    },
    {
        "question": "How to access static nested classes?",
        "options": [
            "OuterClass.StaticNestedClass",
            "OuterClass->StaticNestedClass",
            "OuterClass(StaticNestedClass)",
            "OuterClass[StaticNestedClass]"
        ],
        "explanation": "Explanation: Like any other member of the class, the static nested class uses the dot operator to be accessed. The reason behind is, the static classes can\u2019t work with instances, hence we use enclosing class name to access static nested class.",
        "index": 166,
        "difficulty": -1.56470716867716,
        "correct": 1
    },
    {
        "question": "A nested class can have its own static members.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The nested classes are associated with the object of the enclosing class. Hence have direct access to the members of that object. Hence the inner class can\u2019t have any static members of its own. Otherwise the rule of static members would be violated using enclosing class instance.",
        "index": 167,
        "difficulty": -1.5572686320646132,
        "correct": 2
    },
    {
        "question": "How to create object of the inner class?",
        "options": [
            "OuterClass.InnerClass innerObject = outerObject.new InnerClass();",
            "OuterClass.InnerClass innerObject = new InnerClass();",
            "InnerClass innerObject = outerObject.new InnerClass();",
            "OuterClass.InnerClass = outerObject.new InnerClass();"
        ],
        "explanation": "Explanation: An instance of inner class can exist only within instance of outer class. To instantiate the inner class, one must instantiate the outer class first. This can be done by the correct syntax above.",
        "index": 168,
        "difficulty": -1.5493633032359724,
        "correct": 1
    },
    {
        "question": "In how many ways can an object be passed to a function?",
        "options": [
            "1",
            "2",
            "3",
            "4"
        ],
        "explanation": "Explanation: The objects can be passed in three ways. Pass by value, pass by reference and pass by address. These are the general ways to pass the objects to a function.",
        "index": 169,
        "difficulty": -1.542124170711184,
        "correct": 3
    },
    {
        "question": "If an object is passed by value _____________",
        "options": [
            "A new copy of object is created implicitly",
            "The object itself is used",
            "Address of the object is passed",
            "A new object is created with new random values"
        ],
        "explanation": "Explanation: When an object is passed by value, a new object is created implicitly. This new object uses the implicit values assignment, same as that of the object being passed.",
        "index": 170,
        "difficulty": -1.5237578477199103,
        "correct": 1
    },
    {
        "question": "Pass by address passes the address of object _________ and pass by reference passes the address of the object _________",
        "options": [
            "Explicitly, explicitly",
            "Implicitly, implicitly",
            "Explicitly, Implicitly",
            "Implicitly, explicitly"
        ],
        "explanation": "Explanation: Pass by address uses the explicit address passing to the function whereas pass by reference implicitly passes the address of the object.",
        "index": 171,
        "difficulty": -1.516516910745758,
        "correct": 3
    },
    {
        "question": "If an object is passed by reference, the changes made in the function ___________",
        "options": [
            "Are reflected to the main object of caller function too",
            "Are reflected only in local scope of the called function",
            "Are reflected to the copy of the object that is made during pass",
            "Are reflected to caller function object and called function object also"
        ],
        "explanation": "Explanation: When an object is passed by reference, its address is passed implicitly. This will make changes to the main function whenever any modification is done.",
        "index": 172,
        "difficulty": -1.4971978817297038,
        "correct": 1
    },
    {
        "question": "Constructor function is not called when an object is passed to a function, will its destructor be called when its copy is destroyed?",
        "options": [
            "Yes, depending on code",
            "Yes, must be called",
            "No, since no constructor was called",
            "No, since same object gets used"
        ],
        "explanation": "Explanation: Even though the constructor is not called when the object is passed to a function, the copy of the object is still created, where the values of the members are same. When the object have to be destroyed, the destructor is called to free the memory and resources that the object might have reserved.",
        "index": 173,
        "difficulty": -1.496300487520633,
        "correct": 2
    },
    {
        "question": "When an object is returned by a function, a _______________ is automatically created to hold the return value.",
        "options": [
            "Temporary object",
            "Virtual object",
            "New object",
            "Data member"
        ],
        "explanation": "Explanation: The temporary object is created. It holds the return value. The values gets assigned as required, and the temporary object gets destroyed.",
        "index": 174,
        "difficulty": -1.4894040760474174,
        "correct": 1
    },
    {
        "question": "Is the destruction of temporary object safe (while returning object)?",
        "options": [
            "Yes, the resources get free to use",
            "Yes, other objects can use the memory space",
            "No, unexpected side effects may occur",
            "No, always gives rise to exceptions"
        ],
        "explanation": "Explanation: The destruction of temporary variable may give rise to unexpected logical errors. Consider the destructor which may free the dynamically allocated memory. But this may abort the program if another is still trying to copy the values from that dynamic memory.",
        "index": 175,
        "difficulty": -1.4851983051289501,
        "correct": 3
    },
    {
        "question": "How to overcome the problem arising due to destruction of temporary object?",
        "options": [
            "Overloading insertion operator",
            "Overriding functions can be used",
            "Overloading parenthesis or returning object",
            "Overloading assignment operator and defining copy constructor"
        ],
        "explanation": "Explanation: The problem can be solved by overloading the assignment operator to get the values that might be getting returned while the destructor free the dynamic memory. Defining copy constructor can help us to do this in even simpler way.",
        "index": 176,
        "difficulty": -1.4811433821314433,
        "correct": 4
    },
    {
        "question": "How many objects can be returned at once?",
        "options": [
            "Only 1",
            "Only 2",
            "Only 16",
            "As many as required"
        ],
        "explanation": "Explanation: Like any other value, only one object can be returned at ones. The only possible way to return more than one object is to return address of an object array. But that again comes under returning object pointer.",
        "index": 177,
        "difficulty": -1.4665839631701023,
        "correct": 1
    },
    {
        "question": "What is reference to an object?",
        "options": [
            "It is address of an object",
            "It is address of where the variables and methods of object are stored",
            "It is pointer having address of an object",
            "It is address of only variables and not the methods of an object"
        ],
        "explanation": "Explanation: Reference indicates the address where the object\u2019s variables and methods are stored. It is not actual address of the object. This is done to directly use the variables and methods whenever required.",
        "index": 178,
        "difficulty": -1.457866255361312,
        "correct": 2
    },
    {
        "question": "Whenever an object is assigned to a variable or passed to a method ________________",
        "options": [
            "Actually the objects aren\u2019t used",
            "Actually only the objects are used",
            "Actually a pointer to an object is used",
            "Actually copy of object is used"
        ],
        "explanation": "Explanation: Whenever an object is assigned to a variable or passed to a method, we aren\u2019t actually using objects there. Actually the reference to the objects is used. The reference makes a lot of difference as the main object may or may not get affected depending on the code.",
        "index": 179,
        "difficulty": -1.4461638873963472,
        "correct": 1
    },
    {
        "question": "Does use of object reference in assignment or passing means copy of the object is being used?",
        "options": [
            "No, because the copy would create a new temporary variable",
            "No, because the copy would not help to make changes to main object",
            "Yes, because the reference directly means using address",
            "Yes, because the reference directly means the constructors are involved"
        ],
        "explanation": "Explanation: We can\u2019t say that the reference involves constructors in passing the objects to some method. The reference is used to denote the addresses and hence to point to the main object itself. There is no copy involved.",
        "index": 180,
        "difficulty": -1.4387187752058455,
        "correct": 3
    },
    {
        "question": "What does memory allocation for objects mean?",
        "options": [
            "Actual creation and memory allocation for object members",
            "Creation of member functions",
            "Creation of data members for a class",
            "Actual creation and data declaration for object members"
        ],
        "explanation": "Explanation: The memory allocated for the object members indicates actual creation of the object members. This is known as memory allocation for object.",
        "index": 181,
        "difficulty": -1.426912302548055,
        "correct": 1
    },
    {
        "question": "Where is the memory allocated for the objects?",
        "options": [
            "HDD",
            "Cache",
            "RAM",
            "ROM"
        ],
        "explanation": "Explanation: The memory for the objects or any other data is allocated in RAM initially. This is while we run a program all the memory allocation takes place in some RAM segments. Arrays in heap and local members in stack etc.",
        "index": 182,
        "difficulty": -1.4258483391289292,
        "correct": 3
    },
    {
        "question": "When is the memory allocated for an object?",
        "options": [
            "At declaration of object",
            "At compile time",
            "When object constructor is called",
            "When object is initialized to another object"
        ],
        "explanation": "Explanation: The object memory allocation takes place when the object constructor is called. Declaration of an object doesn\u2019t mean that memory is allocated for its members. If object is initialized with another object, it may just get a reference to the previously created object.",
        "index": 183,
        "difficulty": -1.4113761065824793,
        "correct": 3
    },
    {
        "question": "Using new is type safe as _______________________",
        "options": [
            "It require to be specified with type of data",
            "It doesn\u2019t require to be specified with type of data",
            "It requires the name of data",
            "It allocated memory for the data"
        ],
        "explanation": "Explanation: The new is type safe because we don\u2019t have to specify the type of data that have to be allocated with memory. We can directly use it with data name. Name of the data doesn\u2019t matter though for type of memory allocation though.",
        "index": 184,
        "difficulty": -1.4105878808589452,
        "correct": 2
    },
    {
        "question": "Which of the following function can be used for dynamic memory allocation of objects?",
        "options": [
            "malloc()",
            "calloc()",
            "create()",
            "malloc() and calloc()"
        ],
        "explanation": "Explanation: The malloc() function can be used to allocate dynamic memory for objects. Function calloc() can also be use. These functions differ in the way they allocate memory for objects.",
        "index": 185,
        "difficulty": -1.4096001956572637,
        "correct": 4
    },
    {
        "question": "What is an array of objects?",
        "options": [
            "An array of instances of class represented by single name",
            "An array of instances of class represented by more than one name",
            "An array of instances which have more than 2 instances",
            "An array of instances which have different types"
        ],
        "explanation": "Explanation: The array of objects an array of instances of a class. The array is represented by a single name. The array name is itself a pointer. Array name represents the first object.",
        "index": 186,
        "difficulty": -1.4077049604011294,
        "correct": 1
    },
    {
        "question": "Which among the following is a mandatory condition for array of objects?",
        "options": [
            "All the objects should be of different class",
            "All the objects should be of same program classes",
            "All the objects should be of same class",
            "All the objects should have different data"
        ],
        "explanation": "Explanation: The objects of an array must be of same class. This is mandatory because array is set of same type of elements. The objects of same class are considered to be of same type.",
        "index": 187,
        "difficulty": -1.3962874584129106,
        "correct": 3
    },
    {
        "question": "What is the type of elements of array of objects?",
        "options": [
            "Class",
            "Void",
            "String",
            "Null"
        ],
        "explanation": "Explanation: The class itself is the type of elements of array of objects. All the objects possess the same properties. Like any other primitive data type, the objects are of their respective class type.",
        "index": 188,
        "difficulty": -1.3824716743077599,
        "correct": 1
    },
    {
        "question": "Which among the following is the main use of object?",
        "options": [
            "To create instance of a function",
            "To create instance of a program",
            "To create instance of class",
            "To create instance of structures"
        ],
        "explanation": "Explanation: The objects are used to create an instance of a class. Objects can represent a class in an independent form. The basic blueprint, that contains the information of the type of data that can be stored in an object, is given by the class.",
        "index": 189,
        "difficulty": -1.37453710781414,
        "correct": 3
    },
    {
        "question": "Which among the following is not a property of an object?",
        "options": [
            "Identity",
            "Properties",
            "Attributes",
            "Names"
        ],
        "explanation": "Explanation: The names are not property of an object. The identity can be in any form like address or name of object but name can\u2019t be termed as only identity of an object. The objects contain attributes that define what type of data an object can store.",
        "index": 190,
        "difficulty": -1.3715170151261935,
        "correct": 4
    },
    {
        "question": "What is function object?",
        "options": [
            "An object with a single function",
            "An object with only functions",
            "An object with more than one function",
            "An object with no functions"
        ],
        "explanation": "Explanation: A function object is an object with single function. In C++ a function object can be like operator() function. This acts more like a function rather than an object.",
        "index": 191,
        "difficulty": -1.36097154162441,
        "correct": 1
    },
    {
        "question": "Immutable object are used ______________________",
        "options": [
            "To set up as a fixed state",
            "To set up variable object",
            "To set up an object of abstract class",
            "To set up an object of derived class"
        ],
        "explanation": "Explanation: An immutable object can be created for an object which has to be fixed with values. The object data will not be changed throughout the program. This can be useful to eliminate the unintentional changes in the data of object.",
        "index": 192,
        "difficulty": -1.3540064863442571,
        "correct": 1
    },
    {
        "question": "Which object can be used to contain other objects?",
        "options": [
            "First class object",
            "Derived class object",
            "Container object",
            "Enclosure object"
        ],
        "explanation": "Explanation: A container object can be used to contain other objects. Container object is an ADT. Its object are collection of other objects. Some specific rules apply to these types of objects.",
        "index": 193,
        "difficulty": -1.3521202048876233,
        "correct": 3
    },
    {
        "question": "A factory object is used ______________________",
        "options": [
            "To create new classes",
            "To create new function",
            "To create new data members",
            "To create new objects"
        ],
        "explanation": "Explanation: The factory object is an object that can be used to create other objects. If it is seen formally, it behaves like a method that will return object on its use. The object returned is assumed to be a new object.",
        "index": 194,
        "difficulty": -1.348109616432022,
        "correct": 4
    },
    {
        "question": "What are singleton objects?",
        "options": [
            "The only two objects of a class throughout the program",
            "The only object of a class throughout the program",
            "The objects that are alive throughout the program",
            "The objects that are created and then deleted without use"
        ],
        "explanation": "Explanation: If a class has only one object created and that is the only object of the class. Then the object is known as the singleton object. But only if that object is the only object of the class and no other object is created for that class.",
        "index": 195,
        "difficulty": -1.3425339023997156,
        "correct": 2
    },
    {
        "question": "Object cout and cin _________________",
        "options": [
            "Can be used directly with << and >> symbols respectively",
            "Can be used directly with >> and << symbols respectively",
            "Must be used as a function which accepts 2 arguments",
            "Must be used as a function which accepts 3 arguments"
        ],
        "explanation": "Explanation: The cin and cout objects can be used directly with the >> and << operators respectively. The objects are of iostream class. Class iostream is an inbuilt class.",
        "index": 196,
        "difficulty": -1.341376951918764,
        "correct": 1
    },
    {
        "question": "Objects type ____________________",
        "options": [
            "Can be changed in runtime",
            "Can\u2019t be changed in runtime",
            "Can be changed in compile time",
            "May or may not get changed"
        ],
        "explanation": "Explanation: The object types are always fixed. Once the object is created of a specific type then it can\u2019t be changed. Neither at runtime nor at compile time.",
        "index": 197,
        "difficulty": -1.3358213654162217,
        "correct": 2
    },
    {
        "question": "An object can be used to represent _________________",
        "options": [
            "A real world entity",
            "A real function",
            "Some real data only",
            "Some function only"
        ],
        "explanation": "Explanation: The objects are actually meant to represent an entity. The classes are real world object\u2019s blueprint. The classes then are used to create an entity representation.",
        "index": 198,
        "difficulty": -1.335461087414092,
        "correct": 1
    },
    {
        "question": "Objects can be used _____________________",
        "options": [
            "To access any member of a class",
            "To access only public members of a class",
            "To access only protected members of a class",
            "To access only private members of a class"
        ],
        "explanation": "Explanation: The objects are created for a specific class. Then the objects can be used to access the public members of a class. The members can be the data members or the member functions of the class.",
        "index": 199,
        "difficulty": -1.313987895250322,
        "correct": 2
    },
    {
        "question": "Which among the following is not a use of object?",
        "options": [
            "Defining a member function",
            "Accessing data members",
            "Creating instance of a class",
            "Using class members"
        ],
        "explanation": "Explanation: The objects can\u2019t be used to define any member function. Member functions must be defined by the class only. Objects can only access the members and use them.",
        "index": 200,
        "difficulty": -1.2958826522866127,
        "correct": 1
    },
    {
        "question": "Which object can be used to access the standard input?",
        "options": [
            "System.inner",
            "cin",
            "System.stdin",
            "console.input"
        ],
        "explanation": "Explanation: Object cin can be used to take input from the standard input. It is used in C++. In java we can use System.in for the standard input stream. The syntax changes from language to language.",
        "index": 201,
        "difficulty": -1.2803748038123293,
        "correct": 2
    },
    {
        "question": "A single object can be used __________________",
        "options": [
            "As only two class types at a time",
            "As only three class types at a time",
            "As only one class type at a time",
            "As of as many class types as required"
        ],
        "explanation": "Explanation: The object can be of only one type. The type of an object can\u2019t be changed. Object type is mandatory to be of one class type to ensure the type and number of data members it have.",
        "index": 202,
        "difficulty": -1.2730424544310983,
        "correct": 3
    },
    {
        "question": "If same object name is given to different objects of different class then _____________",
        "options": [
            "Its compile time error",
            "Its runtime error",
            "It\u2019s not an error",
            "Program suns smooth"
        ],
        "explanation": "Explanation: It is a compile time error as the compiler doesn\u2019t allow the same name objects to be declared more than once. Compiler produces multiple declaration errors. Every object must have a different name.",
        "index": 203,
        "difficulty": -1.271597454743826,
        "correct": 1
    },
    {
        "question": "Which among the following best describes abstract classes?",
        "options": [
            "If a class has more than one virtual function, it\u2019s abstract class",
            "If a class have only one pure virtual function, it\u2019s abstract class",
            "If a class has at least one pure virtual function, it\u2019s abstract class",
            "If a class has all the pure virtual functions only, then it\u2019s abstract class"
        ],
        "explanation": "Explanation: The condition for a class to be called abstract class is that it must have at least one pure virtual function. The keyword abstract must be used while defining abstract class in java.",
        "index": 204,
        "difficulty": -1.2694257135299227,
        "correct": 3
    },
    {
        "question": "Can abstract class have main() function defined inside it?",
        "options": [
            "Yes, depending on return type of main()",
            "Yes, always",
            "No, main must not be defined inside abstract class",
            "No, because main() is not abstract function"
        ],
        "explanation": "Explanation: This is a property of abstract class. It can define main() function inside it. There is no restriction on its definition and implementation.",
        "index": 205,
        "difficulty": -1.2628168677549736,
        "correct": 2
    },
    {
        "question": "If there is an abstract method in a class then, ________________",
        "options": [
            "Class must be abstract class",
            "Class may or may not be abstract class",
            "Class is generic",
            "Class must be public"
        ],
        "explanation": "Explanation: It is a rule that if a class have even one abstract method, it must be an abstract class. If this rule was not made, the abstract methods would have got skipped to get defined in some places which are undesirable with the idea of abstract class.",
        "index": 206,
        "difficulty": -1.2488804227513528,
        "correct": 1
    },
    {
        "question": "If a class is extending/inheriting another abstract class having abstract method, then _______________________",
        "options": [
            "Either implementation of method or making class abstract is mandatory",
            "Implementation of the method in derived class is mandatory",
            "Making the derived class also abstract is mandatory",
            "It\u2019s not mandatory to implement the abstract method of parent class"
        ],
        "explanation": "Explanation: Either of the two things must be done, either implementation or declaration of class as abstract. This is done to ensure that the method intended to be defined by other classes gets defined at every possible class.",
        "index": 207,
        "difficulty": -1.2352071122760466,
        "correct": 1
    },
    {
        "question": "Abstract class A has 4 virtual functions. Abstract class B defines only 2 of those member functions as it extends class A. Class C extends class B and implements the other two member functions of class A. Choose the correct option below.",
        "options": [
            "Program won\u2019t run as all the methods are not defined by B",
            "Program won\u2019t run as C is not inheriting A directly",
            "Program won\u2019t run as multiple inheritance is used",
            "Program runs correctly"
        ],
        "explanation": "Explanation: The program runs correctly. This is because even class B is abstract so it\u2019s not mandatory to define all the virtual functions. Class C is not abstract but all the virtual functions have been implemented will that class.",
        "index": 208,
        "difficulty": -1.232364996986583,
        "correct": 4
    },
    {
        "question": "Abstract classes can ____________________ instances.",
        "options": [
            "Never have",
            "Always have",
            "Have array of",
            "Have pointer of"
        ],
        "explanation": "Explanation: When an abstract class is defined, it won\u2019t be having the implementation of at least one function. This will restrict the class to have any constructor. When the class doesn\u2019t have constructor, there won\u2019t be any instance of that class.",
        "index": 209,
        "difficulty": -1.2237522484027854,
        "correct": 1
    },
    {
        "question": "We ___________________ to an abstract class.",
        "options": [
            "Can create pointers",
            "Can create references",
            "Can create pointers or references",
            "Can\u2019t create any reference, pointer or instance"
        ],
        "explanation": "Explanation: Even though there can\u2019t be any instance of abstract class. We can always create pointer or reference to abstract class. The member functions which have some implementation inside abstract itself can be used with these references.",
        "index": 210,
        "difficulty": -1.2210603798284865,
        "correct": 3
    },
    {
        "question": "Which among the following is an important use of abstract classes?",
        "options": [
            "Header files",
            "Class Libraries",
            "Class definitions",
            "Class inheritance"
        ],
        "explanation": "Explanation: The abstract classes can be used to create a generic, extensible class library that can be used by other programmers. This helps us to get some already implemented codes and functions that might have not been provided by the programming language itself.",
        "index": 211,
        "difficulty": -1.2135859756300915,
        "correct": 2
    },
    {
        "question": "Use of pointers or reference to an abstract class gives rise to which among the following feature?",
        "options": [
            "Static Polymorphism",
            "Runtime polymorphism",
            "Compile time Polymorphism",
            "Polymorphism within methods"
        ],
        "explanation": "Explanation: The runtime polymorphism is supported by reference and pointer to an abstract class. This relies upon base class pointer and reference to select the proper virtual function.",
        "index": 212,
        "difficulty": -1.2127637520727865,
        "correct": 2
    },
    {
        "question": "The abstract classes in java can _________________",
        "options": [
            "Implement constructors",
            "Can\u2019t implement constructor",
            "Can implement only unimplemented methods",
            "Can\u2019t implement any type of constructor"
        ],
        "explanation": "Explanation: The abstract classes in java can define a constructor. Even though instance can\u2019t be created. But in this way, only during constructor chaining, constructor can be called. When instance of concrete implementation class is created, it\u2019s known as constructor chaining.",
        "index": 213,
        "difficulty": -1.1963731632118677,
        "correct": 1
    },
    {
        "question": "Abstract class can\u2019t be final in java.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: If an abstract class is made final in java, it will stop the abstract class from being extended. And if the class is not getting extended, there won\u2019t be another class to implement the virtual functions. Due to this contradicting fact, it can\u2019t be final in java.",
        "index": 214,
        "difficulty": -1.1950015738349706,
        "correct": 1
    },
    {
        "question": "Can abstract classes have static methods (Java)?",
        "options": [
            "Yes, always",
            "Yes, but depends on code",
            "No, never",
            "No, static members can\u2019t have different values"
        ],
        "explanation": "Explanation: There is no restriction on declaring static methods. The only condition is that the virtual functions must have some definition in the program.",
        "index": 215,
        "difficulty": -1.1937164526690216,
        "correct": 1
    },
    {
        "question": "It is _________________________ to have an abstract method.",
        "options": [
            "Not mandatory for an static class",
            "Not mandatory for a derived class",
            "Not mandatory for an abstract class",
            "Not mandatory for parent class"
        ],
        "explanation": "Explanation: Derived, parent and static classes can\u2019t have abstract method (We can\u2019t say what type of these classes is). And for abstract class it\u2019s not mandatory to have abstract method. But if any abstract method is there inside a class, then class must be abstract type.",
        "index": 216,
        "difficulty": -1.1907259800624987,
        "correct": 3
    },
    {
        "question": "How many abstract classes can a single program contain?",
        "options": [
            "At most 1",
            "At least 1",
            "At most 127",
            "As many as required"
        ],
        "explanation": "Explanation: There is no restriction on the number of abstract classes that can be defined inside a single program. The programs can use as many abstract classes as required. But the functions with no body must be implemented.",
        "index": 217,
        "difficulty": -1.1832185508101023,
        "correct": 4
    },
    {
        "question": "Is it necessary that all the abstract methods must be defined from an abstract class?",
        "options": [
            "Yes, depending on code",
            "Yes, always",
            "No, never",
            "No, if function is not used, no definition is required"
        ],
        "explanation": "Explanation: That is the rule of programming language that each function declared, must have some definition. There can\u2019t be some abstract method that remains undefined. Even if it\u2019s there, it would result in compile time error.",
        "index": 218,
        "difficulty": -1.1750436937099547,
        "correct": 2
    },
    {
        "question": "A template class can have _____________",
        "options": [
            "More than one generic data type",
            "Only one generic data type",
            "At most two data types",
            "Only generic type of integers and not characters"
        ],
        "explanation": "Explanation: The template class can support more than one data type. The only thing is to add all the data types required in a list separated by comma within template specification.",
        "index": 219,
        "difficulty": -1.170771728758142,
        "correct": 1
    },
    {
        "question": "Which among the following is the proper syntax for the template class?",
        "options": [
            "template <typename T1, typename T2>;",
            "Template <typename T1, typename T2>;",
            "template <typename T> T named(T x, T y){  }",
            "Template <typename T1, typename T2> T1 named(T1 x, T2 y){  }"
        ],
        "explanation": "Explanation: The syntax must start with keyword template, case sensitive. Then it should include the typename and a variable to denote it. Then whenever that variable is used, it replaces it with the data type needed.",
        "index": 220,
        "difficulty": -1.1641811737757222,
        "correct": 3
    },
    {
        "question": "Can default arguments be used with the template class?",
        "options": [
            "Yes, in some special cases",
            "Yes, always",
            "No, it must satisfy some specific conditions first",
            "No, it can\u2019t be done"
        ],
        "explanation": "Explanation: The template class can use default arguments. This is used to specify the data type to be considered if it is not specified while passing to the generic class. The default type will be used.",
        "index": 221,
        "difficulty": -1.1596853152024769,
        "correct": 2
    },
    {
        "question": "What is the syntax to use explicit class specialization?",
        "options": [
            "template <int> class myClass<>{  }",
            "template <int> class myClass<int>{  }",
            "template <> class myClass<>{  }",
            "template <> class myClass<int>{  }"
        ],
        "explanation": "Explanation: The class specialization is creation of explicit specialization of a generic class. We have to use template<> constructor for this to work. It works in the same way as with explicit function specialization.",
        "index": 222,
        "difficulty": -1.1472202557483588,
        "correct": 4
    },
    {
        "question": "Which is the most significant feature that arises by using template classes?",
        "options": [
            "Code readability",
            "Ease in coding",
            "Code reusability",
            "Modularity in code"
        ],
        "explanation": "Explanation: The code reusability is the feature that becomes more powerful with the use of template classes. You can generate a single code that can be used in variety of programming situations.",
        "index": 223,
        "difficulty": -1.1384153266127641,
        "correct": 3
    },
    {
        "question": "A template class defines the form of a class _____________________ it will operate.",
        "options": [
            "With full specification of the data on which",
            "With full specification of the functions on which",
            "Without full specification of the data on which",
            "Without full specification of the functions on which"
        ],
        "explanation": "Explanation: The template classes can accept all types of data types. There is no need to specify the data on which the class has to operate. Hence it gives us flexibility to code without worrying about the type of data that might be used in the code.",
        "index": 224,
        "difficulty": -1.1147538295626784,
        "correct": 3
    },
    {
        "question": "What are the two specializations of I/O template classes in C++?",
        "options": [
            "16-bit character and wide characters",
            "8-bit character and wide characters",
            "32-bit character and locale characters",
            "64-bit characters and locale characters"
        ],
        "explanation": "Explanation: The I/O specialization is made with wide character and 8-bit characters. Wide characters are used to store the characters that might take more than 1 byte of space in memory or any size that is different from the one that the machine is using.",
        "index": 225,
        "difficulty": -1.1025618504492287,
        "correct": 2
    },
    {
        "question": "Can typeid() function be used with the object of generic classes?",
        "options": [
            "Yes, only if default type is given",
            "Yes, always",
            "No, generic data can\u2019t be determined",
            "No, never possible"
        ],
        "explanation": "Explanation: The typeid() function can be used with the objects of generic classes. An instance of a template class will take the type of data that is being used with it. Hence when typeid() function is used, the data type would have already been defined and hence we can get desired result from typeid() function.",
        "index": 226,
        "difficulty": -1.1017842063078545,
        "correct": 2
    },
    {
        "question": "The _____________ class is a specialization of a more general template class.",
        "options": [
            "String",
            "Integer",
            "Digit",
            "Math"
        ],
        "explanation": "Explanation: The string class is more specialized. Since the string must be able to store any kind of data that is given to the string. Hence it needs maximum specialization.",
        "index": 227,
        "difficulty": -1.1007132703458495,
        "correct": 1
    },
    {
        "question": "How is function overloading different from template class?",
        "options": [
            "Overloading is multiple function doing same operation, Template is multiple function doing different operations",
            "Overloading is single function doing different operations, Template is multiple function doing different operations",
            "Overloading is multiple function doing similar operation, Template is multiple function doing identical operations",
            "Overloading is multiple function doing same operation, Template is same function doing different operations"
        ],
        "explanation": "Explanation: The function overloading is multiple functions with similar or different functionality but generic class functions perform the same task on given different types of data.",
        "index": 228,
        "difficulty": -1.0894626378228585,
        "correct": 3
    },
    {
        "question": "What if static members are declared inside template classes?",
        "options": [
            "All instances will share the static variable",
            "All instances will have their own static variable",
            "All the instances will ignore the static variable",
            "Program gives compile time error"
        ],
        "explanation": "Explanation: The generic class have a special case with static members. Each instance will have its own static member. The static members are not shared usually.",
        "index": 229,
        "difficulty": -1.079274487673417,
        "correct": 2
    },
    {
        "question": "Which is most appropriate definition of a base class?",
        "options": [
            "It is parent of any of its derived class",
            "It is child of one of the parent class",
            "It is most basic class of whole program",
            "It is class with maximum number of members"
        ],
        "explanation": "Explanation: A class which is parent of another class, or from which other classes can be derived, is known as a base class. It is mandatory that a class must have at least one derived class to be called as a base class.",
        "index": 230,
        "difficulty": -1.0746757793378723,
        "correct": 1
    },
    {
        "question": "A base class is also known as _____________ class.",
        "options": [
            "Basic",
            "Inherited",
            "Super",
            "Sub"
        ],
        "explanation": "Explanation: A class which is being derived by other classes, is called as super class. This concept is clearly used in java as we call the functions of a base class by using the keyword super as required.",
        "index": 231,
        "difficulty": -1.0657154401777202,
        "correct": 3
    },
    {
        "question": "An abstract class is always a __________ class.",
        "options": [
            "Base",
            "Derived",
            "Template",
            "Nested"
        ],
        "explanation": "Explanation: Every abstract class is a base class. It must be so, because the functions which are not defined inside the abstract class, must be defined in the derived classes. Hence it becomes a base class.",
        "index": 232,
        "difficulty": -1.060199479251291,
        "correct": 1
    },
    {
        "question": "How many base classes can a single class inherit in java?",
        "options": [
            "1",
            "2",
            "3",
            "As many as required"
        ],
        "explanation": "Explanation: In java, multiple inheritance is not supported, which leads to the fact that a class can have only 1 parent class if inheritance is used. Only if interfaces are used then the class can implement more than one base class.",
        "index": 233,
        "difficulty": -1.058978361678145,
        "correct": 1
    },
    {
        "question": "How to make a derived class a base class?",
        "options": [
            "Change name of the class",
            "Use keyword base",
            "Make a class derive from it",
            "Can\u2019t be done"
        ],
        "explanation": "Explanation: Making another class derive from it will make that class as base class. It is not necessary that we have to write different code for it. If at least one class derives that class, it becomes the base class for the new class.",
        "index": 234,
        "difficulty": -1.0547061018152009,
        "correct": 3
    },
    {
        "question": "If a base class is being derived by two other classes, which inheritance will that be called?",
        "options": [
            "Single",
            "Multiple",
            "Multi-level",
            "Hierarchical"
        ],
        "explanation": "Explanation: When more than one classes are being derived from a single parent class, the inheritance is known as hierarchical inheritance. This is usually useful when the base class is higher abstraction of its derived classes.",
        "index": 235,
        "difficulty": -1.0443484543475918,
        "correct": 4
    },
    {
        "question": "Which among the following must be in a base class?",
        "options": [
            "Data members",
            "Member functions",
            "Access specifiers",
            "Nothing"
        ],
        "explanation": "Explanation: Even a class that doesn\u2019t have any members can be a base class. It is not mandatory to have any member or attribute in base class.",
        "index": 236,
        "difficulty": -1.0421918400150174,
        "correct": 4
    },
    {
        "question": "Which type of members can\u2019t be accessed in derived classes of a base class?",
        "options": [
            "Protected",
            "Private",
            "Public",
            "All can be accessed"
        ],
        "explanation": "Explanation: The private members can be accessed only inside the base class. If the class is derived by other classes. Those members will not be accessible. This concept of OOP is made to make the members more secure.",
        "index": 237,
        "difficulty": -1.0386557217000343,
        "correct": 2
    },
    {
        "question": "If a class is enclosing more than one class, than it can be called as base class of those classes.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: When a class have more than one nested classes, it is known as enclosing class. It can\u2019t be called as parent or base class since there is no inheritance involved.",
        "index": 238,
        "difficulty": -1.0318388532466662,
        "correct": 2
    },
    {
        "question": "Base class have ________________ of abstraction.",
        "options": [
            "Higher degree",
            "Lower degree",
            "Intermediate",
            "Minimum degree"
        ],
        "explanation": "Explanation: A base class will have lesser information as compared to those of derived classes. Since derived classes inherit the base class properties and then add on their own features, they elaborate more hence have lower degree of abstraction.",
        "index": 239,
        "difficulty": -1.0183362609744435,
        "correct": 2
    },
    {
        "question": "Always the base class constructors are called ___________ constructor of derived class.",
        "options": [
            "Before",
            "After",
            "Along",
            "According to priority of"
        ],
        "explanation": "Explanation: When the base class object is created, its constructor will be called for sure. But if a derived class constructor is called, first base class constructor is called and then derived class constructor is taken into consideration.",
        "index": 240,
        "difficulty": -1.0127494948054365,
        "correct": 1
    },
    {
        "question": "Can we call methods of base class using the constructor of the derived class?",
        "options": [
            "Yes, always",
            "Yes, but not always",
            "No, never",
            "No, but we can call in some cases"
        ],
        "explanation": "Explanation: If the function is defined in the base class, it can always be called from the constructor of its derived class. Since the constructors are not private, they can be accessed in derived class even if those are protected.",
        "index": 241,
        "difficulty": -1.0115384953905677,
        "correct": 1
    },
    {
        "question": "If a base class is inherited from another class and then one class derives it, which inheritance is shown?",
        "options": [
            "Multiple",
            "Single",
            "Hierarchical",
            "Multi-level"
        ],
        "explanation": "Explanation: If a base class is inherited from another class, single inheritance is shown. But when one more class inherits the derived class, this becomes a multi-level inheritance.",
        "index": 242,
        "difficulty": -1.0044400581712534,
        "correct": 4
    },
    {
        "question": "How many base classes can a single derived class have in C++?",
        "options": [
            "1",
            "2",
            "3",
            "As many as required"
        ],
        "explanation": "Explanation: This is because C++ allows multiple inheritance. A derived class can have more than one base class and hence can derive all of their features.",
        "index": 243,
        "difficulty": -0.9748363768965493,
        "correct": 4
    },
    {
        "question": "If a base class is added with a few new members, its subclass must also be modified.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The base class can be added with new members without affecting the subclasses. This is because the subclasses may get some more features inherited but it won\u2019t use them. But the base class will be able to use the new members as would be required.",
        "index": 244,
        "difficulty": -0.9716779321404729,
        "correct": 2
    },
    {
        "question": "Which among the following is best definition of a derived class?",
        "options": [
            "A child class",
            "A class which inherits one or more classes",
            "A class with keyword derived",
            "A class with more than one constructor"
        ],
        "explanation": "Explanation: Any class which inherits one or more classes is a derived class. The only condition is it must inherit at least one class in order to be called as a derived class.",
        "index": 245,
        "difficulty": -0.9558410783708449,
        "correct": 2
    },
    {
        "question": "Which among the following is inherited by a derived class from base class?",
        "options": [
            "Data members only",
            "Member functions only",
            "All the members except private members",
            "All the members of base class"
        ],
        "explanation": "Explanation: The class inheriting another class, inherits all the data members and member functions that are not private. This is done to ensure the security features with maximum flexibility.",
        "index": 246,
        "difficulty": -0.9459782079738872,
        "correct": 3
    },
    {
        "question": "If there is a derived class in a program, how many classes must be in that program?",
        "options": [
            "1",
            "2",
            "3",
            "4"
        ],
        "explanation": "Explanation: If there is a derived class in a program, there must be at least 2 classes in that program. One is a base class and another derived class. Hence at least 2 classes must be there.",
        "index": 247,
        "difficulty": -0.9412341837951574,
        "correct": 2
    },
    {
        "question": "Which members can never be accessed in derived class from the base class?",
        "options": [
            "Private",
            "Protected",
            "Public",
            "All except private"
        ],
        "explanation": "Explanation: There is no restriction for a derived class to access the members of the base class until and unless the members are private. Private member are declared so that those members are not accessible outside the class.",
        "index": 248,
        "difficulty": -0.9398082461779804,
        "correct": 4
    },
    {
        "question": "How many types of inheritance are supported in C++ for deriving a class?",
        "options": [
            "1",
            "2",
            "3",
            "4"
        ],
        "explanation": "Explanation: There are three types of inheritance possible. Private inheritance, protected inheritance, and public inheritance. The inheritance defines the access specifier to be used with the inherited members in the derived class.",
        "index": 249,
        "difficulty": -0.9354886225180956,
        "correct": 3
    },
    {
        "question": "How many derived class can a single base class have?",
        "options": [
            "1",
            "2",
            "3",
            "As many are required"
        ],
        "explanation": "Explanation: There is no restriction on how many classes can inherit a single base class. Hence there can be as many derived classes as required in a program from a single base class.",
        "index": 250,
        "difficulty": -0.9320703351305051,
        "correct": 4
    },
    {
        "question": "Which among the following is correct?",
        "options": [
            "Friend function of derived class can access non-private members of base class",
            "Friend function of base class can access derived class members",
            "Friend function of derived class can access members of only derived class",
            "Friend function can access private members of base class of a derived class"
        ],
        "explanation": "Explanation: The friend function of a class can access the non-private members of base class. The reason behind is that the members of base class gets derived into the derived class and hence become members of derived class too. Hence a friend function can access all of those.",
        "index": 251,
        "difficulty": -0.9313976888587581,
        "correct": 1
    },
    {
        "question": "If a class is being derived using more than two base classes, which inheritance will be used?",
        "options": [
            "Single",
            "Multi-level",
            "Hierarchical",
            "Multiple"
        ],
        "explanation": "Explanation: The statement given is the definition of multiple inheritance with respect to the derived class. The concept can be illustrated with many other samples but the main aspects are base class and derived class only.",
        "index": 252,
        "difficulty": -0.9297070787197388,
        "correct": 4
    },
    {
        "question": "Derived class is also known as ______________ class.",
        "options": [
            "Subclass",
            "Small class",
            "Big class",
            "Noticeable class"
        ],
        "explanation": "Explanation: It is just another name given to the derived classes. This is used while denoting all the derived classes subsequent to a superclass.",
        "index": 253,
        "difficulty": -0.9281098150634017,
        "correct": 1
    },
    {
        "question": "If class A is derived from another derived class B which is derived from class C, which class will have maximum level of abstraction?",
        "options": [
            "Class A",
            "Class B",
            "Class C",
            "All have the same level of abstraction"
        ],
        "explanation": "Explanation: The abstraction level of class C will be maximum. This is because the parent class have higher level of abstraction. Hence the parent of all other class will have maximum level of abstraction.",
        "index": 254,
        "difficulty": -0.9240528646944872,
        "correct": 3
    },
    {
        "question": "If base class is an abstract class then derived class ______________ the undefined functions.",
        "options": [
            "Must define",
            "Must become another abstract class or define",
            "Must become parent class for",
            "Must implement 2 definitions of"
        ],
        "explanation": "Explanation: The function must be defined in the program which are not defined in the base class. Hence the class must be defined as abstract of implement the function definition in it.",
        "index": 255,
        "difficulty": -0.9234396210783906,
        "correct": 2
    },
    {
        "question": "How many classes can be derived from a derived class?",
        "options": [
            "Only 1",
            "At most 1",
            "At least 1",
            "As many as required"
        ],
        "explanation": "Explanation: When a class is to be derived from another derived class, the derived class behaves as a normal base class hence there are no restriction on how many class can be derived from a derived class. The derived class again behaves as a normal superclass.",
        "index": 256,
        "difficulty": -0.8702883622197408,
        "correct": 4
    },
    {
        "question": "The members of a derived class can never be derived.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: This is not true that the members of a derived class can\u2019t be derived. All the classes are considered to be a normal class when used for derivation. The members can be derived with respect to their access specifiers.",
        "index": 257,
        "difficulty": -0.8604616034597852,
        "correct": 2
    },
    {
        "question": "Which feature is not related to the derived classes among the following?",
        "options": [
            "Inheritance",
            "Encapsulation",
            "Run time memory management",
            "Compile time function references"
        ],
        "explanation": "Explanation: The memory management is the feature that is not necessary for derived classes that will be a part of whole program. The functions references must be resolved for their proper use if inheritance is used.",
        "index": 258,
        "difficulty": -0.8599758449417951,
        "correct": 3
    },
    {
        "question": "Deriving a class in such a way that that the base class members are not available for further inheritance is known as ___________________",
        "options": [
            "Public inheritance",
            "Protected inheritance",
            "Protected or private inheritance",
            "Private inheritance"
        ],
        "explanation": "Explanation: The private members of a class can never be derived to another class. When a class derives another class using private inheritance, all the members become private members of the derived class. Hence these member won\u2019t be available for further inheritance.",
        "index": 259,
        "difficulty": -0.8458717487251368,
        "correct": 4
    },
    {
        "question": "Which among the following is the main characteristic of class?",
        "options": [
            "Inheritance",
            "Encapsulation",
            "Polymorphism",
            "Object creation"
        ],
        "explanation": "Explanation: The classes are made to encapsulate the data and properties that are most similar and can be grouped together inside a single class. This single class can represent all of those features by creating its instances.",
        "index": 260,
        "difficulty": -0.8415208664552285,
        "correct": 2
    },
    {
        "question": "To group all the brands of cars, what should be used?",
        "options": [
            "Class",
            "Structure",
            "Function",
            "Object"
        ],
        "explanation": "Explanation: A class can be used to group all the brands of cars. The Different brands may have different properties but all will have some common properties like number of wheels and doors, accessories etc. All of those properties can be grouped into a single class representing all the cars.",
        "index": 261,
        "difficulty": -0.8375169003040144,
        "correct": 1
    },
    {
        "question": "If a class have two data members and two functions to add those two numbers and to subtract them, which among the following is most efficient if the programmer wants to implement multiplication too?",
        "options": [
            "Define a public function which multiplies two numbers",
            "Define a public function that returns values of two data members",
            "Define a private function which multiplies two numbers",
            "Define a private function that returns values of two data members"
        ],
        "explanation": "Explanation: The best choice would be to define a public member function that returns the values of two data members of the class. This way we can implement any operation on those data members. Also there won\u2019t be any need to modify the program and to add new functions for each new operation.",
        "index": 262,
        "difficulty": -0.8197196397324933,
        "correct": 2
    },
    {
        "question": "If a database have to be maintained using OOP, to store the details of each employee in a company, which would be the best choice among the following?",
        "options": [
            "Define a class to store details of each employee",
            "Define a structure to store details of each employee",
            "Define separate variable for each detail",
            "Define a generic type to store string and number details"
        ],
        "explanation": "Explanation: A single class can be defined that represents a single employee of a company. The specific type of functions that can be applied to specific employees can be put into another class that is derived from the existing class.",
        "index": 263,
        "difficulty": -0.8162479964820548,
        "correct": 1
    },
    {
        "question": "Which class represents the most abstracted information?",
        "options": [
            "Nested",
            "Derived",
            "Enclosed",
            "Base"
        ],
        "explanation": "Explanation: The base classes are the most abstracted part of information. A base class having many other derived classes would have a bigger overview of all the other derived classes. Hence the base classes have the most abstract information.",
        "index": 264,
        "difficulty": -0.7997136470436281,
        "correct": 4
    },
    {
        "question": "Which among the following is an advantage of using classes over structures of C?",
        "options": [
            "Functions are restricted",
            "Functions can\u2019t be defined",
            "Functions can also be encapsulated",
            "Functions can have more security"
        ],
        "explanation": "Explanation: The functions are also made easy to be encapsulated inside a class. In structures, only the data members were allowed to be encapsulated. Hence classes can represent an entity in a better way.",
        "index": 265,
        "difficulty": -0.7978115180580829,
        "correct": 3
    },
    {
        "question": "Which among the following is a feature of class?",
        "options": [
            "Object orientation",
            "Procedure orientation",
            "Both object and procedure orientation",
            "Neither object nor procedure orientation"
        ],
        "explanation": "Explanation: Thee use of classes feature the object oriented programming. The OOP concept can be implemented by using class and their objects. Procedures orientation is not a feature of OOP.",
        "index": 266,
        "difficulty": -0.7965089173494664,
        "correct": 1
    },
    {
        "question": "Class is _____________ of an object.",
        "options": [
            "Basic function definition",
            "Detailed description with values",
            "Blueprint",
            "Set of constant values"
        ],
        "explanation": "Explanation: The class is an overview for an object. It contains the basic details map of data that an object will contain. An object is independent representation of class.",
        "index": 267,
        "difficulty": -0.7881248508423391,
        "correct": 3
    },
    {
        "question": "In which case the classes can be used to make the more efficient program?",
        "options": [
            "To define a function that is called frequently in a program",
            "To structure data that is most similar",
            "To group the most similar data and operations",
            "To define a blueprint that shows memory location of data"
        ],
        "explanation": "Explanation: The classes would be more suitable to use in case where we need to group the most similar data and operations. The data can be represented as data members of class and operations as member functions of class. This is indirectly encapsulation feature.",
        "index": 268,
        "difficulty": -0.7633873131393458,
        "correct": 3
    },
    {
        "question": "What is the use of inbuilt classes?",
        "options": [
            "Provide predefined data",
            "Provide predefined functions",
            "Provide predefined data and functions",
            "Provide predeclared data to be overridden"
        ],
        "explanation": "Explanation: The data that is constant or is always the same initially for use can be provided by some inbuilt classes. The functions that are mostly used are also provided by the inbuilt classes. The data and functions can be used by including the corresponding header file or library.",
        "index": 269,
        "difficulty": -0.7618951523778099,
        "correct": 3
    },
    {
        "question": "Which feature is exhibited by the inbuilt classes?",
        "options": [
            "Code reusability",
            "Code efficiency",
            "Code readability",
            "Code reusability, efficiency and readability"
        ],
        "explanation": "Explanation: The code is reusable as the functions which are already written, can be used anytime required. The code becomes easier to read. Also, the code is efficient as there is no need to assign any external code.",
        "index": 270,
        "difficulty": -0.7523089204745812,
        "correct": 4
    },
    {
        "question": "Why do we use user defined classes?",
        "options": [
            "To design a user intended code",
            "To model real world objects",
            "To design the interfaces",
            "To model the functions"
        ],
        "explanation": "Explanation: The primitive classes are not sufficient for the programming complex algorithms. Some user defined classes are required to represent a real world object and to define a blueprint of what the class should actually contain. The user defined classes are as per the requirements and need of user.",
        "index": 271,
        "difficulty": -0.7482858091954325,
        "correct": 2
    },
    {
        "question": "Why do classes use accessor methods?",
        "options": [
            "To make public data accessible to client",
            "To make public data private to client",
            "To make private data public for whole program",
            "To make private data accessible to the client"
        ],
        "explanation": "Explanation: The private data of a class is usually not accessible. But the data can be accessed by the user using accessor functions. These functions allows the user to get the data stored as private in a class.",
        "index": 272,
        "difficulty": -0.7360435916687122,
        "correct": 4
    },
    {
        "question": "Why do classes use mutator methods?",
        "options": [
            "Allows client to modify the program",
            "Allows client to modify/write the private members",
            "Allows servers to access all the private data",
            "Allows servers to access only protected members"
        ],
        "explanation": "Explanation: The client can have rights to access a file and write something to it. This is mandatory to keep the private data updated. Also it is an advantage over the use of hidden class members.",
        "index": 273,
        "difficulty": -0.7356878409844487,
        "correct": 2
    },
    {
        "question": "Which among the following is the most abstract form of class?",
        "options": [
            "Cars",
            "BMW cars",
            "Big cars",
            "Small cars"
        ],
        "explanation": "Explanation: The most abstract class is class Cars. The class Cars is the most general form of all other cars. If it is a brand of car, it comes under car. If it is the type of car then also it comes under Cars.",
        "index": 274,
        "difficulty": -0.7279012913877119,
        "correct": 1
    },
    {
        "question": "Which among the following best describes the Inheritance?",
        "options": [
            "Copying the code already written",
            "Using the code already written once",
            "Using already defined functions in programming language",
            "Using the data and functions into derived segment"
        ],
        "explanation": "Explanation: It can only be indicated by using the data and functions that we use in derived class, being provided by parent class. Copying code is nowhere similar to this concept, also using the code already written is same as copying. Using already defined functions is not inheritance as we are not adding any of our own features.",
        "index": 275,
        "difficulty": -0.7172446701645669,
        "correct": 4
    },
    {
        "question": "How many basic types of inheritance are provided as OOP feature?",
        "options": [
            "4",
            "3",
            "2",
            "1"
        ],
        "explanation": "Explanation: There are basically 4 types of inheritance provided in OOP, namely, single level, multilevel, multiple and hierarchical inheritance. We can add one more type as Hybrid inheritance but that is actually the combination any types of inheritance from the 4 basic ones.",
        "index": 276,
        "difficulty": -0.7089139226232168,
        "correct": 1
    },
    {
        "question": "Which among the following best defines single level inheritance?",
        "options": [
            "A class inheriting a derived class",
            "A class inheriting a base class",
            "A class inheriting a nested class",
            "A class which gets inherited by 2 classes"
        ],
        "explanation": "Explanation: A class inheriting a base class defines single level inheritance. Inheriting an already derived class makes it multilevel inheritance. And if base class is inherited by 2 other classes, it is multiple inheritance.",
        "index": 277,
        "difficulty": -0.6977561195104309,
        "correct": 2
    },
    {
        "question": "Which among the following is correct for multiple inheritance?",
        "options": [
            "class student{public:  int marks;}s;  class stream{int total;}; class topper:public student, public stream{  };",
            "class student{int marks;}; class stream{ }; class topper: public student{ };",
            "class student{int marks;}; class stream:public student{ };",
            "class student{ }; class stream{ }; class topper{ };"
        ],
        "explanation": "Explanation: Class topper is getting derived from 2 other classes and hence it is multiple inheritance. Topper inherits class stream and class student publicly and hence can use its features. If only few classes are defined, there we are not even using inheritance (as in option class student{ }; class stream{ }; class topper{ };).",
        "index": 278,
        "difficulty": -0.6929192190010518,
        "correct": 1
    },
    {
        "question": "Which programming language doesn\u2019t support multiple inheritance?",
        "options": [
            "C++ and Java",
            "C and C++",
            "Java and SmallTalk",
            "Java"
        ],
        "explanation": "Explanation: Java doesn\u2019t support multiple inheritance. But that feature can be implemented by using the interfaces concept. Multiple inheritance is not supported because of diamond problem and similar issues.",
        "index": 279,
        "difficulty": -0.6891934122577146,
        "correct": 4
    },
    {
        "question": "Which among the following is correct for a hierarchical inheritance?",
        "options": [
            "Two base classes can be used to be derived into one single class",
            "Two or more classes can be derived into one class",
            "One base class can be derived into other two derived classes or more",
            "One base class can be derived into only 2 classes"
        ],
        "explanation": "Explanation: One base class can be derived into the other two derived classes or more. If only one class gets derived by only 2 other classes, it is also hierarchical inheritance, but it is not a mandatory condition, because any number of derived classes can be there.",
        "index": 280,
        "difficulty": -0.6828022958186084,
        "correct": 3
    },
    {
        "question": "Which is the correct syntax of inheritance?",
        "options": [
            "class derived_classname : base_classname{ /*define class body*/ };",
            "class base_classname : derived_classname{ /*define class body*/ };",
            "class derived_classname : access base_classname{ /*define class body*/ };",
            "class base_classname :access derived_classname{ /*define class body*/ };"
        ],
        "explanation": "Explanation: Firstly, keyword class should come, followed by the derived class name. Colon is must followed by access in which base class has to be derived, followed by the base class name. And finally the body of class. Semicolon after the body is also must.",
        "index": 281,
        "difficulty": -0.6656274736451486,
        "correct": 3
    },
    {
        "question": "Which type of inheritance leads to diamond problem?",
        "options": [
            "Single level",
            "Multi-level",
            "Multiple",
            "Hierarchical"
        ],
        "explanation": "Explanation: When 2 or more classes inherit the same class using multiple inheritance and then one more class inherits those two base classes, we get a diamond like structure. Here, ambiguity arises when same function gets derived into 2 base classes and finally to 3rd level class because same name functions are being inherited.",
        "index": 282,
        "difficulty": -0.6592678849067113,
        "correct": 3
    },
    {
        "question": "Which access type data gets derived as private member in derived class?",
        "options": [
            "Private",
            "Public",
            "Protected",
            "Protected and Private"
        ],
        "explanation": "Explanation: It is a rule, that when a derived class inherits the base class in private access mode, all the members of base class gets derived as private members of the derived class.",
        "index": 283,
        "difficulty": -0.638309349600299,
        "correct": 1
    },
    {
        "question": "If a base class is inherited in protected access mode then which among the following is true?",
        "options": [
            "Public and Protected members of base class becomes protected members of derived class",
            "Only protected members become protected members of derived class",
            "Private, Protected and Public all members of base, become private of derived class",
            "Only private members of base, become private of derived class"
        ],
        "explanation": "Explanation: As the programming language rules apply, all the public and protected members of base class becomes protected members of derived class in protected access mode. It can\u2019t be changed because it would hinder the security of data and may add vulnerability in the program.",
        "index": 284,
        "difficulty": -0.6369605230133137,
        "correct": 1
    },
    {
        "question": "Members which are not intended to be inherited are declared as ________________",
        "options": [
            "Public members",
            "Protected members",
            "Private members",
            "Private or Protected members"
        ],
        "explanation": "Explanation: Private access specifier is the most secure access mode. It doesn\u2019t allow members to be inherited. Even Private inheritance can only inherit protected and public members.",
        "index": 285,
        "difficulty": -0.6243772552533651,
        "correct": 3
    },
    {
        "question": "While inheriting a class, if no access mode is specified, then which among the following is true? (in C++)",
        "options": [
            "It gets inherited publicly by default",
            "It gets inherited protected by default",
            "It gets inherited privately by default",
            "It is not possible"
        ],
        "explanation": "Explanation: If the access mode is not specified during inheritance, the class is inherited privately by default. This is to ensure the security of data and to maintain OOP features. Hence it is not mandatory to specify the access mode if we want the class to be inherited privately.",
        "index": 286,
        "difficulty": -0.6175265092665789,
        "correct": 3
    },
    {
        "question": "If a derived class object is created, which constructor is called first?",
        "options": [
            "Base class constructor",
            "Derived class constructor",
            "Depends on how we call the object",
            "Not possible"
        ],
        "explanation": "Explanation: First the base class constructor is invoked. When we create a derived class object, the system tries to invoke its constructor but the class is derived so first the base class must be initialized, hence in turn the base class constructor is invoked before the derived class constructor.",
        "index": 287,
        "difficulty": -0.611417921591149,
        "correct": 1
    },
    {
        "question": "The private members of the base class are visible in derived class but are not accessible directly.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: Consider that a variable is private in base class and the derived class uses public inheritance to inherit that class. Now if we also have a global variable of same name as that of base class private variable, neither the global variable nor the base class private variable will be accessible from derived class. This is because we can\u2019t have 2 variables with same name in same local scope. Hence the private members are accessible but not directly.",
        "index": 288,
        "difficulty": -0.6096433991488595,
        "correct": 1
    },
    {
        "question": "How can you make the private members inheritable?",
        "options": [
            "By making their visibility mode as public only",
            "By making their visibility mode as protected only",
            "By making their visibility mode as private in derived class",
            "It can be done both by making the visibility mode public or protected"
        ],
        "explanation": "Explanation: It is not mandatory that you have to make the visibility mode either public or protected. You can do either of those. That will give you permission to inherit the private members of base class.",
        "index": 289,
        "difficulty": -0.5928529733672017,
        "correct": 4
    },
    {
        "question": "How many types of inheritance are possible in C++?",
        "options": [
            "2",
            "3",
            "4",
            "5"
        ],
        "explanation": "Explanation: There are five types of inheritance that are possible in C++. Single level, Multilevel, multiple, hierarchical and hybrid. Here we count hybrid also because it sometimes can bring up a new form of inheritance, Like inheritance using multiple and hierarchical, which sometimes results in diamond problem.",
        "index": 290,
        "difficulty": -0.589496144451723,
        "correct": 4
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "Java supports all types of inheritance",
            "Java supports multiple inheritance",
            "Java doesn\u2019t support multiple inheritance",
            "Java doesn\u2019t support inheritance"
        ],
        "explanation": "Explanation: Java doesn\u2019t support multiple inheritance. This is done to avoid the diamond problem that sometimes arises with inherited functions. Though, multiple inheritance can be implemented in java using interfaces.",
        "index": 291,
        "difficulty": -0.5865193531805026,
        "correct": 3
    },
    {
        "question": "Which among the following defines single level inheritance?",
        "options": [
            "One base class derives another class",
            "One derived class inherits from one base class",
            "One base class inherits from one derived class",
            "One derived class derives from another derived class"
        ],
        "explanation": "Explanation: If only one base class is used to derive only one subclass, it is known as single level inheritance. The reason of this name is that we inherit the base class to one more level and stop the inheritance any further.",
        "index": 292,
        "difficulty": -0.5695766936460789,
        "correct": 2
    },
    {
        "question": "If class A and class B are derived from class C and class D, then ________________",
        "options": [
            "Those are 2 pairs of single inheritance",
            "That is multilevel inheritance",
            "Those is enclosing class",
            "Those are all independent classes"
        ],
        "explanation": "Explanation: Since class A is derived from class C and then class B is derived from class D, there are two pairs of classes which shows single inheritance. Those two pairs are independent of each other though.",
        "index": 293,
        "difficulty": -0.5659166674618716,
        "correct": 1
    },
    {
        "question": "If single inheritance is used, program will contain ________________",
        "options": [
            "At least 2 classes",
            "At most 2 classes",
            "Exactly 2 classes",
            "At most 4 classes"
        ],
        "explanation": "Explanation: The program will contain at least 2 classes in the sense of base and derived classes. At least one base class and one derived class must be there. Types of inheritance remains the same though.",
        "index": 294,
        "difficulty": -0.5648508199169244,
        "correct": 1
    },
    {
        "question": "Single level inheritance supports _____________ inheritance.",
        "options": [
            "Runtime",
            "Compile time",
            "Multiple inheritance",
            "Language independency"
        ],
        "explanation": "Explanation: The runtime inheritance is done when object of a class is created to call a method. At runtime the function is searched if it is in class of object. If not, it will search in its parent classes and hierarchy for that method.",
        "index": 295,
        "difficulty": -0.5632810600865743,
        "correct": 1
    },
    {
        "question": "Which among the following best defines multilevel inheritance?",
        "options": [
            "A class derived from another derived class",
            "Classes being derived from other derived classes",
            "Continuing single level inheritance",
            "Class which have more than one parent"
        ],
        "explanation": "Explanation: Only if the class is being derived from other derived class, it can be called as multilevel inheritance. If a class is derived from another class, it is single level inheritance. There must be more than one level of inheritance.",
        "index": 296,
        "difficulty": -0.5626116187361752,
        "correct": 2
    },
    {
        "question": "If there are 5 classes, E is derived from D, D from C, C from B and B from A. Which class constructor will be called first if the object of E or D is created?",
        "options": [
            "A",
            "B",
            "C",
            "A and B"
        ],
        "explanation": "Explanation: A is parent of all other classes indirectly. Since A is parent of B and B is parent of C and so on till E. Class A constructor will be called first always.",
        "index": 297,
        "difficulty": -0.5563624335344688,
        "correct": 1
    },
    {
        "question": "If there are 3 classes. Class C is derived from class B and B is derived from A, Which class destructor will be called at last if object of C is destroyed.",
        "options": [
            "A",
            "B",
            "C",
            "All together"
        ],
        "explanation": "Explanation: The destructors are called in the reverse order of the constructors being called. Hence in multilevel inheritance, the constructors are created from parent to child, which leads to destruction from child to parent. Hence class A destructor will be called at last.",
        "index": 298,
        "difficulty": -0.5550200382312531,
        "correct": 1
    },
    {
        "question": "Which Class is having highest degree of abstraction in multilevel inheritance of 5 levels?",
        "options": [
            "Class at 1st level",
            "Class 2nd last level",
            "Class at 5th level",
            "All with same abstraction"
        ],
        "explanation": "Explanation: The class with highest degree of abstraction will be the class at the 1st level. You can look at a simple example like, a CAR is more abstract than SPORTS CAR class. The level of abstraction decrease with each level as more details comes out.",
        "index": 299,
        "difficulty": -0.5480732901041119,
        "correct": 1
    },
    {
        "question": "If all the classes use private inheritance in multilevel inheritance then ______________",
        "options": [
            "It will not be called multilevel inheritance",
            "Each class can access only non-private members of its parent",
            "Each subsequent class can access all members of previous level parent classes",
            "None of the members will be available to any other class"
        ],
        "explanation": "Explanation: The classes will be able to access only the non-private members of its parent class. The classes are using private inheritance, hence all the members of the parent class become private in the derived class. In turn those won\u2019t be allowed for further inheritance or direct access outside the class.",
        "index": 300,
        "difficulty": -0.5395214868660068,
        "correct": 2
    },
    {
        "question": "Multilevel inheritance allows _________________ in the program.",
        "options": [
            "Only 7 levels of inheritance",
            "At least 7 levels of inheritance",
            "At most 16 levels of inheritance",
            "As many levels of inheritance as required"
        ],
        "explanation": "Explanation: The multilevel inheritance allows any number of levels of inheritance. This is the maximum flexibility feature to make the members available to all the new classes and to add their own functionalities. The code reusability is used too.",
        "index": 301,
        "difficulty": -0.5307635178197438,
        "correct": 4
    },
    {
        "question": "What is the minimum number of levels for a implementing multilevel inheritance?",
        "options": [
            "1",
            "2",
            "3",
            "4"
        ],
        "explanation": "Explanation: There must be at least 3 levels of inheritance. Otherwise if less, it will be single level inheritance or would have got no inheritance implemented. There must be a derived class from which another class is derived.",
        "index": 302,
        "difficulty": -0.5244374472515849,
        "correct": 3
    },
    {
        "question": "In multilevel inheritance one class inherits _______________",
        "options": [
            "Only one class",
            "More than one class",
            "At least one class",
            "As many classes as required"
        ],
        "explanation": "Explanation: The classes inherit only from one class. This continues as each class inherits only one class. There should not be any class that inherits from two or more classes or which have more than one subclass.",
        "index": 303,
        "difficulty": -0.5184717437419155,
        "correct": 1
    },
    {
        "question": "All the classes must have all the members declared private to implement multilevel inheritance.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: There is no mandatory rule to make the members private for multilevel inheritance. Moreover, if all the classes have only the private members then there won\u2019t be any member to get inherited. Hence the working will be of no use.",
        "index": 304,
        "difficulty": -0.5141316448118003,
        "correct": 2
    },
    {
        "question": "Can abstract classes be used in multilevel inheritance?",
        "options": [
            "Yes, always",
            "Yes, only one abstract class",
            "No, abstract class doesn\u2019t have constructors",
            "No, never"
        ],
        "explanation": "Explanation: The abstract classes can always be used in multilevel inheritance. The only condition that may arise is that all the undefined functions must be defined in subclasses. There must not be any undefined function.",
        "index": 305,
        "difficulty": -0.5052697759279599,
        "correct": 1
    },
    {
        "question": "How many abstract classes can be used in multilevel inheritance?",
        "options": [
            "Only 1",
            "Only 2",
            "At least one less than number of levels",
            "Can\u2019t be used"
        ],
        "explanation": "Explanation: At least one class must implement all the undefined functions. Hence there must be at least one class which is not abstract. That is at least one less than number of levels.",
        "index": 306,
        "difficulty": -0.4962319992396864,
        "correct": 3
    },
    {
        "question": "If all the classes used parameterized constructors and no default constructor then ___________",
        "options": [
            "The object of lower level classes can\u2019t be created",
            "Object of lower level classes must call parent class constructors explicitly",
            "Object of lower level classes must define all the default constructors",
            "Only object of first class can be created, which is first parent"
        ],
        "explanation": "Explanation: Each class constructor must be called before creating the object of any subclass. Hence it will be mandatory to call the constructors of parent classes explicitly with parameters. This will make all the previous class member be initialized and then the class in use will be able to create the object.",
        "index": 307,
        "difficulty": -0.46190013320428935,
        "correct": 2
    },
    {
        "question": "In multilevel inheritance, which is the most significant feature of OOP used?",
        "options": [
            "Code readability",
            "Flexibility",
            "Code reusability",
            "Code efficiency"
        ],
        "explanation": "Explanation: The classes using multilevel inheritance will use the code in all the subsequent subclasses if available. Hence the most significant feature among the options given is code reusability. This feature is generally intended to use the data values and reuse the redundant functions.",
        "index": 308,
        "difficulty": -0.4552040817827776,
        "correct": 3
    },
    {
        "question": "Multiple inheritance is ____________________",
        "options": [
            "When a class is derived from another class",
            "When a class is derived from two or more classes",
            "When a class is derived from other two derived classes",
            "When a class is derived from exactly one class"
        ],
        "explanation": "Explanation: The multiple inheritance is used when a class is being derived using two base classes or more. This way a single class can have features of more than one classes inherited into a single unit. This lets us combine two class members into a single class.",
        "index": 309,
        "difficulty": -0.45195174386615644,
        "correct": 2
    },
    {
        "question": "Which problem arises due to multiple inheritance, if hierarchical inheritance is used previously for its base classes?",
        "options": [
            "Diamond",
            "Circle",
            "Triangle",
            "Loop"
        ],
        "explanation": "Explanation: The diamond problem arises when multiple inheritance is used. This problem arises because the same name member functions get derived into a single class. Which in turn creates ambiguity in calling those methods.",
        "index": 310,
        "difficulty": -0.4443763450232776,
        "correct": 1
    },
    {
        "question": "How many classes should a program contain to implement the multiple inheritance?",
        "options": [
            "Only 1",
            "At least 1",
            "At least 3",
            "Exactly 3"
        ],
        "explanation": "Explanation: For the implementation of multiple inheritance, there must be at least 3 classes in a program. At least 2 base classes and one class to inherit those two classes. If lesser, it becomes single level inheritance.",
        "index": 311,
        "difficulty": -0.4427402369688793,
        "correct": 3
    },
    {
        "question": "Which programming language restricts the use of multiple inheritance?",
        "options": [
            "C++",
            "PHP",
            "SmallTalk",
            "Java"
        ],
        "explanation": "Explanation: Java doesn\u2019t allow use of multiple inheritance with classes. But this can be done by using the interfaces. This is more secure and unambiguous way to implement multiple inheritance.",
        "index": 312,
        "difficulty": -0.4360163312429539,
        "correct": 4
    },
    {
        "question": "Is it possible to have all the abstract classes as base classes of a derived class from those?",
        "options": [
            "Yes, always",
            "Yes, only if derived class implements all the methods",
            "No, because abstract classes doesn\u2019t have constructors",
            "No, never"
        ],
        "explanation": "Explanation: The condition for abstract class applies same here too. All the undefined functions must be defined. Hence all the base classes can be abstract but derived class must implement all those undefined functions.",
        "index": 313,
        "difficulty": -0.4190805623250209,
        "correct": 2
    },
    {
        "question": "If class A inherits class B and class C as \u201cclass A: public class B, public class C {// class body ;}; \u201d, which class constructor will be called first?",
        "options": [
            "Class A",
            "Class B",
            "Class C",
            "All together"
        ],
        "explanation": "Explanation: The constructors of parent class will be called first. In that, the constructor of the classes will be called in the same sequence as that mentioned in class definition inheritance. Since class B is mentioned first for inheritance, its constructor will be called first.",
        "index": 314,
        "difficulty": -0.40619154486042497,
        "correct": 2
    },
    {
        "question": "Why does diamond problem arise due to multiple inheritance?",
        "options": [
            "Methods with same name creates ambiguity and conflict",
            "Methods inherited from the superclass may conflict",
            "Derived class gets overloaded with more than two class methods",
            "Derived class can\u2019t distinguish the owner class of any derived method"
        ],
        "explanation": "Explanation: All the derived classes can distinguish the base class members, but if a method is being inherited to the base classes from another class which again gets inherited into same class (diamond shape), that may create conflict in using the function from two available.",
        "index": 315,
        "difficulty": -0.38713525408333327,
        "correct": 1
    },
    {
        "question": "How many base classes can a derived class have which is implementing multiple inheritance?",
        "options": [
            "Only 2",
            "At least 2",
            "At most 2",
            "As many as required"
        ],
        "explanation": "Explanation: The classes can derive from as many classes as required since the multiple inheritance feature is made to combine or group together the functions that are from different classes. This make the derived class stronger in terms of its flexibility.",
        "index": 316,
        "difficulty": -0.36179668346938154,
        "correct": 4
    },
    {
        "question": "How to overcome diamond problem?",
        "options": [
            "Using alias name",
            "Using seperate derived class",
            "Using virtual keyword with same name function",
            "Can\u2019t be done"
        ],
        "explanation": "Explanation: To overcome the ambiguity and conflict we can use keyword virtual. This will help us to differentiate the functions with same name that came to last derived class in diamond problem.",
        "index": 317,
        "difficulty": -0.35299355118615017,
        "correct": 3
    },
    {
        "question": "When multiple inheritance is used, which class object should be used in order to access all the available members of parent and derived class?",
        "options": [
            "Derived class object",
            "Parent class objects",
            "Use Abstract derived class",
            "Derive a class from derived class"
        ],
        "explanation": "Explanation: The derived class object can access all of its own members. It can also access the available members of the parent classes, because the members are derived into the derived class.",
        "index": 318,
        "difficulty": -0.34964267753466416,
        "correct": 1
    },
    {
        "question": "If all the members of all the base classes are private then _____________",
        "options": [
            "There won\u2019t be any use of multiple inheritance",
            "It will make those members public",
            "Derived class can still access them in multiple inheritance",
            "Compile time error"
        ],
        "explanation": "Explanation: The derived class will not be able to access any members of the base classes. Since private member\u2019s are not inheritable. It leads to no use of multiple inheritance.",
        "index": 319,
        "difficulty": -0.32903509002258335,
        "correct": 1
    },
    {
        "question": "Is it compulsory to have constructor for all the classes involved in multiple inheritance?",
        "options": [
            "Yes, always",
            "Yes, only if no abstract class is involved",
            "No, only classes being used should have a constructor",
            "No, they must not contain constructors"
        ],
        "explanation": "Explanation: The constructors must be defined in every class. If class is abstract, it won\u2019t have any constructor but other classes must have constructor. Either implicit or explicit.",
        "index": 320,
        "difficulty": -0.31973166995383373,
        "correct": 2
    },
    {
        "question": "If a class contains 2 nested class and is being inherited by another class, will there be any multiple inheritance?",
        "options": [
            "No, only single level inheritance is used",
            "No, only multilevel inheritance is used",
            "Yes, because 3 classes are involved",
            "Yes, because more than 1 classes are being derived"
        ],
        "explanation": "Explanation: When a class having nested classes is being derived into another class. It indirectly means a simple class is being inherited to another class. This is single level inheritance.",
        "index": 321,
        "difficulty": -0.3183646876783932,
        "correct": 1
    },
    {
        "question": "Which members can\u2019t be accessed in derived class in multiple inheritance?",
        "options": [
            "Private members of base",
            "Public members of base",
            "Protected members of base",
            "All the members of base"
        ],
        "explanation": "Explanation: The private member\u2019s are available for only the class containing those members. Derived classes will have access to protected and public members only.",
        "index": 322,
        "difficulty": -0.3086861722031897,
        "correct": 1
    },
    {
        "question": "Can the derived class be made abstract if multiple inheritance is used?",
        "options": [
            "No, because other classes must be abstract too",
            "Yes, if all the functions are implemented",
            "Yes, if all the methods are predefined",
            "No, since constructors won\u2019t be there"
        ],
        "explanation": "Explanation: The derived class must not be abstract. This is because the abstract classes doesn\u2019t have constructor and hence we won\u2019t be having the capability to have instances. This will restrict the use of multiple inheritance.",
        "index": 323,
        "difficulty": -0.27211269826512385,
        "correct": 4
    },
    {
        "question": "Which among the following is best to define hierarchical inheritance?",
        "options": [
            "More than one classes being derived from one class",
            "More than 2 classes being derived from single base class",
            "At most 2 classes being derived from single base class",
            "At most 1 class derived from another class"
        ],
        "explanation": "Explanation: When two or more classes get derived from a single base class, it is known as hierarchical inheritance. This gives us freedom to use same code with different scopes and flexibility into different classes.",
        "index": 324,
        "difficulty": -0.26995400232514655,
        "correct": 1
    },
    {
        "question": "Do members of base class gets divided among all of its child classes?",
        "options": [
            "Yes, equally",
            "Yes, depending on  type of inheritance",
            "No, it\u2019s doesn\u2019t get divided",
            "No, it may or may not get divided"
        ],
        "explanation": "Explanation: The class members doesn\u2019t get divided among the child classes. All the members get derived to each of the subclasses as whole. The only restriction is from the access specifiers used.",
        "index": 325,
        "difficulty": -0.2628839189182717,
        "correct": 3
    },
    {
        "question": "Each class can inherit the base class ________________",
        "options": [
            "Independently using any inheritance",
            "Independently with private inheritance only",
            "With same type of inheritance",
            "With each class using different inheritance only"
        ],
        "explanation": "Explanation: The classes can inherit the base class using any type of inheritance. There is no mandatory condition to use same private,public or protected inheritance only.",
        "index": 326,
        "difficulty": -0.2612268571635452,
        "correct": 1
    },
    {
        "question": "How many classes must be there to implement hierarchical inheritance?",
        "options": [
            "Exactly 3",
            "At least 3",
            "At most 3",
            "At least 1"
        ],
        "explanation": "Explanation: At least 3 classes must be there. Two derived classes and one base class. This lets us implement two classes that have common characteristics from base class.",
        "index": 327,
        "difficulty": -0.25761310214973143,
        "correct": 2
    },
    {
        "question": "Base class  _______________",
        "options": [
            "Can be made abstract",
            "Can\u2019t be made abstract",
            "Must be abstract",
            "If made abstract, compile time error"
        ],
        "explanation": "Explanation: The base class may or may not be declared abstract. It depends on the need of program. If it is made abstract, it can contain undefined functions too. In turn, those functions will have to be implemented by each of the derived classes.",
        "index": 328,
        "difficulty": -0.2573990163790296,
        "correct": 1
    },
    {
        "question": "Which access specifiers should be used so that all the derived classes restrict further inheritance of base class members?",
        "options": [
            "Private",
            "Public",
            "Protected",
            "Any inheritance type can be used"
        ],
        "explanation": "Explanation: All the derived classes must use private inheritance. This will make the members of base class private in derived classes. Hence none of the members of base class will be available for further inheritance.",
        "index": 329,
        "difficulty": -0.24384057255561364,
        "correct": 1
    },
    {
        "question": "Which among the following best defines the hybrid inheritance?",
        "options": [
            "Combination of two or more inheritance types",
            "Combination of same type of inheritance",
            "Inheritance of more than 7 classes",
            "Inheritance involving all the types of inheritance"
        ],
        "explanation": "Explanation: When more than one type of inheritance are used together, it results in new type of inheritance which is in general known as hybrid inheritance. This may of may not have better capabilities.",
        "index": 330,
        "difficulty": -0.24301696498723313,
        "correct": 1
    },
    {
        "question": "How many types of inheritance should be used for hybrid?",
        "options": [
            "Only 1",
            "At least 2",
            "At most two",
            "Always more than 2"
        ],
        "explanation": "Explanation: There must be combination of at least 2 types of inheritance. The inheritance should be of different type.",
        "index": 331,
        "difficulty": -0.2393047904233887,
        "correct": 2
    },
    {
        "question": "If single inheritance is used with class A and B. A is base class. Then class C, D and E where C is base class and D is derived from C, then E is derived from D. Class C is made to inherit from class B. Which is the resultant type?",
        "options": [
            "Single level",
            "Multilevel",
            "Hybrid",
            "Multiple"
        ],
        "explanation": "Explanation: The statement represents multilevel inheritance. It is not hybrid since looking at complete idea, one can\u2019t differentiate whether two type of inheritance are used. Hence it is multilevel inheritance.",
        "index": 332,
        "difficulty": -0.2392635737478943,
        "correct": 2
    },
    {
        "question": "Diamond problem includes ____________________ hybrid inheritance.",
        "options": [
            "Hierarchical and Multiple",
            "Hierarchical and Hierarchical",
            "Multiple and Multilevel",
            "Single, Hierarchical and Multiple"
        ],
        "explanation": "Explanation: The diamond problem arises when more than one classes are derived from one class and then those classes are used to derive single clas. Resulting in ambiguity of same functions from each class.",
        "index": 333,
        "difficulty": -0.2329149585914383,
        "correct": 1
    },
    {
        "question": "If __________________ inheritance is done continuously, it is similar to tree structure.",
        "options": [
            "Hierarchical",
            "Multiple",
            "Multilevel",
            "Hierarchical and Multiple"
        ],
        "explanation": "Explanation: Hierarchical inheritance is deriving more than one classes from a base class, it it is done continuously and subsequently, it results forming a tree like structure of classes being linked.",
        "index": 334,
        "difficulty": -0.22448489170691488,
        "correct": 1
    },
    {
        "question": "Which amongst the following is true for hybrid inheritance?",
        "options": [
            "Constructor calls are in reverse",
            "Constructor calls are priority based",
            "Constructor of only derived class is called",
            "Constructor calls are usual"
        ],
        "explanation": "Explanation: The constructors will be called in usual way. First the parent class Constructor and then the derived class Constructors. This is done to initialise all the members properly.",
        "index": 335,
        "difficulty": -0.22252861175068528,
        "correct": 4
    },
    {
        "question": "Which type of inheritance must be used so that the resultant is hybrid?",
        "options": [
            "Multiple",
            "Hierarchical",
            "Multilevel",
            "None"
        ],
        "explanation": "Explanation: The use of any specific type is not necessary. Though the final structure should not be the same, it should represent more than one type of inheritance if class diagram is drawn.",
        "index": 336,
        "difficulty": -0.21876188392553697,
        "correct": 4
    },
    {
        "question": "The private member\u2019s are made public to all the classes in inheritance.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The private member\u2019s scope can\u2019t be changed and those can never be accessed in other classes. Only the class containing private member\u2019s can access its own members.",
        "index": 337,
        "difficulty": -0.2183765947391545,
        "correct": 2
    },
    {
        "question": "If hierarchical inheritance requires to inherit more than one class to single class, which syntax is correct? (A, B, C are class names)",
        "options": [
            "hierarchical class A: public B, public C",
            "multiple class A: public B, public C",
            "many class A: public B, public C",
            "class A: public B, public C"
        ],
        "explanation": "Explanation: The syntax is as same as declaration of other classes. There is no specific keyword defined for using hybrid inheritance in programming. Only thing is to specify the class name separated by commas.",
        "index": 338,
        "difficulty": -0.2081790474148062,
        "correct": 4
    },
    {
        "question": "What is the maximum number of classes allowed in hybrid inheritance?",
        "options": [
            "7",
            "127",
            "255",
            "As many as required"
        ],
        "explanation": "Explanation: The classes in any type of inheritance can inherit as many classes as required. The only condition that may arise is memory management. The classes can inherit most of the features from more than one class.",
        "index": 339,
        "difficulty": -0.2010531404719762,
        "correct": 4
    },
    {
        "question": "What is the minimum number of classes to be there in a program implementing hybrid inheritance?",
        "options": [
            "2",
            "3",
            "4",
            "No limit"
        ],
        "explanation": "Explanation: The answer is no limit. There is no condition defined for limit of classes that has to be used in hybrid. Though you must have at least 4 classes so that one set of multiple or hierarchical inheritance is there and one more class to use single level inheritance.",
        "index": 340,
        "difficulty": -0.19680323131578348,
        "correct": 4
    },
    {
        "question": "If object of lowest level class is created (last derived class) ________________  of its parent class constructors are called.",
        "options": [
            "Few",
            "All",
            "Only parent and parent",
            "Base and Derived"
        ],
        "explanation": "Explanation: When derived class object is created, all of its successor parent classes constructors are called. Constructor of all the connected classes is not created. Since the parent members have to be initialised, but other derived classes are not needed.",
        "index": 341,
        "difficulty": -0.16924030009310176,
        "correct": 3
    },
    {
        "question": "If hybrid inheritance is used, it mostly shows _______________ feature of OOP.",
        "options": [
            "Flexibility",
            "Reusability",
            "Efficiency",
            "Code readability"
        ],
        "explanation": "Explanation: The code is reusable in most of the classes and the data becomes more linked to other classes. Other features are also exhibited, but the code reusability is used the most. Code readability becomes relatively less. Flexibility increases but it depends on how the hybrid inheritance is used.",
        "index": 342,
        "difficulty": -0.15560765063133175,
        "correct": 2
    },
    {
        "question": "The sequence of destructors being called while using hybrid inheritance is ____________",
        "options": [
            "Reverse of constructors being called",
            "Reverse of classes being made",
            "Reverse of objects being created",
            "Reverse of code calling objects"
        ],
        "explanation": "Explanation: The destructors are always called in reverse order of constructors being called always. The type of inheritance doesn\u2019t matter. The only important concept is the sequence of classes being inherited.",
        "index": 343,
        "difficulty": -0.15278859367810504,
        "correct": 1
    },
    {
        "question": "Overloading operators are possible only by using hybrid inheritance.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The overloading concept is not related to the types of inheritance being used. Overloading operators can be done without using inheritance. You don\u2019t even have to use more than one class for operator overloading.",
        "index": 344,
        "difficulty": -0.1394642321100843,
        "correct": 2
    },
    {
        "question": "Virtual function is ______ class function which expected to be redefined in ______ class, so that when reference is made to derived class object using pointer then we can call virtual function to execute ________ class definition version.",
        "options": [
            "Base, derived, derived",
            "Derived, Derived, Derived",
            "Base, derived, base",
            "Base, base, derived"
        ],
        "explanation": "Explanation: The functions which may give rise to ambiguity due to inheritance, can be declared virtual. So that whenever derived class object is referred using pointer or reference to the base class methods, we can still call the derived class methods using virtual function. Hence this differentiates those methods from each other.",
        "index": 345,
        "difficulty": -0.13272205341221444,
        "correct": 1
    },
    {
        "question": "What does a virtual function ensure for an object, among the following?",
        "options": [
            "Correct method is called, regardless of the class defining it",
            "Correct method is called, regardless of the object being called",
            "Correct method is called, regardless of the type of reference used for function call",
            "Correct method is called, regardless of the type of function being called by objects"
        ],
        "explanation": "Explanation: It is property of the virtual function and one of their main use. Its use ensure that the correct method is called even though it is been called from different pointer or references. This also decreases chance of mistakes in program.",
        "index": 346,
        "difficulty": -0.13170253435495338,
        "correct": 3
    },
    {
        "question": "Virtual functions are mainly used to achieve _____________",
        "options": [
            "Compile time polymorphism",
            "Interpreter polymorphism",
            "Runtime polymorphism",
            "Functions code polymorphism"
        ],
        "explanation": "Explanation: It is used to achieve runtime polymorphism. The functions which are inherited and overridden, so at runtime the correct function is executed. The correct function call is made from the intended class.",
        "index": 347,
        "difficulty": -0.10372567920845954,
        "correct": 3
    },
    {
        "question": "Which keyword is used to declare virtual functions?",
        "options": [
            "virtual",
            "virt",
            "anonymous",
            "virtually"
        ],
        "explanation": "Explanation: The virtual keyword is used to declare virtual functions. Anonymous keyword is used with classes and have a different meaning. The virtual functions are used to call the intended function of the derived class.",
        "index": 348,
        "difficulty": -0.10357136007331391,
        "correct": 1
    },
    {
        "question": "Where the virtual function should be defined?",
        "options": [
            "Twice in base class",
            "Derived class",
            "Base class and derived class",
            "Base class"
        ],
        "explanation": "Explanation: The virtual function should be declared in base class. So that when the derived class inherits from the base class, the functions can be differentiated from the one in base class and another in derived class.",
        "index": 349,
        "difficulty": -0.10161405457243466,
        "correct": 4
    },
    {
        "question": "The resolving of virtual functions is done at ______________",
        "options": [
            "Compile time",
            "Interpret time",
            "Runtime",
            "Writing source code"
        ],
        "explanation": "Explanation: The resolving of virtual functions that are to be called is done at run time. The base class and the derived classes may contain different definitions and different variables, so all these things are resolved at run time and decided which function is to be called.",
        "index": 350,
        "difficulty": -0.09643595452891951,
        "correct": 3
    },
    {
        "question": "In which access specifier should a virtual function be defined?",
        "options": [
            "Private",
            "Public",
            "Protected",
            "Default"
        ],
        "explanation": "Explanation: The virtual functions must be defined in public section of a class. This is to ensure that the virtual function is available everywhere in the program. Also to avoid any error while resolving the method.",
        "index": 351,
        "difficulty": -0.09200849338094708,
        "correct": 2
    },
    {
        "question": "Virtual functions can never be made _______________",
        "options": [
            "Static function",
            "Parameterized function",
            "Default argument function",
            "Zero parameter function"
        ],
        "explanation": "Explanation: The virtual function must not be static. Those functions are the property of individual objects and not of a class as a whole. The functions should not be made common for all the objects of that class.",
        "index": 352,
        "difficulty": -0.08406867959971898,
        "correct": 1
    },
    {
        "question": "Virtual functions can\u2019t be made friend function of other classes.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The friend functions can access the private members also. This may hinder the security of class members. This is why the functions should not be made friend functions of other class.",
        "index": 353,
        "difficulty": -0.08226952839725454,
        "correct": 1
    },
    {
        "question": "Which is a must condition for virtual function to achieve runtime polymorphism?",
        "options": [
            "Virtual function must be accessed with direct name",
            "Virtual functions must be accessed using base class object",
            "Virtual function must be accessed using pointer or reference",
            "Virtual function must be accessed using derived class object only"
        ],
        "explanation": "Explanation: The virtual functions must be called using pointer or reference. This is mandatory so that the intended function gets executed while resolving the method at runtime. The must not be any ambiguity between the method of parent class and derived class.",
        "index": 354,
        "difficulty": -0.08030666430269617,
        "correct": 3
    },
    {
        "question": "Which among the following is true for virtual functions?",
        "options": [
            "Prototype must be different in base and derived class",
            "Prototype must be same in base class and derived class",
            "Prototype must be given only in base class",
            "Prototype must have different signature in base and derived class"
        ],
        "explanation": "Explanation: The prototype must be the same. Because the function is to be overridden in the derived class. If the function prototype is different in derived class then it will not override the base class function and hence virtual function concept won\u2019t work here.",
        "index": 355,
        "difficulty": -0.07167228612047971,
        "correct": 2
    },
    {
        "question": "The virtual functions must be declared and defined in _____________ class and overridden in ___________ class.",
        "options": [
            "Base, base",
            "Derived, derived",
            "Derived, base",
            "Base, derived"
        ],
        "explanation": "Explanation: The virtual functions must be declared and defined in base class. The functions can be redefined in derived class. If redefined in derived class then it overrides the base class function definition.",
        "index": 356,
        "difficulty": -0.07154834223093154,
        "correct": 4
    },
    {
        "question": "It is __________ to redefine the virtual function in derived class.",
        "options": [
            "Necessary",
            "Not necessary",
            "Not acceptable",
            "Good practice"
        ],
        "explanation": "Explanation: It is not necessary to redefine the virtual function in the derived class. If not defined, the base class function definition is used but if defined, the intended definition is used according to need. It is not about good coding practice as it should be redefined only if needed.",
        "index": 357,
        "difficulty": -0.028243934354421185,
        "correct": 2
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "A class may have virtual destructor but not virtual constructor",
            "A class may have virtual constructor but not virtual destructor",
            "A class may have virtual constructor and virtual constructor",
            "A class may have either virtual destructor or virtual constructor"
        ],
        "explanation": "Explanation: Any class can contain virtual destructor. But is not possible to define a virtual constructor. The reason behind is that the destructors can be overridden but constructors should not be.",
        "index": 358,
        "difficulty": -0.019091637692472574,
        "correct": 1
    },
    {
        "question": "If virtual function of base class is redefined in derived class then ________________",
        "options": [
            "It must be declared virtual in derived class also",
            "It may or may not be declared virtual in derived class",
            "It can must not be declared virtual in derived class",
            "It must be declared normally in derived class"
        ],
        "explanation": "Explanation: The virtual functions may or may not be declared virtual in derived class. This is because if the overriding function defined in derived class is not declared virtual explicitly, the compiler makes it virtual implicitly.",
        "index": 359,
        "difficulty": -0.00886761505344058,
        "correct": 2
    },
    {
        "question": "Which among the following best defines the abstract methods?",
        "options": [
            "Functions declared and defined in base class",
            "Functions only declared in base class",
            "Function which may or may not be defined in base class",
            "Function which must be declared in derived class"
        ],
        "explanation": "Explanation: The abstract functions must only be declared in base class. Their definitions are provided by the derived classes. It is a mandatory condition.",
        "index": 360,
        "difficulty": 0.0010733400045968011,
        "correct": 2
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "The abstract functions must be only declared in derived classes",
            "The abstract functions must not be defined in derived classes",
            "The abstract functions must be defined in base and derived class",
            "The abstract functions must be defined either in base or derived class"
        ],
        "explanation": "Explanation: The abstract functions can\u2019t be defined in base class. They are to be defined in derived classes. It is a rule for abstract functions.",
        "index": 361,
        "difficulty": 0.0103175783837135,
        "correct": 1
    },
    {
        "question": "How are abstract functions different from the abstract functions?",
        "options": [
            "Abstract must not be defined in base class whereas virtual function can be defined",
            "Either of those must be defined in base class",
            "Different according to definition",
            "Abstract functions are faster"
        ],
        "explanation": "Explanation: The abstract functions are only declared in base class. Derived classes have to implement those functions in order to inherit that base class. The functions are always defined in derived classes only.",
        "index": 362,
        "difficulty": 0.015930566599210216,
        "correct": 1
    },
    {
        "question": "Which among the following is correct?",
        "options": [
            "Abstract functions should not be defined in all the derived classes",
            "Abstract functions should be defined only in one derived class",
            "Abstract functions must be defined in base class",
            "Abstract functions must be defined in all the derived classes"
        ],
        "explanation": "Explanation: The abstract function are only declared in base classes and then has to be defined in all the derived classes. This allows all the derived classes to define own definition of any function whose declaration in base class might be common to all the other derived classes.",
        "index": 363,
        "difficulty": 0.023135223881550537,
        "correct": 4
    },
    {
        "question": "It is ____________________ to define the abstract functions.",
        "options": [
            "Mandatory for all the classes in program",
            "Necessary for all the base classes",
            "Necessary for all the derived classes",
            "Not mandatory for all the derived classes"
        ],
        "explanation": "Explanation: The derived classes must define the abstract function of base class in their own body. This is a necessary condition. Because the abstract functions doesn\u2019t contain any definition in base class and hence becomes mandatory for the derived class to define them. All the functions in a program must have some definition.",
        "index": 364,
        "difficulty": 0.03178579764217382,
        "correct": 3
    },
    {
        "question": "The abstract function definitions in derived classes is enforced at _________",
        "options": [
            "Runtime",
            "Compile time",
            "Writing code time",
            "Interpreting time"
        ],
        "explanation": "Explanation: When the program is compiled, these definitions are checked if properly defined. This compiler also ensure that the function is being defined by all the derived classes. Hence we get a compile time error if not done.",
        "index": 365,
        "difficulty": 0.03747619424979565,
        "correct": 2
    },
    {
        "question": "What is this feature of enforcing definitions of abstract function at compile time called?",
        "options": [
            "Static polymorphism",
            "Polymorphism",
            "Dynamic polymorphism",
            "Static or dynamic according to need"
        ],
        "explanation": "Explanation: The feature is known as Dynamic polymorphism. Because the definitions are resolved at runtime. Even though the definitions are checked at compile time, they are resolved at runtime only.",
        "index": 366,
        "difficulty": 0.03791483242791216,
        "correct": 3
    },
    {
        "question": "What is the syntax for using abstract method?",
        "options": [
            "<access-modifier>abstract<return-type>method_name (parameter)",
            "abs<return-type>method name (parameter)",
            "<access-modifier>abstract return-type method name (parameter)",
            "<access-modifier>abstract <returning> method name (parameter)"
        ],
        "explanation": "Explanation: The syntax must firstly contain the access modifier. Then the keyword abstract is written to mention clearly to the compiler that it is an abstract method. Then prototype of the function with return type, function name and parameters.",
        "index": 367,
        "difficulty": 0.04245331987473122,
        "correct": 1
    },
    {
        "question": "If a function declared as abstract in base class doesn\u2019t have to be defined in derived class then ______",
        "options": [
            "Derived class must define the function anyhow",
            "Derived class should be made abstract class",
            "Derived class should not derive from that base class",
            "Derived class should not use that function"
        ],
        "explanation": "Explanation: If the function that is not to be defined in derived class but is declared as abstract in base class then the derived class must be made an abstract class. This will make the concept mandatory that the derived class must have one subclass to define that method.",
        "index": 368,
        "difficulty": 0.04405867984355272,
        "correct": 2
    },
    {
        "question": "Static methods can\u2019t be made abstract in java.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The abstract functions can\u2019t be made static in a program. If those are made static then the function will be a property of class rather than each object. In turn ever object or derived class must use the common definition given in the base class. But abstract functions can\u2019t be defined in the base class. Hence not possible.",
        "index": 369,
        "difficulty": 0.060055312338288314,
        "correct": 1
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "Abstract methods can be static",
            "Abstract methods can be defined in derived class",
            "Abstract methods must not be static",
            "Abstract methods can be made static in derived class"
        ],
        "explanation": "Explanation: The abstract methods can never be made static. Even if it is in derived class, it can\u2019t be made static. If this happens, then all the subsequent sub classes will have a common definition of abstract function which is not desirable.",
        "index": 370,
        "difficulty": 0.0626736654952329,
        "correct": 3
    },
    {
        "question": "Which among the following is correct for abstract methods?",
        "options": [
            "It must have different prototype in the derived class",
            "It must have same prototype in both base and derived class",
            "It must have different signature in derived class",
            "It must have same return type only"
        ],
        "explanation": "Explanation: The prototype must be the same. This is to override the function declared as abstract in base class. Or else it will not be possible to override the abstract function of base class and hence we get a compile time error.",
        "index": 371,
        "difficulty": 0.0650649522817357,
        "correct": 2
    },
    {
        "question": "If a class have all the abstract methods the class will be known as ___________",
        "options": [
            "Abstract class",
            "Anonymous class",
            "Base class",
            "Derived class"
        ],
        "explanation": "Explanation: The classes containing all the abstract methods are known as abstract classes. And the abstract classes can never have any normal function with definition. Hence known as abstract class.",
        "index": 372,
        "difficulty": 0.08126788496997506,
        "correct": 1
    },
    {
        "question": "The abstract methods can never be ___________ in a base class.",
        "options": [
            "Private",
            "Protected",
            "Public",
            "Default"
        ],
        "explanation": "Explanation: The base class must not contain the abstract methods. The methods have to be derived and defined in derived class. But if it is made private it can\u2019t be inherited. Hence we can\u2019t declare it as a private member.",
        "index": 373,
        "difficulty": 0.08298971899269336,
        "correct": 1
    },
    {
        "question": "The abstract method definition can be made ___________ in derived class.",
        "options": [
            "Private",
            "Protected",
            "Public",
            "Private, public, or protected"
        ],
        "explanation": "Explanation: The derived class implements the definition of the abstract methods of base class. Those can be made private in derived class if security is needed. There won\u2019t be any problem in declaring it as private.",
        "index": 374,
        "difficulty": 0.10173316375441122,
        "correct": 4
    },
    {
        "question": "How many types of member functions are possible in general?",
        "options": [
            "2",
            "3",
            "4",
            "5"
        ],
        "explanation": "Explanation: There are basically 5 types of member functions possible. The types include simple, static, const, inline, and friend member functions. Any of these types can be used in a program as per requirements.",
        "index": 375,
        "difficulty": 0.11283380684389455,
        "correct": 4
    },
    {
        "question": "Simple member functions are ______________________",
        "options": [
            "Ones defined simply without any type",
            "Ones defined with keyword simple",
            "Ones that are implicitly provided",
            "Ones which are defined in all the classes"
        ],
        "explanation": "Explanation: When there is no type defined for any function and just a simple syntax is used with the return type, function name and parameter list then those are known as simple member functions. This is a general definition of simple members.",
        "index": 376,
        "difficulty": 0.11631007142956884,
        "correct": 1
    },
    {
        "question": "What are static member functions?",
        "options": [
            "Functions which use only static data member but can\u2019t be accessed directly",
            "Functions which uses static and other data members",
            "Functions which can be accessed outside the class with the data members",
            "Functions using only static data and can be accessed directly in main() function"
        ],
        "explanation": "Explanation: The static member functions can be accessed directly in the main function. There is no restriction on direct use. We can call them with use of objects also. But the restriction is that the static member functions can only use the static data members of the class.",
        "index": 377,
        "difficulty": 0.11870306755183879,
        "correct": 4
    },
    {
        "question": "How can static member function can be accessed directly in main() function?",
        "options": [
            "Dot operator",
            "Colon",
            "Scope resolution operator",
            "Arrow operator"
        ],
        "explanation": "Explanation: The static member functions can be accessed directly in the main() function. The only restriction is that those must use only static data members of the class. These functions are property of class rather than each object.",
        "index": 378,
        "difficulty": 0.12252495930450769,
        "correct": 3
    },
    {
        "question": "Correct syntax to access the static member functions from the main() function is ______________",
        "options": [
            "classObject::functionName();",
            "className::functionName();",
            "className:classObject:functionName();",
            "className.classObject:functionName();"
        ],
        "explanation": "Explanation: The syntax in option b must be followed in order to call the static functions directly from the main() function. That is a predefined syntax. Scope resolution helps to spot the correct function in the correct class.",
        "index": 379,
        "difficulty": 0.12701123233796974,
        "correct": 2
    },
    {
        "question": "What are const member functions?",
        "options": [
            "Functions in which none of the data members can be changed in a program",
            "Functions in which only static members can be changed",
            "Functions which treat all the data members as constant and doesn\u2019t allow changes",
            "Functions which can change only the static members"
        ],
        "explanation": "Explanation: The const member functions are intended to keep the value of all the data members of a class same and doesn\u2019t allow any changes on them. The data members are treated as constant data and any modification inside the const function is restricted.",
        "index": 380,
        "difficulty": 0.13257102383530928,
        "correct": 3
    },
    {
        "question": "Which among the following best describes the inline member functions?",
        "options": [
            "Functions defined inside the class only",
            "Functions with keyword inline only",
            "Functions defined outside the class",
            "Functions defined inside the class or with the keyword inline"
        ],
        "explanation": "Explanation: The functions which are defined with the keyword inline or are defined inside the class are treated to be inline functions. Definitions inside the class are implicitly made inline if none of the complex statements are used in the definition.",
        "index": 381,
        "difficulty": 0.14027697958498297,
        "correct": 4
    },
    {
        "question": "What are friend member functions (C++)?",
        "options": [
            "Member function which can access all the members of a class",
            "Member function which can modify any data of a class",
            "Member function which doesn\u2019t have access to private members",
            "Non-member functions which have access to all the members (including private) of a class"
        ],
        "explanation": "Explanation: A non-member function of a class which can access even the private data of a class is a friend function. It is an exception on access to private members outside the class. It is sometimes considered as a member functions since it has all the access that a member function in general have.",
        "index": 382,
        "difficulty": 0.14892987348282727,
        "correct": 4
    },
    {
        "question": "What is the syntax of a const member function?",
        "options": [
            "void fun() const {}",
            "void fun() constant {}",
            "void const fun() {}",
            "const void fun(){}"
        ],
        "explanation": "Explanation: The general syntax to be followed in order to declare a const function in a class is as in option a. The syntax may vary in different programming languages.",
        "index": 383,
        "difficulty": 0.15113636144991904,
        "correct": 1
    },
    {
        "question": "Which keyword is used to make a nonmember function as friend function of a class?",
        "options": [
            "friendly",
            "new",
            "friend",
            "connect"
        ],
        "explanation": "Explanation: The keyword friend is provided in programming languages to use it whenever a functions is to be made friend of one class or other. The keyword indicates that the function is capable of new functionalities like accessing private members.",
        "index": 384,
        "difficulty": 0.1513235045367578,
        "correct": 3
    },
    {
        "question": "Member functions _____________________",
        "options": [
            "Must be defined inside class body",
            "Can be defined inside class body or outside",
            "Must be defined outside the class body",
            "Can be defined in another class"
        ],
        "explanation": "Explanation: The functions definitions can be given inside or outside the body of class. If defined inside, general syntax is used. If defined outside then the class name followed by scope resolution operator and then function name must be given for the definition.",
        "index": 385,
        "difficulty": 0.15233626911907994,
        "correct": 3
    },
    {
        "question": "All type of member functions can\u2019t be used inside a single class.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: There is no restriction on the use of type of member functions inside a single class. Any type any number of times can be defined inside a class. The member functions can be used as required.",
        "index": 386,
        "difficulty": 0.1621949551625903,
        "correct": 2
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "Member functions can never be private",
            "Member functions can never be protected",
            "Member functions can never be public",
            "Member functions can be defined in any access specifier"
        ],
        "explanation": "Explanation: The member functions can be defined inside any specifier. There is no restriction. The programmer can apply restrictions on its use by specifying the access specifier with the functions.",
        "index": 387,
        "difficulty": 0.1767631967943304,
        "correct": 4
    },
    {
        "question": "Which keyword is used to define the static member functions?",
        "options": [
            "static",
            "stop",
            "open",
            "state"
        ],
        "explanation": "Explanation: The static keyword is used to declare any static member function in a class. The static members become common to each object of the class being created. They share the same values.",
        "index": 388,
        "difficulty": 0.19034978793793922,
        "correct": 1
    },
    {
        "question": "Which keyword is used to define the inline member function?",
        "options": [
            "no keyword required",
            "inline",
            "inlined",
            "line"
        ],
        "explanation": "Explanation: The inline keyword is used to defined the inline member functions in a class. The functions are implicitly made inline if defined inside the class body, but only if they doesn\u2019t have any complex statement inside. All functions defined outside the class body must be mentioned with an explicit inline keyword.",
        "index": 389,
        "difficulty": 0.19088373227941702,
        "correct": 2
    },
    {
        "question": "Which among the following are valid ways of overloading the operators?",
        "options": [
            "Only using friend function",
            "Only using member function",
            "Either member functions or friend functions can be used",
            "Operators can\u2019t be overloaded"
        ],
        "explanation": "Explanation: The operators can be overloaded by using the member function or even the friend functions can be used. This is because both of these can access all the data members of a class.",
        "index": 390,
        "difficulty": 0.19207450890883626,
        "correct": 3
    },
    {
        "question": "Which among the following is mandatory condition for operators overloading?",
        "options": [
            "Overloaded operator must be member function of the left operand",
            "Overloaded operator must be member function of the right operand",
            "Overloaded operator must be member function of either left or right operand",
            "Overloaded operator must not be dependent on the operands"
        ],
        "explanation": "Explanation: The operator to be overloaded must be made the member function of the operand on left side of expressions to be used. This allows the compiler to identify whether the overloading has to be used or not. This rule also reduces the ambiguity in code.",
        "index": 391,
        "difficulty": 0.19815754840831623,
        "correct": 1
    },
    {
        "question": "When the operator to be overloaded becomes the left operand member then ______________",
        "options": [
            "The right operand acts as implicit object represented by *this",
            "The left operand acts as implicit object represented by *this",
            "Either right or left operand acts as implicit object represented by *this",
            "*this pointer is not applicable in that member function"
        ],
        "explanation": "Explanation: The left operand becomes the object that is referred by *this pointer in the member function that will be called while using operator overloading. This is done to point to a specific object on which the overloading will be applied.",
        "index": 392,
        "difficulty": 0.20522292396583763,
        "correct": 2
    },
    {
        "question": "If the left operand is pointed by *this pointer, what happens to other operands?",
        "options": [
            "Other operands are passed as function return type",
            "Other operands are passed to compiler implicitly",
            "Other operands must be passed using another member function",
            "Other operands are passed as function arguments"
        ],
        "explanation": "Explanation: The operands that are used during overloading expect the left operand, can be passed as function arguments. Those are then referred in function definition with the names specified in the argument list.",
        "index": 393,
        "difficulty": 0.22199671131514576,
        "correct": 4
    },
    {
        "question": "If a friend overloaded operator have to be changed to member overloaded operator, which operator should be used with the class name?",
        "options": [
            "Scope resolution operator",
            "Colon",
            "Arrow operator",
            "Dot operator"
        ],
        "explanation": "Explanation: The scope resolution operator can be used followed by the class name. Then the operator keyword with the operator symbol that should be overloaded. This is done to use member function instead of friend function.",
        "index": 394,
        "difficulty": 0.24150864987951737,
        "correct": 1
    },
    {
        "question": "What is the syntax to overload an operator?",
        "options": [
            "className::operator<operatorSymbol>(parameters)",
            "className:operator<operatorSymbol>(parameters)",
            "className.operator<operatorSymbol>(paramteres)",
            "className->operator<operatorSymbol>(parameters)"
        ],
        "explanation": "Explanation: The class name is followed by the scope resolution operator. This is done to specify the class to which the function should belong to. Then the keyword operator should be used in order to indicate the operator that is to be overloaded. Then come the parameters list to specify other operands.",
        "index": 395,
        "difficulty": 0.2601765849224815,
        "correct": 1
    },
    {
        "question": "Why the left parameter is removed from parameter list?",
        "options": [
            "Because it is of no use",
            "Because it is never used in definitions",
            "Because it becomes parameter pointed by *this",
            "Because it can\u2019t be referred by *this pointer"
        ],
        "explanation": "Explanation: The left object is removed from being passed as a parameter, because it is implicitly passed. It is passed implicitly because it is considered the object with respect to which the overloading function is being called.",
        "index": 396,
        "difficulty": 0.2630335497979961,
        "correct": 3
    },
    {
        "question": "Which object\u2019s members can be called directly while overloading operator function is used (In function definition)?",
        "options": [
            "Left operand members",
            "Right operand members",
            "All operand members",
            "None of the members"
        ],
        "explanation": "Explanation: This is because the left operand is passed implicitly. It is pointed by *this. This in turn means we can use the direct member names of the object because those are again converted to a syntax containing *this pointer implicitly.",
        "index": 397,
        "difficulty": 0.2645172825328417,
        "correct": 1
    },
    {
        "question": "If left operand member is specified directly in the function definition, which is the correct implicit conversion of that syntax?",
        "options": [
            "*this className",
            "*this parameterObject",
            "*this returnedObject",
            "*this object"
        ],
        "explanation": "Explanation: Since the left operands are passed implicitly, those object members can be accessed directly in the function definition. The compiler converts the syntax into the syntax that can be processed. The implicitly converted syntax contains *this pointer followed by the objectName that is left operand in the expression.",
        "index": 398,
        "difficulty": 0.2830184485607359,
        "correct": 4
    },
    {
        "question": "When the friend operator overloading is converted into member operator overloading _______________",
        "options": [
            "Two parameters of friend function remains same parameters in member operator overloading",
            "Two parameters of friend function becomes only one parameter of member function",
            "Two parameters of friend function are removed while using member function",
            "Two parameters of friend function are made 4 in member operator overloading"
        ],
        "explanation": "Explanation: The friend function would accept two arguments if some binary operator is overloaded. When we try to convert that definition to member operator overloading then it becomes only one parameter. The reason behind is that the left operand is passed implicitly while using the member functions.",
        "index": 399,
        "difficulty": 0.29364015172606495,
        "correct": 2
    },
    {
        "question": "Where in the parameter list is the implicit *this is added?",
        "options": [
            "Right most parameter",
            "Anywhere in parameter list",
            "Left most parameter",
            "Not added to parameter list"
        ],
        "explanation": "Explanation: The left operand is passed implicitly by the compiler to the member function. But this is done, when the compiler adds the calling object as *this to the parameter list. It is always added as the left most parameter, i.e. the first parameter of the function.",
        "index": 400,
        "difficulty": 0.29410933803476036,
        "correct": 3
    },
    {
        "question": "Which operator among the following can be overloading using only member function?",
        "options": [
            "Assignment operator",
            "Addition operator",
            "Subtraction operator",
            "Multiplication and division operator"
        ],
        "explanation": "Explanation: Only the assignment operator among the options given must be overloaded using the member functions. The assignment operator can\u2019t be overloaded using friend function. This is a restriction in the programming languages to make the programs more resistant towards errors.",
        "index": 401,
        "difficulty": 0.29657857074906335,
        "correct": 1
    },
    {
        "question": "Which operator among the following can be overloaded using both friend function and member function?",
        "options": [
            "Assignment operator",
            "Subscript",
            "Member selection (arrow operator)",
            "Modulus operator"
        ],
        "explanation": "Explanation: Only the modulus operator among the given operators can be overloaded using either friend function or member function. Other operators must be overloaded using only the member functions.",
        "index": 402,
        "difficulty": 0.3158246347933362,
        "correct": 4
    },
    {
        "question": "All the operators can be overloaded using the member function operator overloading.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: It is not the case that all the operators can be overloaded using the member operator overloading. There are some cases where the operators must be overloaded using the friend function only. The reason behind is that the left operand should be passed *this pointer, but the left operand in these cases might be object of some other class. Hence can\u2019t be done.",
        "index": 403,
        "difficulty": 0.3181242709697605,
        "correct": 2
    },
    {
        "question": "Which operator among the following must be overloaded using the friend function?",
        "options": [
            "<< operator only",
            ">> operator only",
            "Both << and >> operators",
            "It\u2019s not mandatory to use friend function in any case"
        ],
        "explanation": "Explanation: In some cases it is mandatory to use the friend functions for overloading the operators. Here both the << and >> operators must be overloaded using friend function because the left operand is object of some other class and the right operand is usually of some different type.",
        "index": 404,
        "difficulty": 0.3192305381011433,
        "correct": 3
    },
    {
        "question": "What does memory allocation for objects mean?",
        "options": [
            "Actual creation and memory allocation for object members",
            "Creation of member functions",
            "Creation of data members for a class",
            "Actual creation and data declaration for object members"
        ],
        "explanation": "Explanation: The memory allocated for the object members indicates actual creation of the object members. This is known as memory allocation for object.",
        "index": 405,
        "difficulty": 0.31966713512083667,
        "correct": 1
    },
    {
        "question": "Where is the memory allocated for the objects?",
        "options": [
            "HDD",
            "Cache",
            "RAM",
            "ROM"
        ],
        "explanation": "Explanation: The memory for the objects or any other data is allocated in RAM initially. This is while we run a program all the memory allocation takes place in some RAM segments. Arrays in heap and local members in stack etc.",
        "index": 406,
        "difficulty": 0.32478063295156323,
        "correct": 3
    },
    {
        "question": "When is the memory allocated for an object?",
        "options": [
            "At declaration of object",
            "At compile time",
            "When object constructor is called",
            "When object is initialized to another object"
        ],
        "explanation": "Explanation: The object memory allocation takes place when the object constructor is called. Declaration of an object doesn\u2019t mean that memory is allocated for its members. If object is initialized with another object, it may just get a reference to the previously created object.",
        "index": 407,
        "difficulty": 0.3275223984929898,
        "correct": 3
    },
    {
        "question": "Using new is type safe as _______________________",
        "options": [
            "It require to be specified with type of data",
            "It doesn\u2019t require to be specified with type of data",
            "It requires the name of data",
            "It allocated memory for the data"
        ],
        "explanation": "Explanation: The new is type safe because we don\u2019t have to specify the type of data that have to be allocated with memory. We can directly use it with data name. Name of the data doesn\u2019t matter though for type of memory allocation though.",
        "index": 408,
        "difficulty": 0.3349549828895917,
        "correct": 2
    },
    {
        "question": "Which of the following function can be used for dynamic memory allocation of objects?",
        "options": [
            "malloc()",
            "calloc()",
            "create()",
            "both malloc() and calloc()"
        ],
        "explanation": "Explanation: The malloc() function can be used to allocate dynamic memory for objects. Function calloc() can also be use. These functions differ in the way they allocate memory for objects.",
        "index": 409,
        "difficulty": 0.3492572640078251,
        "correct": 4
    },
    {
        "question": "Which among the following best describes member function overriding?",
        "options": [
            "Member functions having same name in base and derived classes",
            "Member functions having same name in base class only",
            "Member functions having same name in derived class only",
            "Member functions having same name and different signature inside main function"
        ],
        "explanation": "Explanation: The member function which is defined in base class and again in the derived class, is overridden by the definition given in the derived class. This is because the preference is given more to the local members. When derived class object calls that function, definition from the derived class is used.",
        "index": 410,
        "difficulty": 0.35033218543008804,
        "correct": 1
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "Inheritance must not be using when overriding is used",
            "Overriding can be implemented without using inheritance",
            "Inheritance must be done, to use overriding are overridden",
            "Inheritance is mandatory only if more than one functions"
        ],
        "explanation": "Explanation: The inheritance must be used in order to use function overriding. If inheritance is not used, the functions can only be overloaded. There must be a base class and a derived class to override the function of base class.",
        "index": 411,
        "difficulty": 0.35664233185860583,
        "correct": 3
    },
    {
        "question": "Which is the correct condition for function overriding?",
        "options": [
            "The declaration must not be same in base and derived class",
            "The declaration must be exactly the same in base and derived class",
            "The declaration should have at least 1 same argument in declaration of base and derived class",
            "The declaration should have at least 1 different argument in declaration of base and derived class"
        ],
        "explanation": "Explanation: For a function to be over ridden, the declaration must be exactly the same. There must not be any different syntax used. This will ensure that the function to be overridden is only the one intended from to be overridden from the derived class.",
        "index": 412,
        "difficulty": 0.357032155687127,
        "correct": 2
    },
    {
        "question": "Exactly same declaration in base and derived class includes______________",
        "options": [
            "Only same name",
            "Only same return type and name",
            "Only same return type and argument list",
            "All the same return type, name and parameter list"
        ],
        "explanation": "Explanation: Declaration includes the whole prototype of the function. The return type name and the parameter list must be same in order to confirm that the function is same in derived and the base class. And hence can be overridden.",
        "index": 413,
        "difficulty": 0.3577610149858583,
        "correct": 4
    },
    {
        "question": "What are the constant member functions?",
        "options": [
            "Functions which doesn\u2019t change value of calling object",
            "Functions which doesn\u2019t change value of any object inside definition",
            "Functions which doesn\u2019t allow modification of any object of class",
            "Functions which doesn\u2019t allow modification of argument objects"
        ],
        "explanation": "Explanation: The constant member functions are a special type of member functions. These are intended to restrict any modification in to the values of object which is used to invoke that function. This is done to ensure that there are no accidental modifications to the object.",
        "index": 414,
        "difficulty": 0.36116134925180265,
        "correct": 1
    },
    {
        "question": "Which keyword must be used to declare a member function as a constant member function?",
        "options": [
            "Constant",
            "Const",
            "FunctionConst",
            "Unchanged"
        ],
        "explanation": "Explanation: The keyword const is provided in most of the programming languages. This indicates that the member on which it is specified remains constant with the respective values of members. The keyword must be mentioned so as to declare a member function to be constant.",
        "index": 415,
        "difficulty": 0.3677950968166708,
        "correct": 2
    },
    {
        "question": "Which objects can call the const functions?",
        "options": [
            "Only const objects",
            "Only non-const objects",
            "Both const and non-const objects",
            "Neither const not non-const objects"
        ],
        "explanation": "Explanation: All the objects of a class can call const functions for its use. Const objects can call the const functions to since those values are already constant. And the non- const objects can call the const functions to keep their values constant.",
        "index": 416,
        "difficulty": 0.37085001496498027,
        "correct": 3
    },
    {
        "question": "Non-const functions _______________________",
        "options": [
            "Can be called only from non-const object",
            "Can be called only from const object",
            "Can be called both by const and non-const object",
            "Can\u2019t be called with object"
        ],
        "explanation": "Explanation: The non-const functions are able to modify the values of object which called the function. So only the non-const functions can be called. If const object is used then the compiler produces an error as the const object is being given to a function which can modify its values.",
        "index": 417,
        "difficulty": 0.37841950341008657,
        "correct": 1
    },
    {
        "question": "Which is the correct condition on const member functions?",
        "options": [
            "Const member functions can\u2019t call non-const member functions",
            "Const member functions can\u2019t call any other function",
            "Const member functions can call only the functions which are neither const nor non-const",
            "Const member functions can call only data members of call not member functions"
        ],
        "explanation": "Explanation: The const member functions are restricted to call any other non-const member functions. This is to ensure that the const function doesn\u2019t have any code that might modify the calling object.",
        "index": 418,
        "difficulty": 0.3824067259720332,
        "correct": 1
    },
    {
        "question": "If a const object calls a non-const member function then ____________________",
        "options": [
            "Run time error may get produced",
            "Compile time error may get produced",
            "Either compile time or run time error is produced",
            "The program can\u2019t be compiled"
        ],
        "explanation": "Explanation: The program gets compiled but produces an error. The error is produced because a constant value is being changed. Even if there is no code that can change any object value, but non-const member functions are assumed to change the values.",
        "index": 419,
        "difficulty": 0.38428511338345217,
        "correct": 2
    },
    {
        "question": "Can a constructor function be constant?",
        "options": [
            "Yes, always",
            "Yes, only if permissions are given",
            "No, because objects are not involved",
            "No, never"
        ],
        "explanation": "Explanation: The constructors can\u2019t be made const. This is to ensure that the constructor is capable of initializing the values to the members of the object. If it is made constant then it won\u2019t be able to initialize any data member values.",
        "index": 420,
        "difficulty": 0.3909479732971368,
        "correct": 4
    },
    {
        "question": "A function can have both the const and non-const version in the same program.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The functions in a program can be made both const and non-const. This feature is made available to make programming more flexible. This ensures the security too as we can call const function whenever required.",
        "index": 421,
        "difficulty": 0.3920243927288274,
        "correct": 1
    },
    {
        "question": "How is it possible to have both const and non-const version of a function?",
        "options": [
            "Function overriding",
            "Function prototyping",
            "Function overloading",
            "Function declaring"
        ],
        "explanation": "Explanation: The functions can be declared const and non-const in the same program. The technique used is function overloading. We can define a const function and then a non-const version of same function using overloading.",
        "index": 422,
        "difficulty": 0.3940461398317643,
        "correct": 3
    },
    {
        "question": "When both the const and non-const version of functions are required?",
        "options": [
            "Return value have to be different in const",
            "Return value have to be same in const",
            "Return values have to be ignored",
            "Return values have to be suppressed"
        ],
        "explanation": "Explanation: The return values can help to overload the functions. Also, this will allow us to use a non-const function to be called inside both the const and non-const version of functions.",
        "index": 423,
        "difficulty": 0.39726294850054034,
        "correct": 1
    },
    {
        "question": "If a function is to be made const, which is the correct syntax?",
        "options": [
            "const functionName(parameters);",
            "const returnType functionName(parameters);",
            "const functionName(returnType)(Parameters);",
            "const (functionName(parameters));"
        ],
        "explanation": "Explanation: The function declaration must contain the keyword const. The const keyword makes the function const type. The usual function declaration can be given followed by the keyword. The keyword const can be given after the declaration of function and before definition.",
        "index": 424,
        "difficulty": 0.4066519380138196,
        "correct": 2
    },
    {
        "question": "Functions which differ in const-ness are considered ______________________",
        "options": [
            "To have same signature",
            "To have different signature",
            "To produce compile time error",
            "To produce runtime error"
        ],
        "explanation": "Explanation: The functions are considered to have different signature. This is because the const-ness also defines the type of function or the working of functions. And hence the functions can be considered different. This is the reason that we can use function overloading for const and non-const version of same function.",
        "index": 425,
        "difficulty": 0.41522883599474447,
        "correct": 2
    },
    {
        "question": "If const version of a function when overloading is used, the function ___________________",
        "options": [
            "Returns reference to object",
            "Returns volatile reference",
            "Returns mutable reference",
            "Returns const reference"
        ],
        "explanation": "Explanation: The function returns a const reference. This is to ensure that the value of object calling the function is not modified. This is a security feature.",
        "index": 426,
        "difficulty": 0.416245457756923,
        "correct": 4
    },
    {
        "question": "Which among the following is recommended for const functions?",
        "options": [
            "Const function use should be reduced in a program",
            "Const function use should be more in a program",
            "Const function use should not matter in a program",
            "Const function use should be able to modify the values"
        ],
        "explanation": "Explanation: The const member functions should be used more in a program. The reason behind is to ensure there is no accidental modification of data of object. Also to ensure any unintended modification which may result in unexpected termination of program.",
        "index": 427,
        "difficulty": 0.41795892576972227,
        "correct": 2
    },
    {
        "question": "Use of const member function in a program _________________________",
        "options": [
            "Is mandatory, always",
            "Is optional, always",
            "Is mandatory, if objects are used",
            "Is optional, if const objects are used"
        ],
        "explanation": "Explanation: The use of const member functions is not mandatory. If const objects are involved then there is a high use of const member functions too. But there is no mandatory condition.",
        "index": 428,
        "difficulty": 0.41863189196296435,
        "correct": 2
    },
    {
        "question": "Which is private member functions access scope?",
        "options": [
            "Member functions which can only be used within the class",
            "Member functions which can used outside the class",
            "Member functions which are accessible in derived class",
            "Member functions which can\u2019t be accessed inside the class"
        ],
        "explanation": "Explanation: The member functions can be accessed inside the class only if they are private. The access is scope is limited to ensure the security of the private members and their usage.",
        "index": 429,
        "difficulty": 0.42020924086418177,
        "correct": 1
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "The private members can\u2019t be accessed by public members of the class",
            "The private members can be accessed by public members of the class",
            "The private members can be accessed only by the private members of the class",
            "The private members can\u2019t be accessed by the protected members of the class"
        ],
        "explanation": "Explanation: The private members are accessible within the class. There is no restriction on use of private members by public or protected members. All the members can access the private member functions of the class.",
        "index": 430,
        "difficulty": 0.4202314412514436,
        "correct": 2
    },
    {
        "question": "Which member can never be accessed by inherited classes?",
        "options": [
            "Private member function",
            "Public member function",
            "Protected member function",
            "All can be accessed"
        ],
        "explanation": "Explanation: The private member functions can never be accessed in the derived classes. The access specifiers is of maximum security that allows only the members of self class to access the private member functions.",
        "index": 431,
        "difficulty": 0.42651440048706935,
        "correct": 1
    },
    {
        "question": "Which syntax among the following shows that a member is private in a class?",
        "options": [
            "private: functionName(parameters)",
            "private(functionName(parameters))",
            "private functionName(parameters)",
            "private::functionName(parameters)"
        ],
        "explanation": "Explanation: The function declaration must contain private keyword follower by the return type and function name. Private keyword is followed by normal function declaration.",
        "index": 432,
        "difficulty": 0.43978898015456735,
        "correct": 3
    },
    {
        "question": "If private member functions are to be declared in C++ then _____________",
        "options": [
            "private: <all private members>",
            "private <member name>",
            "private(private member list)",
            "private :- <private members>"
        ],
        "explanation": "Explanation: The private members doesn\u2019t have to have the keyword with each private member. We only have to specify the keyword private followed by single colon and then private member\u2019s are listed.",
        "index": 433,
        "difficulty": 0.44447180421940535,
        "correct": 1
    },
    {
        "question": "In java, which rule must be followed?",
        "options": [
            "Keyword private preceding list of private member\u2019s",
            "Keyword private with a colon before list of private member\u2019s",
            "Keyword private with arrow before each private member",
            "Keyword private preceding each private member"
        ],
        "explanation": "Explanation: The private keyword must be mentioned before each private member. Unlike the rule in C++ to specify private once and list all other private member\u2019s, in java all member declarations must be preceded by the keyword private.",
        "index": 434,
        "difficulty": 0.4449508294450748,
        "correct": 4
    },
    {
        "question": "How many private member functions are allowed in a class?",
        "options": [
            "Only 1",
            "Only 7",
            "Only 255",
            "As many as required"
        ],
        "explanation": "Explanation: There are no conditions applied on the number of private member functions that can be declared in a class. Though the system may restrict use of too many functions depending on memory.",
        "index": 435,
        "difficulty": 0.4450081360861171,
        "correct": 4
    },
    {
        "question": "How to access a private member function of a class?",
        "options": [
            "Using object of class",
            "Using object pointer",
            "Using address of member function",
            "Using class address"
        ],
        "explanation": "Explanation: Even the private member functions can be called outside the class. This is possible if address of the function is known. We can use the address to call the function outside the class.",
        "index": 436,
        "difficulty": 0.4541227805233503,
        "correct": 3
    },
    {
        "question": "Private member functions ____________",
        "options": [
            "Can\u2019t be called from enclosing class",
            "Can be accessed from enclosing class",
            "Can be accessed only if nested class is private",
            "Can be accessed only if nested class is public"
        ],
        "explanation": "Explanation: The nested class members can\u2019t be accessed in the enclosed class even though other members can be accessed. This is to ensure the class members security and not to go against the rules of private members.",
        "index": 437,
        "difficulty": 0.4657034617157767,
        "correct": 1
    },
    {
        "question": "Which function among the following can\u2019t be accessed outside the class in java in same package?",
        "options": [
            "public void show()",
            "void show()",
            "protected show()",
            "static void show()"
        ],
        "explanation": "Explanation: The protected members are available within the class. And are also available in derived classes. But these members are treated as private members for outside the class and inheritance structure. Hence can\u2019t be accessed.",
        "index": 438,
        "difficulty": 0.4761276319459449,
        "correct": 3
    },
    {
        "question": "If private members are to be called outside the class, which is a good alternative?",
        "options": [
            "Call a public member function which calls private function",
            "Call a private member function which calls private function",
            "Call a protected member function which calls private function",
            "Not possible"
        ],
        "explanation": "Explanation: The private member functions can be accessed within the class. A public member function can be called which in turn calls the private member function. This maintains the security and adheres to the rules of private members.",
        "index": 439,
        "difficulty": 0.47738725716197017,
        "correct": 1
    },
    {
        "question": "A private function of a derived class can be accessed by the parent class.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: If private functions get accessed even by the parent class that will violate the rules of private members. If the functions can be accessed then the derived class security is hindered.",
        "index": 440,
        "difficulty": 0.48958942725064336,
        "correct": 2
    },
    {
        "question": "Which error will be produced if private members are accessed?",
        "options": [
            "Can\u2019t access private message",
            "Code unreachable",
            "Core dumped",
            "Bad code"
        ],
        "explanation": "Explanation: The private members access from outside the class produce an error. The error states that the code at some line can\u2019t access the private members. And denies the access terminating the program.",
        "index": 441,
        "difficulty": 0.520825465745232,
        "correct": 1
    },
    {
        "question": "Can main() function be made private?",
        "options": [
            "Yes, always",
            "Yes, if program doesn\u2019t contain any classes",
            "No, because main function is user defined",
            "No, never"
        ],
        "explanation": "Explanation: The reason given in option \u201cNo, because main function is user defined\u201d is wrong. The proper reason that the main function should not be private is that it should be accessible in whole program. This makes the program flexible.",
        "index": 442,
        "difficulty": 0.5464728507272154,
        "correct": 4
    },
    {
        "question": "If a function in java is declared private then it __________________",
        "options": [
            "Can\u2019t access the standard output",
            "Can access the standard output",
            "Can\u2019t access any output stream",
            "Can access only the output streams"
        ],
        "explanation": "Explanation: The private members can access any standard input or output. There is no restriction on access to any input or output stream. And since standard input can also be used hence only accessing the output stream is not true.",
        "index": 443,
        "difficulty": 0.5784497258244361,
        "correct": 2
    },
    {
        "question": "What are public member functions?",
        "options": [
            "Functions accessible outside the class but not in derived class",
            "Functions accessible outside the class directly",
            "Functions accessible everywhere using object of class",
            "Functions that can\u2019t be accessed outside the class"
        ],
        "explanation": "Explanation: The most suitable definition would be that public member functions are accessible everywhere using object of the class. If derived classes are using those, derived class object can be used to call those functions.",
        "index": 444,
        "difficulty": 0.5807459312022205,
        "correct": 3
    },
    {
        "question": "Which among the following is true for public member functions?",
        "options": [
            "Public member functions doesn\u2019t have a return type",
            "Public member functions doesn\u2019t have any security",
            "Public member functions are declared outside the class",
            "Public member functions can be called using object of class"
        ],
        "explanation": "Explanation: The public member functions can be called using object of the class. The members can\u2019t be declared outside the class as those would become non-member functions of the class. The functions have security as those can be accessed using the class object only.",
        "index": 445,
        "difficulty": 0.5880928421794183,
        "correct": 4
    },
    {
        "question": "Which type of member functions get inherited in the same specifier in which the inheritance is done? (If private inheritance is used, those become private and if public used, those become public)",
        "options": [
            "Private member functions",
            "Protected member functions",
            "Public member functions",
            "All member functions"
        ],
        "explanation": "Explanation: The public member functions gets into the same specifier in which the inheritance is done. If protected members are involved in public inheritance, still those remain protected in the derived class but public members become public on public inheritance and protected in protected inheritance.",
        "index": 446,
        "difficulty": 0.6029004425813467,
        "correct": 3
    },
    {
        "question": "Which syntax among the following is correct for public member functions?",
        "options": [
            "public::void functionName(parameters)",
            "public void functionName(parameters)",
            "public(void functionName(parameters))",
            "public:-void functionName(Parameters)"
        ],
        "explanation": "Explanation: The public member functions declaration must be mentioned with the keyword public. The syntax given is used in java. Keyword public is followed by the usual function declaration.",
        "index": 447,
        "difficulty": 0.6532771809089599,
        "correct": 2
    },
    {
        "question": "Which syntax is applicable to declare public member functions in C++?",
        "options": [
            "public: <function declaration>",
            "public(<function declaration>)",
            "public void <function declaration>",
            "public::<function declaration>"
        ],
        "explanation": "Explanation: The syntax in C++ must contain the public keyword followed by a colon. Thereafter, all the public members can be declared. But in few other language, public have to be mentioned explicitly with each member.",
        "index": 448,
        "difficulty": 0.6616046151405315,
        "correct": 1
    },
    {
        "question": "In java, which rule among the following is applicable?",
        "options": [
            "Keyword public can\u2019t be preceded with all the public members",
            "Keyword public must be preceded with all the public members",
            "Keyword public must be post mentioned the function declaration",
            "Keyword public is not mandatory"
        ],
        "explanation": "Explanation: The public members in java must be preceded with the keyword public. It must be mentioned with each public member, unlike C++ where we mention it only once. In java, each member must have explicit declaration of specifier type.",
        "index": 449,
        "difficulty": 0.6634606055268444,
        "correct": 2
    },
    {
        "question": "How many public members are allowed in a class?",
        "options": [
            "Only 1",
            "At most 7",
            "Exactly 3",
            "As many as required"
        ],
        "explanation": "Explanation: The number of public members that can be defined in a class doesn\u2019t have any limit. Though the programmer should not use too many functions, instead should use another class for more specific functions to reduce the readability complexity.",
        "index": 450,
        "difficulty": 0.6725686435652731,
        "correct": 4
    },
    {
        "question": "Which is not a proper way to access public members of a class?",
        "options": [
            "Using object pointer with arrow operator",
            "Using object of class in main function",
            "Using object of class with arrow operator",
            "Using object anywhere in the program"
        ],
        "explanation": "Explanation: The public members can be accessed anywhere in the program using the object of the class. And if object pointer is used, then arrow operator is used to access class members. If normal object is used with arrow operator, an error will be generated.",
        "index": 451,
        "difficulty": 0.6755664315376579,
        "correct": 3
    },
    {
        "question": "Which call is correct for public members of a nested class?",
        "options": [
            "Can be called from object of enclosing class",
            "Can be called within enclosing class only with direct names",
            "Direct names should be used for the nested classes",
            "Only with help of nested class object pointer"
        ],
        "explanation": "Explanation: The closest definition is that any public member function of the nested class can be accessed with the help of enclosing class object. The nested class object pointer can be used only within the enclosing class. It\u2019s not mandatory to use the members of nested class only within the enclosing class.",
        "index": 452,
        "difficulty": 0.6805722494852016,
        "correct": 1
    },
    {
        "question": "Which public function call among the following is correct outside the class, if return type is void (C++)?",
        "options": [
            "object.void functionName(parameters);",
            "object.functionName(parameters);",
            "object.functionName void (parameters)",
            "object.void functionName();"
        ],
        "explanation": "Explanation: The condition given says that there is no return type hence we can call the function directly. The object name should be mentioned with a dot operator to access its class members. Then the function name with parameters, if required, can be given.",
        "index": 453,
        "difficulty": 0.6810129248026144,
        "correct": 2
    },
    {
        "question": "If public members are to be restricted from getting inherited from the subclass of the class containing that function, which alternative is best?",
        "options": [
            "Make the function private",
            "Use private inheritance",
            "Use public inheritance",
            "Use protected inheritance"
        ],
        "explanation": "Explanation: If private inheritance is used then the class containing the function will be able to use the function with rules of whichever specifier is used. Then the derived class makes those function the private members of itself. This restricts the public members of parent class from further inheritance.",
        "index": 454,
        "difficulty": 0.6817068848594117,
        "correct": 2
    },
    {
        "question": "A derived class object can access the public members of the base class.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The public members of the base class can be accessed from the derived class object only if public inheritance is used. If protected or private inheritance is used then those members become public/protected in derived class and hence won\u2019t be able to be called from object of the derived class.",
        "index": 455,
        "difficulty": 0.6881080532186052,
        "correct": 2
    },
    {
        "question": "If a class have a public member function and is called directly in the main function then ___________________________",
        "options": [
            "Undeclared function error will be produced",
            "Out of memory error is given",
            "Program gives warning only",
            "Program shut down the computer"
        ],
        "explanation": "Explanation: If the function is called directly without using any object then the compiler doesn\u2019t gets to know that the function have to be called from a specific class. And if there are no global or in-scope function with same name then the compiler produces an error stating that the called function is undeclared.",
        "index": 456,
        "difficulty": 0.699992478856319,
        "correct": 1
    },
    {
        "question": "The function main() must always be public.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The main() function must always be public. This is because the whole function and the operating system that is out of the package have to access the main function throughout the program execution. Hence the main() function should be public so as to be available everywhere in the program.",
        "index": 457,
        "difficulty": 0.7016221639559763,
        "correct": 1
    },
    {
        "question": "All the public member functions ___________________",
        "options": [
            "Can\u2019t access the private members of a class",
            "Can\u2019t access the protected members of a class",
            "Can access only public members of a class",
            "Can access all the member of its class"
        ],
        "explanation": "Explanation: The public member function can access any private, protected and public member of its class. Not only public member function, any member function of a class can access each and every other member declared inside the class. Hence are flexible to program.",
        "index": 458,
        "difficulty": 0.7044765490323988,
        "correct": 4
    },
    {
        "question": "What is an exception?",
        "options": [
            "Problem arising during compile time",
            "Problem arising during runtime",
            "Problem in syntax",
            "Problem in IDE"
        ],
        "explanation": "Explanation: The problems that might occur during execution of a program are known as exceptions. The exceptions are unexpected sometimes and can be predicted. Also, the exceptions should be always considered for a better program.",
        "index": 459,
        "difficulty": 0.7074965223307084,
        "correct": 2
    },
    {
        "question": "Why do we need to handle exceptions?",
        "options": [
            "To prevent abnormal termination of program",
            "To encourage exception prone program",
            "To avoid syntax errors",
            "To save memory"
        ],
        "explanation": "Explanation: The exceptions should be handled to prevent any abnormal termination of a program. The program should keep running even if it gets interrupted in between. The program should preferable show the error occurred and then retry the process or just continue the program further.",
        "index": 460,
        "difficulty": 0.7147336747695134,
        "correct": 1
    },
    {
        "question": "An exception may arise when _______________",
        "options": [
            "Input is fixed",
            "Input is some constant value of program",
            "Input given is invalid",
            "Input is valid"
        ],
        "explanation": "Explanation: The exceptions may arise because the input given by the user might not be of the same type that a program can manage. If the input is invalid the program gets terminated.",
        "index": 461,
        "difficulty": 0.7248968092658261,
        "correct": 3
    },
    {
        "question": "If a file that needs to be opened is not found in the target location then _____________",
        "options": [
            "Exception will be produced",
            "Exceptions are not produced",
            "Exception might get produced because of syntax",
            "Exceptions are not produced because of logic"
        ],
        "explanation": "Explanation: The exceptions are produced when anything unexpected happened. The program might not be able to find a file in the target location and hence program produces an exceptions. The exception produced, then terminates the program.",
        "index": 462,
        "difficulty": 0.7332038405899031,
        "correct": 1
    },
    {
        "question": "Which is the universal exception handler class?",
        "options": [
            "Object",
            "Math",
            "Errors",
            "Exceptions"
        ],
        "explanation": "Explanation: Any type of exception can be handled by using class Exceptions. An object of this class is created which can manipulate the exception data. The data can be used to display the error or to run the program further based on error produced.",
        "index": 463,
        "difficulty": 0.7387809305282209,
        "correct": 4
    },
    {
        "question": "What are two exception classes in hierarchy of java exceptions class?",
        "options": [
            "Runtime exceptions only",
            "Compile time exceptions only",
            "Runtime exceptions and other exceptions",
            "Other exceptions"
        ],
        "explanation": "Explanation: The exceptions class is having two other derived classes which are of runtime exception handler and for other type of exceptions handling. The runtime exception handler is used to handle the exceptions produced during run time and same with case of other exceptions.",
        "index": 464,
        "difficulty": 0.7416448052214077,
        "correct": 3
    },
    {
        "question": "Which are the two blocks that are used to check error and handle the error?",
        "options": [
            "Try and catch",
            "Trying and catching",
            "Do and while",
            "TryDo and Check"
        ],
        "explanation": "Explanation: Two blocks that are used to check for errors and to handle the errors are try and catch block. The code which might produce some exceptions is placed inside the try block and then the catch block is written to catch the error that is produced. The error message or any other processing can be done in catch block if the error is produced.",
        "index": 465,
        "difficulty": 0.7484775172461222,
        "correct": 1
    },
    {
        "question": "There can be a try block without catch block but vice versa is not possible.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The try block may or may not have any catch block. But a catch block can\u2019t be there in a program if there is no try block. It is like else-block can only be written if and only if if-block is present in the program.",
        "index": 466,
        "difficulty": 0.7486493677581967,
        "correct": 1
    },
    {
        "question": "How many catch blocks can a single try block can have?",
        "options": [
            "Only 1",
            "Only 2",
            "Maximum 127",
            "As many as required"
        ],
        "explanation": "Explanation: There is no limit on the number of catch blocks corresponding to a try block. This is because the error can be of any type and for each type, a new catch block can be defined. This is to make sure all type of exceptions can be handled.",
        "index": 467,
        "difficulty": 0.7604124931773089,
        "correct": 4
    },
    {
        "question": "Which among the following is not a method of Throwable class?",
        "options": [
            "public String getMessage()",
            "public Throwable getCause()",
            "public Char toString()",
            "public void printStackTrace()"
        ],
        "explanation": "Explanation: Actually all the functions are available in throwable class. But the return type given in the option is wrong. The function toString returns string value. Hence the return type must be a String and not a char.",
        "index": 468,
        "difficulty": 0.7799003432456102,
        "correct": 3
    },
    {
        "question": "To catch the exceptions ___________________",
        "options": [
            "An object must be created to catch the exception",
            "A variable should be created to catch the exception",
            "An array should be created to catch all the exceptions",
            "A string have to be created to store the exception"
        ],
        "explanation": "Explanation: The object must be created of a specific class of which the error has occurred. If the type of error is unknown then we can use an object of class Exceptions. This object will be able to handle any kind of exception that a program might produce.",
        "index": 469,
        "difficulty": 0.8031896764278037,
        "correct": 1
    },
    {
        "question": "Multiple catch blocks __________________",
        "options": [
            "Are mandatory for each try block",
            "Can be combined into a single catch block",
            "Are not possible for a try block",
            "Can never be associated with a single try block"
        ],
        "explanation": "Explanation: The separate catch blocks for a single try block can be combined into a single catch block. All type of errors can be then handled in s single block. The type still have to be specified for the errors that might be produced.",
        "index": 470,
        "difficulty": 0.8063459269688811,
        "correct": 2
    },
    {
        "question": "Which symbol should be used to separate the type of exception handler classes in a single catch block?",
        "options": [
            "?",
            ",",
            "\u2013",
            "|"
        ],
        "explanation": "Explanation: A pipe symbol can be used to separate different type of exceptions. The exceptions should always be given in proper sequence to ensure that no code remains unreachable. If not done properly the code might never be used in a program.",
        "index": 471,
        "difficulty": 0.8076246140584269,
        "correct": 4
    },
    {
        "question": "Which class is used to handle the input and output exceptions?",
        "options": [
            "InputOutput",
            "InputOutputExceptions",
            "IOExceptions",
            "ExceptionsIO"
        ],
        "explanation": "Explanation: There is a specific class to handle each type of exceptions that might be produced in a program. The input and output exceptions can be handled by an object of class IOExcceptions. This class handles all type of input and output exceptions.",
        "index": 472,
        "difficulty": 0.8080514917058181,
        "correct": 3
    },
    {
        "question": "Why do we use finally block?",
        "options": [
            "To execute the block if exception occurred",
            "To execute a code when exception is not occurred",
            "To execute a code whenever required",
            "To execute a code with each and every run of program"
        ],
        "explanation": "Explanation: Sometimes there is a need to execute a set of code every time the program runs. Even if the exception occurs and even if it doesn\u2019t, there can be some code that must be executed at end of the program. That code is written in finally block. This block is always executed regardless of exceptions occurring.",
        "index": 473,
        "difficulty": 0.8105592954775336,
        "correct": 4
    },
    {
        "question": "Which among the following is true for class exceptions?",
        "options": [
            "Only base class can give rise to exceptions",
            "Only derived class can give rise to exceptions",
            "Either base class or derived class may produce exceptions",
            "Both base class and derived class may produce exceptions"
        ],
        "explanation": "Explanation: It\u2019s not mandatory that either base class or derived class can give rise to exceptions. The exceptions might get produced from any class. The exceptions depends on code.",
        "index": 474,
        "difficulty": 0.818595870188445,
        "correct": 4
    },
    {
        "question": "If both base and derived class caught exceptions ______________",
        "options": [
            "Then catch block of derived class must be defined before base class",
            "Then catch block of base class must be defined before the derived class",
            "Then catch block of base and derived classes doesn\u2019t matter",
            "Then catch block of base and derived classes are not mandatory to be defined"
        ],
        "explanation": "Explanation: It is a condition for writing the catch blocks for base and derived classes. It is mandatory to write derived class catch block first because the errors produced by the derived class must be handled first.",
        "index": 475,
        "difficulty": 0.8244241920307691,
        "correct": 1
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "If catch block of base class is written first, it is compile time error",
            "If catch block of base class is written first, it is run time error",
            "If catch block of base class is written first, derived class catch block can\u2019t be reached",
            "If catch block of base class is written first, only derived class catch block is executed"
        ],
        "explanation": "Explanation: If the catch block of the base class is defined first and then the derived class catch block is given. The code becomes unreachable. Hence the derived class catch block must be written first.",
        "index": 476,
        "difficulty": 0.8249713196741233,
        "correct": 3
    },
    {
        "question": "The catching of base class exception ___________________________ in java.",
        "options": [
            "After derived class is not allowed by compiler",
            "Before derived class is not allowed by compiler",
            "Before derived class is allowed",
            "After derived class can\u2019t be done"
        ],
        "explanation": "Explanation: The catching of base class exception before derived class is not allowed in java. The compiler itself doesn\u2019t allow this declaration. It produces an error.",
        "index": 477,
        "difficulty": 0.827707052281994,
        "correct": 2
    },
    {
        "question": "If catching of base class exception is done before derived class in C++ ________________",
        "options": [
            "It gives compile time error",
            "It doesn\u2019t run the program",
            "It may give warning but not error",
            "It always gives compile time error"
        ],
        "explanation": "Explanation: The compiler in C++ doesn\u2019t identify this as compile time error and allows the execution of the program. But, the compiler may give some warning related to the catch block sequence or code unreachable.",
        "index": 478,
        "difficulty": 0.8407573048394905,
        "correct": 3
    },
    {
        "question": "How many catch blocks can a class have?",
        "options": [
            "Only 1",
            "2",
            "3",
            "As many as required"
        ],
        "explanation": "Explanation: There are many type of exceptions that may arise while running a code. And each catch block can handle only one exception. Hence there can be as many catch blocks as required.",
        "index": 479,
        "difficulty": 0.8587892063385314,
        "correct": 4
    },
    {
        "question": "Since which version of java is multiple exception catch was made possible?",
        "options": [
            "Java 4",
            "Java 5",
            "Java 6",
            "Java 7"
        ],
        "explanation": "Explanation: None of the languages used to support multiple exception catch in a single catch block. Since java 7 the feature was added to catch more than one exceptions in one catch block.",
        "index": 480,
        "difficulty": 0.876687481928851,
        "correct": 4
    },
    {
        "question": "To catch more than one exception in one catch block, how are the exceptions separated in the syntax?",
        "options": [
            "Vertical bar",
            "Hyphen",
            "Plus",
            "Modulus"
        ],
        "explanation": "Explanation: Just the way we separate the arguments in a function definition using comma. Here we separate the exceptions by using a vertical bar or we call it pipe symbol sometimes. This is just a convention followed to separate different exception list.",
        "index": 481,
        "difficulty": 0.8799372542278041,
        "correct": 1
    },
    {
        "question": "If a catch block accepts more than one exceptions then __________________",
        "options": [
            "The catch parameters are not final",
            "The catch parameters are final",
            "The catch parameters are not defined",
            "The catch parameters are not used"
        ],
        "explanation": "Explanation: The catch parameters are made final. This is to ensure that the parameters are not changed inside the catch block. Hence those retain their values.",
        "index": 482,
        "difficulty": 0.8836804240697695,
        "correct": 2
    },
    {
        "question": "Which among the following handles the undefined class in program?",
        "options": [
            "ClassNotFound",
            "NoClassException",
            "ClassFoundException",
            "ClassNotFoundException"
        ],
        "explanation": "Explanation: It is the exception handler that handles the exceptions when the class used is not found in the program. This is done to handle all the undefined class exceptions. This can be due to a command line error.",
        "index": 483,
        "difficulty": 0.8950020508972067,
        "correct": 4
    },
    {
        "question": "If classes produce some exceptions, then ______________________",
        "options": [
            "Their respective catch block must be defined",
            "Their respective catch blocks are not mandatory",
            "Their catch blocks should be defined inside main function",
            "Their catch blocks must be defined at the end of program"
        ],
        "explanation": "Explanation: The catch blocks must be defined. This is to ensure that all the exceptions related to the classes are handled by the program code and the program doesn\u2019t terminate unexpectedly.",
        "index": 484,
        "difficulty": 0.897355396355767,
        "correct": 1
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "Only the base class catch blocks are important",
            "Only the derived class catch blocks are important",
            "Both the base and derived class catch blocks are important",
            "If base and derived classes both produce exceptions, program doesn\u2019t run"
        ],
        "explanation": "Explanation: The purpose of exception handling is to handle the unexpected errors in the program. If base class might produce some error then its catch block must be given and if the derived class might produce some error then it must be given a specific catch block too.",
        "index": 485,
        "difficulty": 0.9096759480968992,
        "correct": 3
    },
    {
        "question": "Which is the necessary condition to define the base and derived class catch blocks?",
        "options": [
            "Base class catch should be defined first",
            "Derived class catch should be defined first",
            "Catch block for both the classes must not be defined",
            "Catch block must be defined inside main function"
        ],
        "explanation": "Explanation: The derived class catch blocks must be defined prior to the base class catch block. This is to ensure that all the catch boxes are reachable. If not done, the code might become unreachable which in turn makes the program prone to errors.",
        "index": 486,
        "difficulty": 0.9141215625072956,
        "correct": 2
    },
    {
        "question": "Only the base class catch box can handle more than one exception in single block.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: There is no specific condition that states that only base class catch box can handle more than one exception in single box. Even the derived class catch clocks can handle more than one exceptions.",
        "index": 487,
        "difficulty": 0.9172382526232683,
        "correct": 2
    },
    {
        "question": "Which condition among the following might result in memory exception?",
        "options": [
            "False if conditions",
            "Nested if conditions that are all false",
            "Infinite loops",
            "Loop that runs exactly 99 times"
        ],
        "explanation": "Explanation: The infinite loops doesn\u2019t stop running once started. There must be a way to stop the loop but that is always an improper termination. Infinite loops may keep on using more memory and hence would result in memory error.",
        "index": 488,
        "difficulty": 0.9288005201469804,
        "correct": 3
    },
    {
        "question": "Which among the following best defines static variables members?",
        "options": [
            "Data which is allocated for each object separately",
            "Data which is common to all the objects of a class",
            "Data which is common to all the classes",
            "Data which is common to a specific method"
        ],
        "explanation": "Explanation: The static data members are made common to all the object of a class. They doesn\u2019t change from object to object. Those are property of class rather than of any individual object.",
        "index": 489,
        "difficulty": 0.9316549865442498,
        "correct": 2
    },
    {
        "question": "Which keyword should be used to declare static variables?",
        "options": [
            "static",
            "stat",
            "common",
            "const"
        ],
        "explanation": "Explanation: The keyword used to declare static variables is static. This is must be used while declaring the static variables. The compiler can make variables static if and only if they are mentioned with static keyword.",
        "index": 490,
        "difficulty": 0.956503953485309,
        "correct": 1
    },
    {
        "question": "Any changes made to static data member from one member function _____________",
        "options": [
            "Is reflected to only the corresponding object",
            "Is reflected to all the variables in a program",
            "Is reflected to all the objects of that class",
            "Is constant to that function only"
        ],
        "explanation": "Explanation: The changes made from any function to static data member will be a common change for all the other objects also. If the change is made with respect to one object and change is printed from another object, the result will be same.",
        "index": 491,
        "difficulty": 0.9604289307575251,
        "correct": 3
    },
    {
        "question": "Which is the correct syntax for declaring static data member?",
        "options": [
            "static mamberName dataType;",
            "dataType static memberName;",
            "memberName static dataType;",
            "static dataType memberName;"
        ],
        "explanation": "Explanation: The syntax must firstly be mentioned with the keyword static. Then the data type of the member followed by the member name should be given. This is general form of declaring static data members.",
        "index": 492,
        "difficulty": 0.9772422699074816,
        "correct": 4
    },
    {
        "question": "The static data member ______________________",
        "options": [
            "Must be defined inside the class",
            "Must be defined outside the class",
            "Must be defined in main function",
            "Must be defined using constructor"
        ],
        "explanation": "Explanation: The static data members must be defined outside the class. Since these are common to all the objects and should be created only once, they must not be defined in the constructor.",
        "index": 493,
        "difficulty": 0.9773797755189437,
        "correct": 2
    },
    {
        "question": "The syntax for defining the static data members is __________",
        "options": [
            "dataType className :: memberName = value;",
            "dataType className : memberName = value;",
            "dataType className . memberName = value;",
            "dataType className -> memberName =value;"
        ],
        "explanation": "Explanation: The syntax doesn\u2019t contain the static keyword. Since it is already been declared as static inside the class. The data type and the corresponding class name must be there to allocate the variable to a class. The value is assigned using scope resolution operator for the member name.",
        "index": 494,
        "difficulty": 1.0043346683023753,
        "correct": 1
    },
    {
        "question": "If static data members have to be used inside a class, those member functions _______________",
        "options": [
            "Must not be static member functions",
            "Must not be member functions",
            "Must be static member functions",
            "Must not be member function of corresponding class"
        ],
        "explanation": "Explanation: Only the static member functions can access the static data members. The definition of static members is made common and hence the member function should be capable of manipulating the static data members.",
        "index": 495,
        "difficulty": 1.0115739573182987,
        "correct": 3
    },
    {
        "question": "The static data member __________________________",
        "options": [
            "Can be accessed directly",
            "Can be accessed with any public class name",
            "Can be accessed with dot operator",
            "Can be accessed using class name if not using static member function"
        ],
        "explanation": "Explanation: The static data members can be accessed using the class name also. If the member functions is not used or is not to be used then we can call the static data members directly by using its corresponding class name.",
        "index": 496,
        "difficulty": 1.0148941565911107,
        "correct": 4
    },
    {
        "question": "Which among the following is the correct syntax to access static data member without using member function?",
        "options": [
            "className -> staticDataMember;",
            "className :: staticDataMember;",
            "className : staticDataMember;",
            "className . staticDataMember;"
        ],
        "explanation": "Explanation: For accessing the static data members without using the static member functions, the class name can be used. The class name followed by scope resolution, indicating that static data members is member of this class, and then the data member name.",
        "index": 497,
        "difficulty": 1.0228896774904852,
        "correct": 2
    },
    {
        "question": "Which data members among the following are static by default?",
        "options": [
            "extern",
            "integer",
            "const",
            "void"
        ],
        "explanation": "Explanation: The const data members of any class are made static by default. This is an implicit meaning given by the compiler to the member. Since const values won\u2019t change from object to object, hence are made static instead.",
        "index": 498,
        "difficulty": 1.0236656051829058,
        "correct": 3
    },
    {
        "question": "Which among the following is correct definition for static member functions?",
        "options": [
            "Functions created to allocate constant values to each object",
            "Functions made to maintain single copy of member functions for all objects",
            "Functions created to define the static members",
            "Functions made to manipulate static programs"
        ],
        "explanation": "Explanation: The functions which are made common, with respect to definition and data usage, to all the objects. These functions are able to access the static data members of a class.",
        "index": 499,
        "difficulty": 1.0270074203734563,
        "correct": 2
    },
    {
        "question": "The static member functions __________________",
        "options": [
            "Have access to all the members of a class",
            "Have access to only constant members of a class",
            "Have access to only the static members of a class",
            "Have direct access to all other class members also"
        ],
        "explanation": "Explanation: The static member functions are common for all the objects. These functions can use only the static members of a class in which those are defined. This is because other members change with respect to each object created.",
        "index": 500,
        "difficulty": 1.0405852382908414,
        "correct": 3
    },
    {
        "question": "The static member functions ____________________",
        "options": [
            "Can be called using class name",
            "Can be called using program name",
            "Can be called directly",
            "Can\u2019t be called outside the function"
        ],
        "explanation": "Explanation: The static members can be accessed using class name also. This is because the static members remain common to all the objects. Hence objects are not required.",
        "index": 501,
        "difficulty": 1.0526454975174158,
        "correct": 1
    },
    {
        "question": "Which is correct syntax to access the static member functions with class name?",
        "options": [
            "className . functionName;",
            "className -> functionName;",
            "className : functionName;",
            "className :: functionName;"
        ],
        "explanation": "Explanation: The scope resolution operator must be used to access the static member functions with class name. This indicates that the function belongs to the corresponding class.",
        "index": 502,
        "difficulty": 1.0596721716451087,
        "correct": 4
    },
    {
        "question": "Which among the following is not applicable for the static member functions?",
        "options": [
            "Variable pointers",
            "void pointers",
            "this pointer",
            "Function pointers"
        ],
        "explanation": "Explanation: Since the static members are not property of objects, they doesn\u2019t have this pointer. Every time the same member is referred from all the objects, hence use of this pointer is of no use.",
        "index": 503,
        "difficulty": 1.0601528522857881,
        "correct": 3
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "Static member functions can\u2019t be virtual",
            "Static member functions can be virtual",
            "Static member functions can be declared virtual if it is pure virtual class",
            "Static member functions can be used as virtual in Java"
        ],
        "explanation": "Explanation: The static member functions can\u2019t be virtual. This is a restriction on static member functions, since the definition should not change or should not be overridden by any other function of derived class. The static members must remain same for all the objects.",
        "index": 504,
        "difficulty": 1.0670025093529496,
        "correct": 1
    },
    {
        "question": "The static members are ______________________",
        "options": [
            "Created with each new object",
            "Created twice in a program",
            "Created as many times a class is used",
            "Created and initialized only once"
        ],
        "explanation": "Explanation: The static members are created only once. Then those members are reused whenever called or invoked. Memory is allocated only once.",
        "index": 505,
        "difficulty": 1.0765037637476542,
        "correct": 4
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "Static member functions can be overloaded",
            "Static member functions can\u2019t be overloaded",
            "Static member functions can be overloaded using derived classes",
            "Static member functions are implicitly overloaded"
        ],
        "explanation": "Explanation: The static member functions can\u2019t be overloaded because the definition must be the same for all the instances of a class. If an overloaded function have many definitions, none of them can be made static.",
        "index": 506,
        "difficulty": 1.0826152074989697,
        "correct": 2
    },
    {
        "question": "The static member functions _______________",
        "options": [
            "Can\u2019t be declared const",
            "Can\u2019t be declared volatile",
            "Can\u2019t be declared const or volatile",
            "Can\u2019t be declared const, volatile or const volatile"
        ],
        "explanation": "Explanation: The static member functions can\u2019t be made const, since any object or class itself should be capable of making changes to the function. And the function must retain all changes common to all the objects.",
        "index": 507,
        "difficulty": 1.0912316588650262,
        "correct": 4
    },
    {
        "question": "Which keyword should be used to declare the static member functions?",
        "options": [
            "static",
            "stat",
            "const",
            "common"
        ],
        "explanation": "Explanation: The member functions which are to be made static, must be preceded with the keyword static. This indicates the compiler to make the functions common to all the objects. And a new copy is not created with each of the new object.",
        "index": 508,
        "difficulty": 1.1040623508994267,
        "correct": 1
    },
    {
        "question": "The keyword static is used _______________",
        "options": [
            "With declaration inside class and with definition outside the class",
            "With declaration inside class and not with definition outside the class",
            "With declaration and definition wherever done",
            "With each call to the member function"
        ],
        "explanation": "Explanation: The keyword is used only inside the class while declaring the static member. Outside the class, only definition with proper syntax is given. There is no need of specifying the keyword static again.",
        "index": 509,
        "difficulty": 1.1073412744076059,
        "correct": 2
    },
    {
        "question": "Which among the following can\u2019t be used to access the members in any way?",
        "options": [
            "Scope resolution",
            "Arrow operator",
            "Single colon",
            "Dot operator"
        ],
        "explanation": "Explanation: The single colon can\u2019t be used in any way in order to access the static members of a class. Other symbols can be used according to the code and need.",
        "index": 510,
        "difficulty": 1.1077023415273644,
        "correct": 3
    },
    {
        "question": "We can use the static member functions and static data member __________________",
        "options": [
            "Even if class object is not created",
            "Even if class is not defined",
            "Even if class doesn\u2019t contain any static member",
            "Even if class doesn\u2019t have complete definition"
        ],
        "explanation": "Explanation: The static members are property of class as a whole. There is no need of specific objects to call static members. Those can be called directly or with class name.",
        "index": 511,
        "difficulty": 1.109402103039681,
        "correct": 1
    },
    {
        "question": "The static data member _________________",
        "options": [
            "Can be mutable",
            "Can\u2019t be mutable",
            "Can\u2019t be integer",
            "Can\u2019t be characters"
        ],
        "explanation": "Explanation: The static data members can never be mutable. There copies are not made. Since those are common and created only once.",
        "index": 512,
        "difficulty": 1.1104897110104321,
        "correct": 2
    },
    {
        "question": "If static data member are made inline, ______________",
        "options": [
            "Those should be initialized outside the class",
            "Those can\u2019t be initialized with the class",
            "Those can be initialized within the class",
            "Those can\u2019t be used by class members"
        ],
        "explanation": "Explanation: Since the members are created once and are common for all the instances, those can be initialized inside the class. Those doesn\u2019t change with each object being created hence can be defined inside the class once for all.",
        "index": 513,
        "difficulty": 1.1126233931434468,
        "correct": 3
    },
    {
        "question": "Passing object to a function _______________",
        "options": [
            "Can be done only in one way",
            "Can be done in more than one ways",
            "Is not possible",
            "Is not possible in OOP"
        ],
        "explanation": "Explanation: The objects can be passed to the functions and this requires OOP concept because objects are main part of OOP. The objects can be passed in more than one way to a function. The passing depends on how the object have to be used.",
        "index": 514,
        "difficulty": 1.1219211332595629,
        "correct": 2
    },
    {
        "question": "The object ________________",
        "options": [
            "Can be passed by reference",
            "Can be passed by value",
            "Can be passed by reference or value",
            "Can be passed with reference"
        ],
        "explanation": "Explanation: The objects can be passed by reference if required to use the same object. The values can be passed so that the main object remains same and no changes are made to it if the function makes any changes to the values being passed.",
        "index": 515,
        "difficulty": 1.1264154786598652,
        "correct": 3
    },
    {
        "question": "Which symbol should be used to pass the object by reference in C++?",
        "options": [
            "&",
            "@",
            "$",
            "$ or &"
        ],
        "explanation": "Explanation: The object to be passed by reference to the function should be preceded by & symbol in the argument list syntax of the function. This indicates the compiler not to use new object. The same object which is being passed have to be used.",
        "index": 516,
        "difficulty": 1.1343755860310685,
        "correct": 1
    },
    {
        "question": "If object is passed by value ______________",
        "options": [
            "Copy constructor is used to copy the values into another object in the function",
            "Copy constructor is used to copy the values into temporary object",
            "Reference to the object is used to access the values of the object",
            "Reference to the object is used to created new object in its place"
        ],
        "explanation": "Explanation: The copy constructor is used. This constructor is used to copy the values into a new object which will contain all the values same as that of the object being passed but any changes made to the newly created object will not affect the original object.",
        "index": 517,
        "difficulty": 1.134484344342547,
        "correct": 1
    },
    {
        "question": "Pass by reference of an object to a function _______________",
        "options": [
            "Affects the object in called function only",
            "Affects the object in prototype only",
            "Affects the object in caller function",
            "Affects the object only if mentioned with & symbol with every call"
        ],
        "explanation": "Explanation: The original object in the caller function will get affected. The changes made in the called function will be same in the caller function object also.",
        "index": 518,
        "difficulty": 1.1356592022885215,
        "correct": 3
    },
    {
        "question": "Copy constructor definition requires __________________",
        "options": [
            "Object to be passed by value",
            "Object not to be passed to it",
            "Object to be passed by reference",
            "Object to be passed with each data member value"
        ],
        "explanation": "Explanation: The object must be passed by reference to a copy constructor. This is to avoid the out of memory error. The constructors keeps calling itself, if not passed by reference, and goes out of memory.",
        "index": 519,
        "difficulty": 1.1436533471605834,
        "correct": 3
    },
    {
        "question": "What is the type of object that should be specified in the argument list?",
        "options": [
            "Function name",
            "Object name itself",
            "Caller function name",
            "Class name of object"
        ],
        "explanation": "Explanation: The type of object is the class itself. The class name have to be specified in order to pass the objects to a function. This allows the program to create another object of same class or to use the same object that was passed.",
        "index": 520,
        "difficulty": 1.1463452771749507,
        "correct": 4
    },
    {
        "question": "If an object is passed by value, _________________",
        "options": [
            "Temporary object is used in the function",
            "Local object in the function is used",
            "Only the data member values are used",
            "The values are accessible from the original object"
        ],
        "explanation": "Explanation: When an object is called by values, copy constructor is called and object is copied to the local object of the function which is mentioned in the argument list. The values gets copied and are used from the local object. There is no need to access the original object again.",
        "index": 521,
        "difficulty": 1.1469512017313086,
        "correct": 2
    },
    {
        "question": "Can data members be passed to a function using the object?",
        "options": [
            "Yes, it can be passed only inside class functions",
            "Yes, only if the data members are public and are being passed to a function outside the class",
            "No, can\u2019t be passed outside the class",
            "No, can\u2019t be done"
        ],
        "explanation": "Explanation: The data members can be passed with help of object but only if the member is public. The object will obviously be used outside the class. The object must have access to the data member so that its value or reference is used outside the class which is possible only if the member is public.",
        "index": 522,
        "difficulty": 1.1473073161092202,
        "correct": 2
    },
    {
        "question": "What exactly is passed when an object is passed by reference?",
        "options": [
            "The original object name",
            "The original object class name",
            "The exact address of the object in memory",
            "The exact address of data members"
        ],
        "explanation": "Explanation: The location of the object, that is, the exact memory location is passed, when the object is passed by reference. The pass by reference is actually a reference to the object that the function uses with another name to the same memory location as the original object uses.",
        "index": 523,
        "difficulty": 1.1658392431152516,
        "correct": 3
    },
    {
        "question": "If the object is not to be passed to any function but the values of the object have to be used then?",
        "options": [
            "The data members should be passed separately",
            "The data members and member functions have to be passed separately",
            "The values should be present in other variables",
            "The object must be passed"
        ],
        "explanation": "Explanation: The data members can be passed separately. There is no need to pass whole object, instead we can use the object to pass only the required values.",
        "index": 524,
        "difficulty": 1.2057880613444034,
        "correct": 1
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "More than one object can\u2019t be passed to a function",
            "Any number of objects can be passed to a function",
            "Objects can\u2019t be passed, only data member values can be passed",
            "Objects should be passed only if those are public in class"
        ],
        "explanation": "Explanation: There is no restriction on passing the number of objects to a function. The operating system or the compiler or environment may limit the number of arguments. But there is no limit on number of objects till that limit.",
        "index": 525,
        "difficulty": 1.2129025323534206,
        "correct": 2
    },
    {
        "question": "In which of the following way(s) can the object be returned from a function?",
        "options": [
            "Can only be returned by value",
            "Can only be returned by reference",
            "Can be returned either by value or reference",
            "Can neither be returned by value nor by reference"
        ],
        "explanation": "Explanation: The objects can be returned either by value or reference. There is no mandatory condition for the way it should be used. The way of returning object can be decided based on the requirement.",
        "index": 526,
        "difficulty": 1.2213559376655931,
        "correct": 3
    },
    {
        "question": "Whenever an object is returned by value ____________________",
        "options": [
            "A temporary object is created",
            "Temporary object is not created",
            "Temporary object may or may not be created",
            "New permanent object is created"
        ],
        "explanation": "Explanation: A temporary object is created when an object is returned by value. The temporary object is used to copy the values to another object or to be used in some way. The object holds all the values of the data members of the object.",
        "index": 527,
        "difficulty": 1.2222794872967668,
        "correct": 1
    },
    {
        "question": "Where the temporary objects (created while return by value) are created?",
        "options": [
            "Outside the function scope",
            "Within the function",
            "Inside the main function",
            "Inside the calling function"
        ],
        "explanation": "Explanation: The temporary object are created within the function and are intended to return the value for specific use. Either the object can be assigned to another object or be used directly if possible.",
        "index": 528,
        "difficulty": 1.2235610952232712,
        "correct": 2
    },
    {
        "question": "Which is the correct syntax for returning an object by value?",
        "options": [
            "void functionName ( ){ }",
            "object functionName( ) { }",
            "class object functionName( ) { }",
            "ClassName functionName ( ){ }"
        ],
        "explanation": "Explanation: The class name itself should be the return type of the function. This notifies that the function will return an object of specified class type. Only the class name should be specified.",
        "index": 529,
        "difficulty": 1.2246491454815818,
        "correct": 4
    },
    {
        "question": "Which is the correct syntax for defining a function which passes an object by reference?",
        "options": [
            "className& functionName ( )",
            "className* functionName( )",
            "className-> functionName( )",
            "&className functionName()"
        ],
        "explanation": "Explanation: The function declaration must contain the class name as return type. But, a & symbol should be followed by the class name. & indicates that the object being returned will be returned by reference.",
        "index": 530,
        "difficulty": 1.2290461181592045,
        "correct": 1
    },
    {
        "question": "If an object is declared inside the function then ____________________ outside the function.",
        "options": [
            "It can be returned by reference",
            "It can\u2019t be returned by reference",
            "It can be returned by address",
            "It can\u2019t be returned at all"
        ],
        "explanation": "Explanation: The object which is declared inside the class can never be returned by reference. This is because the object will be destroyed as it goes out of scope when the function is returned. The local variables get destroyed when function is returned hence the local objects can\u2019t be returned by reference.",
        "index": 531,
        "difficulty": 1.2383294064825527,
        "correct": 2
    },
    {
        "question": "How many independent objects can be returned at same time from a function?",
        "options": [
            "1",
            "2",
            "3",
            "4"
        ],
        "explanation": "Explanation: Only one object can be returned at a time. This is because a function is only capable of returning a single value at a time. Though array of objects can be returned from a function.",
        "index": 532,
        "difficulty": 1.2438626094345473,
        "correct": 1
    },
    {
        "question": "Which error will be produced if a local object is returned by reference outside a function?",
        "options": [
            "Out of memory error",
            "Run time error",
            "Compile time error",
            "No error"
        ],
        "explanation": "Explanation: If the local object is returned outside the function then the compile-time error arises. While the program is being converted and the processes happening during compile time, the compiler won\u2019t be able to resolve the statement.",
        "index": 533,
        "difficulty": 1.2505915163563834,
        "correct": 3
    },
    {
        "question": "If object is passed by reference ____________________",
        "options": [
            "Temporary object is created",
            "Temporary object is created inside the function",
            "Temporary object is created for few seconds",
            "Temporary object is not created"
        ],
        "explanation": "Explanation: The temporary object is not created. If object is returned by reference, a particular memory location will be denoted with another name and hence same address values will be used.",
        "index": 534,
        "difficulty": 1.257904104564119,
        "correct": 4
    },
    {
        "question": "Which among the following is correct?",
        "options": [
            "Individual data members can\u2019t be returned",
            "Individual data members can be returned",
            "Individual member functions can be returned from another function",
            "Individual data members can only be passed by reference"
        ],
        "explanation": "Explanation: It is not mandatory to return the whole object. Instead we can return a specific data member value. But the return type given must match with the data type of the data being returned.",
        "index": 535,
        "difficulty": 1.2677252982566625,
        "correct": 2
    },
    {
        "question": "Can we return an array of objects?",
        "options": [
            "Yes, always",
            "Ye, only if objects are having same values",
            "No, because objects contain many other values",
            "No, because objects are single entity"
        ],
        "explanation": "Explanation: The Object array can be returned from a function. This can be done by putting a className* as the return type of the function. This makes the return type to accept an array of objects in return.",
        "index": 536,
        "difficulty": 1.2679943454355485,
        "correct": 1
    },
    {
        "question": "If an object is passed by reference to a function then it must be returned by reference.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: It is not compulsory to return the object in the same way as it was passed. If the object is passed by reference then there is actually no need to return the object. Because the changes made inside the function will be visible on the original object of caller function also.",
        "index": 537,
        "difficulty": 1.2814467043627058,
        "correct": 2
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "Two objects can point to the same memory location",
            "Two objects can never point to the same memory location",
            "Objects not allowed to point at a location already occupied",
            "Objects can\u2019t point to any address"
        ],
        "explanation": "Explanation: When an object is created and instead of calling a constructor, another object is assigned to it. Both the objects point to the same memory location. This can be illustrated with help of return by reference.",
        "index": 538,
        "difficulty": 1.2849050521900933,
        "correct": 1
    },
    {
        "question": "If an object is being returned by value then __________________________",
        "options": [
            "Its member values are made constant",
            "Its member values have to be copied individually",
            "Its member values are not used",
            "Its member values are copied using copy constructor"
        ],
        "explanation": "Explanation: When an object is returned by value, it will be returned to another object or will be directly used. Still in all the conditions the copy constructor will be used to copy all the values from the temporary object that gets created.",
        "index": 539,
        "difficulty": 1.321361193267757,
        "correct": 4
    },
    {
        "question": "Why temporary object is not created in return by reference?",
        "options": [
            "Because compiler can\u2019t create temporary objects",
            "Because the temporary object is created within the function",
            "Because return by reference just make the objects points to values memory location",
            "Because return by reference just make the object point to null"
        ],
        "explanation": "Explanation: A reference to the memory location where the returned object is stored is made. This allows the new object which takes the return value, point to the memory location and hence access the same values.",
        "index": 540,
        "difficulty": 1.3275370402216673,
        "correct": 3
    },
    {
        "question": "When value of an object is assigned to another object ________________",
        "options": [
            "It becomes invalid statement",
            "Its values gets copied into another object",
            "Its values gets address of the existing values",
            "The compiler doesn\u2019t execute that statement"
        ],
        "explanation": "Explanation: The values get copied to another object. No address is assigned to the object values. This is uses copy constructor to copy the values.",
        "index": 541,
        "difficulty": 1.329137447687235,
        "correct": 2
    },
    {
        "question": "If an object is created and another object is assigned to it, then ________________",
        "options": [
            "Copy constructor is called to copy the values",
            "Object is copied directly to the object",
            "Reference to another object is created",
            "The new object is initialized to null values"
        ],
        "explanation": "Explanation: The new object created, refers to the same address of the previously created object. Now whenever new object changes any data member value, it will affect the previously existing object.",
        "index": 542,
        "difficulty": 1.3342962708126134,
        "correct": 3
    },
    {
        "question": "How the argument passed to a function get initialized?",
        "options": [
            "Assigned using copy constructor at time of passing",
            "Copied directly",
            "Uses addresses always",
            "Doesn\u2019t get initialized"
        ],
        "explanation": "Explanation: The arguments get initialized using the copy constructor. There is a need of assigning the value of all the members of an object to the local object of the function.",
        "index": 543,
        "difficulty": 1.3352662091699257,
        "correct": 1
    },
    {
        "question": "Which language among the following doesn\u2019t allow pointers?",
        "options": [
            "C++",
            "Java",
            "Pascal",
            "C"
        ],
        "explanation": "Explanation: The concept of pointers is not supported in Java. The feature is not given in the language but can be used in some ways explicitly. Though this pointer is supported by java too.",
        "index": 544,
        "difficulty": 1.3413100732329735,
        "correct": 2
    },
    {
        "question": "Which is correct syntax for declaring pointer to object?",
        "options": [
            "className* objectName;",
            "className objectName;",
            "*className objectName;",
            "className objectName();"
        ],
        "explanation": "Explanation: The syntax must contain * symbol after the className as the type of object. This declares an object pointer. This can store address of any object of the specified class.",
        "index": 545,
        "difficulty": 1.3426693511762124,
        "correct": 1
    },
    {
        "question": "Which operator should be used to access the members of the class using object pointer?",
        "options": [
            "Dot operator",
            "Colon to the member",
            "Scope resolution operator",
            "Arrow operator"
        ],
        "explanation": "Explanation: The members can be accessed from the object pointer by using arrow operator. The arrow operator can be used only with the pointer of class type. If simple object is declared, it must use dot operator to access the members.",
        "index": 546,
        "difficulty": 1.3526714151453572,
        "correct": 4
    },
    {
        "question": "How does compiler decide the intended object to be used, if more than one object are used?",
        "options": [
            "Using object name",
            "Using an integer pointer",
            "Using this pointer",
            "Using void pointer"
        ],
        "explanation": "Explanation: This pointer denotes the object, in which it is being used. If member function is called with respect to one object then this pointer refers to the same object members. It can be used when members with same name are involved.",
        "index": 547,
        "difficulty": 1.3547639453734899,
        "correct": 3
    },
    {
        "question": "If pointer to an object is declared __________",
        "options": [
            "It can store any type of address",
            "It can store only void addresses",
            "It can only store address of integer type",
            "It can only store object address of class type specified"
        ],
        "explanation": "Explanation: The address of only the specified class type can get their address stored in the object pointer. The addresses doesn\u2019t differ but they do differ for the amount and type of memory required for objects of different classes. Hence same class object pointer should be used.",
        "index": 548,
        "difficulty": 1.3588717076612964,
        "correct": 4
    },
    {
        "question": "What is the size of an object pointer?",
        "options": [
            "Equal to size of any usual pointer",
            "Equal to size of sum of all the members of object",
            "Equal to size of maximum sized member of object",
            "Equal to size of void"
        ],
        "explanation": "Explanation: The size of object pointer is same as that of any usual pointer. This is because only the address have to be stored. There are no values to be stored in the pointer.",
        "index": 549,
        "difficulty": 1.3785408111865385,
        "correct": 1
    },
    {
        "question": "A pointer _________________",
        "options": [
            "Can point to only one object at a time",
            "Can point to more than one objects at a time",
            "Can point to only 2 objects at a time",
            "Can point to whole class objects at a time"
        ],
        "explanation": "Explanation: The object pointer can point to only one object at a time. The pointer will be able to store only one address at a time. Hence only one object can be referred.",
        "index": 550,
        "difficulty": 1.3872244223279928,
        "correct": 1
    },
    {
        "question": "Pointer to a base class can be initialized with the address of derived class, because of _________",
        "options": [
            "derived-to-base implicit conversion for pointers",
            "base-to-derived implicit conversion for pointers",
            "base-to-base implicit conversion for pointers",
            "derived-to-derived implicit conversion for pointers"
        ],
        "explanation": "Explanation: It is an implicit rule defined in most of the programming languages. It permits the programmer to declare a pointer to the derived class from a base class pointer. In this way the programmer doesn\u2019t have to declare object for derived class each time it is required.",
        "index": 551,
        "difficulty": 1.3936307688231526,
        "correct": 1
    },
    {
        "question": "Can pointers to object access the private members of the class?",
        "options": [
            "Yes, always",
            "Yes, only if it is only pointer to object",
            "No, because objects can be referenced from another objects too",
            "No, never"
        ],
        "explanation": "Explanation: The pointers to an object can never access the private members of the class outside the class. The object can indirectly use those private members using member functions which are public in the class.",
        "index": 552,
        "difficulty": 1.4056018697063788,
        "correct": 4
    },
    {
        "question": "Is name of an array of objects is also a pointer to object?",
        "options": [
            "Yes, always",
            "Yes, in few cases",
            "No, because it represents more than one object",
            "No, never"
        ],
        "explanation": "Explanation: The array name represents a pointer to the object. The name alone can represent the starting address of the array. But that also represents an array which is in turn stored in a pointer.",
        "index": 553,
        "difficulty": 1.4166274020787304,
        "correct": 1
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "The pointer to object can hold address only",
            "The pointer can hold value of any type",
            "The pointer can hold only void reference",
            "The pointer can\u2019t hold any value"
        ],
        "explanation": "Explanation: The pointer to an object can hold only the addresses. Address of any other object of same class. This allows the programmer to link more than one objects if required.",
        "index": 554,
        "difficulty": 1.4229502239008083,
        "correct": 1
    },
    {
        "question": "Which is the correct syntax to call a member function using pointer?",
        "options": [
            "pointer->function()",
            "pointer.function()",
            "pointer::function()",
            "pointer:function()"
        ],
        "explanation": "Explanation: The pointer should be mentioned followed by the arrow operator. Arrow operator is applicable only with the pointers. Then the function name should be mentioned that is to be called.",
        "index": 555,
        "difficulty": 1.4268064818971453,
        "correct": 1
    },
    {
        "question": "If a pointer to an object is created and the object gets deleted without using the pointer then __________",
        "options": [
            "It becomes void pointer",
            "It becomes dangling pointer",
            "It becomes null pointer",
            "It becomes zero pointer"
        ],
        "explanation": "Explanation: When the address pointed by the object pointer gets deleted, the pointer now points to an invalid address. Hence it becomes a dangling pointer. It can\u2019t be null or void pointer since it doesn\u2019t point to any specific location.",
        "index": 556,
        "difficulty": 1.4371940248124782,
        "correct": 2
    },
    {
        "question": "How can the address stored in the pointer be retrieved?",
        "options": [
            "Using * symbol",
            "Using $ symbol",
            "Using & symbol",
            "Using @ symbol"
        ],
        "explanation": "Explanation: The & symbol must be used. This should be done such that the object should be preceded by & symbol and then the address should be stored in another variable. This is done to get the address where the object is stored.",
        "index": 557,
        "difficulty": 1.445708576548471,
        "correct": 3
    },
    {
        "question": "What should be done to prevent changes that may be made to the values pointed by the pointer?",
        "options": [
            "Usual pointer can\u2019t change the values pointed",
            "Pointer should be made virtual",
            "Pointer should be made anonymous",
            "Pointer should be made const"
        ],
        "explanation": "Explanation: The pointer should be declared as a const type. This prevents the pointer to change any value that is being pointed from it. This is a feature that is made to access the values using pointer but to make sure that pointer doesn\u2019t change those values accidently.",
        "index": 558,
        "difficulty": 1.449347422286686,
        "correct": 4
    },
    {
        "question": "References to object are same as pointers of object.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The references are made to object when the object is created and initialized with another object without calling any constructor. But the object pointer must be declared explicitly using * symbol that will be capable of storing some address. Hence both are different.",
        "index": 559,
        "difficulty": 1.4496245854961316,
        "correct": 2
    },
    {
        "question": "Which is the pointer which denotes the object calling the member function?",
        "options": [
            "Variable pointer",
            "This pointer",
            "Null pointer",
            "Zero pointer"
        ],
        "explanation": "Explanation: The pointer which denotes the object calling the member function is known as this pointer. The this pointer is usually used when there are members in the function with same name as those of the class members.",
        "index": 560,
        "difficulty": 1.4608394460262346,
        "correct": 2
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "this pointer is passed implicitly when member functions are called",
            "this pointer is passed explicitly when member functions are called",
            "this pointer is passed with help of pointer member functions are called",
            "this pointer is passed with help of void pointer member functions are called"
        ],
        "explanation": "Explanation: When an object calls some member function, it implicitly passes itself as an argument. This allows the compiler to know which member should be used for the purposes. This also allows to reduce the ambiguity among the variable and data member names.",
        "index": 561,
        "difficulty": 1.465430519303288,
        "correct": 1
    },
    {
        "question": "The this pointer is accessible __________________",
        "options": [
            "Within all the member functions of the class",
            "Only within functions returning void",
            "Only within non-static functions",
            "Within the member functions with zero arguments"
        ],
        "explanation": "Explanation: The this pointer is available only within the non-static member functions of a class. If the member function is static, it will be common to all the objects and hence a single object can\u2019t refer to those functions independently.",
        "index": 562,
        "difficulty": 1.4752283198919578,
        "correct": 3
    },
    {
        "question": "An object\u2019s this pointer _____________________",
        "options": [
            "Isn\u2019t part of class",
            "Isn\u2019t part of program",
            "Isn\u2019t part of compiler",
            "Isn\u2019t part of object itself"
        ],
        "explanation": "Explanation: The object\u2019s this pointer being called are not part of the object itself. This can be cross verified by checking that it doesn\u2019t take up any space for the data to be stored or pointed.",
        "index": 563,
        "difficulty": 1.4788461614774704,
        "correct": 4
    },
    {
        "question": "The result of sizeof() function __________________",
        "options": [
            "Includes space reserved for this pointer",
            "Includes space taken up by the address pointer by this pointer",
            "Doesn\u2019t include the space taken by this pointer",
            "Doesn\u2019t include space for any data member"
        ],
        "explanation": "Explanation: The space taken by this pointer is not reflected in by the sizeof() operator. This is because object\u2019s this pointer is not part of object itself. This is a cross verification for the concept stating that this pointer doesn\u2019t take any space in the object.",
        "index": 564,
        "difficulty": 1.5224887590161025,
        "correct": 3
    },
    {
        "question": "Whenever non-static member functions are called _______________",
        "options": [
            "Address of the object is passed implicitly as an argument",
            "Address of the object is passed explicitly as an argument",
            "Address is specified globally so that the address is not used again",
            "Address is specified as return type of the function"
        ],
        "explanation": "Explanation: The address is passed implicitly as an argument to the function. This doesn\u2019t have to be passed explicitly. The address is passed, of the object which is calling the non-static member function.",
        "index": 565,
        "difficulty": 1.5328068677234077,
        "correct": 1
    },
    {
        "question": "Which is the correct interpretation of the member function call from an object, object.function(parameter);",
        "options": [
            "object.function(&this, parameter)",
            "object(&function,parameter)",
            "function(&object,&parameter)",
            "function(&object,parameter)"
        ],
        "explanation": "Explanation: The function name is specified first and then the parameter lists. The parameter list is included with the object name along with & symbol. This denotes that the address of the object is being passed as an argument.",
        "index": 566,
        "difficulty": 1.5432992342895897,
        "correct": 4
    },
    {
        "question": "The address of the object _________________",
        "options": [
            "Can\u2019t be accessed from inside the function",
            "Can\u2019t be accessed in the program",
            "Is available inside the member function using this pointer",
            "Can be accessed using the object name inside the member function"
        ],
        "explanation": "Explanation: The address of the object with respect to which the member functions are being called, are stored in this pointer. This pointer is hence used whenever there are members with same name as those of the variables inside the function.",
        "index": 567,
        "difficulty": 1.5574642926090485,
        "correct": 3
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "This pointer can be used to guard against any kind of reference",
            "This pointer can be used to guard against self-reference",
            "This pointer can be used to guard from other pointers",
            "This pointer can be used to guard from parameter referencing"
        ],
        "explanation": "Explanation: The this pointer can be used to guard itself whenever self-reference is used. This allows accidental address access. And accidental modification of data.",
        "index": 568,
        "difficulty": 1.5694030112432973,
        "correct": 2
    },
    {
        "question": "Which syntax doesn\u2019t execute/is false when executed?",
        "options": [
            "if(&object != this)",
            "if(&function !=object)",
            "this.if(!this)",
            "this.function(!this)"
        ],
        "explanation": "Explanation: The condition becomes false when executed and hence doesn\u2019t executes. This is the case where this pointer can guard itself from the self-reference. Here if the address of the object doesn\u2019t match with this pointer that means the object doesn\u2019t refer itself.",
        "index": 569,
        "difficulty": 1.5979417384356749,
        "correct": 1
    },
    {
        "question": "The this pointers _____________________",
        "options": [
            "Are modifiable",
            "Can be assigned any value",
            "Are made variables",
            "Are non-modifiable"
        ],
        "explanation": "Explanation: The this pointer is non modifiable. This is because the address of any object remains constant throughout its life time. Hence the address must not be changed otherwise wrong members of invalid addresses might get accessed.",
        "index": 570,
        "difficulty": 1.6132018006721758,
        "correct": 4
    },
    {
        "question": "Earlier implementations of C++ ___________________",
        "options": [
            "Never allowed assignment to this pointer",
            "Allowed no assignment to this pointer",
            "Allowed assignments to this pointer",
            "Never allowed assignment to any pointer"
        ],
        "explanation": "Explanation: The earlier, most initial versions of C++ used to allow assignments to this pointers. That used to allow modifications of this pointer. Later that feature got disabled.",
        "index": 571,
        "difficulty": 1.6229255494863901,
        "correct": 3
    },
    {
        "question": "This pointer can be used directly to ___________",
        "options": [
            "To manipulate self-referential data structures",
            "To manipulate any reference to pointers to member functions",
            "To manipulate class references",
            "To manipulate and disable any use of pointers"
        ],
        "explanation": "Explanation: This is a feature provided, that can be used directly. The manipulation of self-referential data structures is just an application of this feature. Other conditions fails as this pointer doesn\u2019t deal with those things.",
        "index": 572,
        "difficulty": 1.6437729399443644,
        "correct": 1
    },
    {
        "question": "Which among the following is/are type(s) of this pointer?",
        "options": [
            "const",
            "volatile",
            "const or volatile",
            "int"
        ],
        "explanation": "Explanation: The this pointer can be declared const or volatile. This depends on need of program and type of code. This is just an additional feature.",
        "index": 573,
        "difficulty": 1.6484978263637204,
        "correct": 3
    },
    {
        "question": "Which is the correct syntax for declaring the type of this in a member function?",
        "options": [
            "classType [cv-qualifier-list] *const this;",
            "classType const[cv-qualifier-list] *this;",
            "[cv-qualifier-list]*const classType this;",
            "[cv-qualifier-list] classType *const this;"
        ],
        "explanation": "Explanation: The syntax contains the cv-qualifier-list that can be determined from the member function declaratory that can be either const or volatile or can be made both. Hence we write it as list. classType denotes the name of class to mention to which class does the object belong to. And *const this denotes that the this pointer is having a constant value.",
        "index": 574,
        "difficulty": 1.6570638714189307,
        "correct": 4
    },
    {
        "question": "What are default arguments?",
        "options": [
            "Arguments which are not mandatory to be passed",
            "Arguments with default value that aren\u2019t mandatory to be passed",
            "Arguments which are not passed to functions",
            "Arguments which always take same data value"
        ],
        "explanation": "Explanation: The arguments which are assigned with some default value. Since some value is already given, it is not mandatory to pass those arguments. They can be used directly.",
        "index": 575,
        "difficulty": 1.6614193003685793,
        "correct": 2
    },
    {
        "question": "Which is the correct condition for the default arguments?",
        "options": [
            "Those must be declared as last arguments in argument list",
            "Those must be declared first in the argument list",
            "Those can be defined anywhere in the argument list",
            "Those are declared inside the function definition"
        ],
        "explanation": "Explanation: The default arguments must be declared at last in the argument list. This is to ensure that the arguments doesn\u2019t create ambiguity. The normal arguments should be passed first.",
        "index": 576,
        "difficulty": 1.6616239371938368,
        "correct": 1
    },
    {
        "question": "If a member function have to be made both zero argument and parameterized constructor, which among the following can be the best option?",
        "options": [
            "Two normal and one default argument",
            "At least one default argument",
            "Exactly one default argument",
            "Make all the arguments default"
        ],
        "explanation": "Explanation: All the arguments must be made default. This will make sure that none of the arguments are mandatory to be passed. Which in turn means that the function can work without any argument and can be passed with arguments too.",
        "index": 577,
        "difficulty": 1.6640948167904357,
        "correct": 4
    },
    {
        "question": "Which among the following function can be called without arguments?",
        "options": [
            "void add(int x, int y=0)",
            "void add(int=0)",
            "void add(int x=0, int y=0)",
            "void add(char c)"
        ],
        "explanation": "Explanation: For the function to be called without arguments, either it must have zero arguments or it must have all the default arguments. Here the function in option void add(int x=0, int y=0) have all the default arguments and hence can be called directly with zero argument.",
        "index": 578,
        "difficulty": 1.6726937958357224,
        "correct": 3
    },
    {
        "question": "If a function have all the default arguments but still some values are passed to the function then ______________",
        "options": [
            "The function will use the values passed to it",
            "The function will use the default values as those are local",
            "The function can use any value whichever is higher",
            "The function will choose the minimum values"
        ],
        "explanation": "Explanation: The function will use the values passed explicitly to it. The default values will be ignored. The default values are used only in case the values are not passed explicitly to the function.",
        "index": 579,
        "difficulty": 1.6881337636081533,
        "correct": 1
    },
    {
        "question": "Which among the following is correct?",
        "options": [
            "void test(int x=0, int y, int z=0)",
            "void test(int x=0, int=0)",
            "void test(int x, int y=0)",
            "void test(int x=\u2019c, int y)"
        ],
        "explanation": "Explanation: The default arguments must be mentioned at last in the argument list. Also, the type of values assigned must match with the argument type. All the default arguments must be mentioned at last, none of the normal arguments should come in between the default arguments list.",
        "index": 580,
        "difficulty": 1.6893477470403138,
        "correct": 3
    },
    {
        "question": "What function will be called with the independent syntax \u201ctest(5,6,7);\u201d?",
        "options": [
            "void test(int x, int y)",
            "void test(int x=0, int y, int z)",
            "int test(int x=0, y=0, z=0)",
            "void test(int x, int y, int z=0)"
        ],
        "explanation": "Explanation: There are three arguments that are getting passed to the function test(). Only the last option have all the default argument at last in the argument list. And the total number of the arguments is three. The third option is wrong because the return type is int and the syntax given is independent which means it doesn\u2019t return any value.",
        "index": 581,
        "difficulty": 1.699431911887138,
        "correct": 4
    },
    {
        "question": "Which among the following is a wrong call to the function void test(int x, int y=0, int z=0)?",
        "options": [
            "test(5,6,7);",
            "test(5);",
            "test();",
            "test(5,6);"
        ],
        "explanation": "Explanation: The function must be passed with at least one argument. There is two default arguments and one normal argument which must be passed with some value. Hence the third call to the function is wrong as it doesn\u2019t pass even a single parameter to the function",
        "index": 582,
        "difficulty": 1.7119136859250794,
        "correct": 3
    },
    {
        "question": "Default arguments are _________________________",
        "options": [
            "Only allowed in the parameter list of the function declaration",
            "Only allowed in the return type of the function declaration",
            "Only allowed with the class name definition",
            "Only allowed with the integer type values"
        ],
        "explanation": "Explanation: The default arguments are only allowed in the parameter list of the function arguments. This rule was not applicable in the beginning versions of c++ but later from c++ 14th version it has been implemented. This is the only way to use default arguments.",
        "index": 583,
        "difficulty": 1.7143988962961494,
        "correct": 1
    },
    {
        "question": "Which among the following is false for default arguments?",
        "options": [
            "Those are not allowed with a declaration of pointer to functions",
            "Those are not allowed with the reference to functions",
            "Those are not allowed with the typedef declarations",
            "Those are allowed with pointer and reference to function declaration"
        ],
        "explanation": "Explanation: The statements given are true because that is a feature given to make the programming more flexible and have some security with accidental changes at same time. The last option is false because it is not a rule defined. It is an opposite statement to the rules defined for default arguments.",
        "index": 584,
        "difficulty": 1.7208917619485664,
        "correct": 4
    },
    {
        "question": "The non-template functions can be added with default arguments to already declared functions ____________________",
        "options": [
            "If and only if the function is declared again in the same scope",
            "If and only if the function is declared only once in the same scope",
            "If and only if the function is declared in different scope",
            "If and only if the function is declared twice in the program"
        ],
        "explanation": "Explanation: The non-template functions can also be added with default arguments. This can be done even if the functions were defined earlier. This is because the call to the function won\u2019t be affected. The function can still be used in the same way as it was used earlier.",
        "index": 585,
        "difficulty": 1.7263632342416981,
        "correct": 1
    },
    {
        "question": "The using declaration __________",
        "options": [
            "Doesn\u2019t carry over the default values",
            "Carries over the known default arguments",
            "Carries over only the normal arguments",
            "Carries over only few default arguments"
        ],
        "explanation": "Explanation: The using-declaration carries over all the known default arguments. This is a common feature as the usage doesn\u2019t gets affected even if the default arguments are added. This comes under flexible programming.",
        "index": 586,
        "difficulty": 1.7318033893847087,
        "correct": 2
    },
    {
        "question": "The names given to the default arguments are only looked up and ________________ and are bound during declaration.",
        "options": [
            "Checked for availability",
            "Checked for random access",
            "Checked for accessibility",
            "Checked for feasibility"
        ],
        "explanation": "Explanation: The names given to the default arguments are bound at time of declaration but are only checked for accessibility and to get bounded. This is mainly to bind those members during declaration.",
        "index": 587,
        "difficulty": 1.7342878094433711,
        "correct": 3
    },
    {
        "question": "The default argument get bound during declaration ________________",
        "options": [
            "And are never executed",
            "And are executed simultaneously",
            "But are executed only if priority is given",
            "But are executed during function call"
        ],
        "explanation": "Explanation: The default argument are bound at the time of declaration. That is an implicit functioning. But those are executed only when the function is called. Otherwise, those will never get executed.",
        "index": 588,
        "difficulty": 1.735852182466088,
        "correct": 4
    },
    {
        "question": "The virtual function overrides ____________",
        "options": [
            "Do not acquire base class declaration of default arguments",
            "Do acquire base class declaration of default arguments",
            "Do not link with the default arguments of base class",
            "Do link with the default argument but only of derived classes"
        ],
        "explanation": "Explanation: The virtual function overrides do not acquire the base class declaration of default arguments. Even if a call to the virtual function is made, static type of the object decides the default arguments to be used.",
        "index": 589,
        "difficulty": 1.736849733426297,
        "correct": 1
    },
    {
        "question": "Which among the following is true for constructors overloading?",
        "options": [
            "Constructors can\u2019t be overloaded",
            "Constructors can be overloaded using different signatures",
            "Constructors can be overloaded with same signatures",
            "Constructors can be overloaded with different return types"
        ],
        "explanation": "Explanation: The constructors can be overloaded only if the definitions have different signatures. Constructors doesn\u2019t have any return type so can\u2019t be overloaded using return type. If constructors have same signature then it will produce a compile time error.",
        "index": 590,
        "difficulty": 1.7437407658316646,
        "correct": 2
    },
    {
        "question": "If a constructors should be capable of creating objects without argument and with arguments, which is a good alternative for this purpose?",
        "options": [
            "Use zero argument constructor",
            "Use constructor with one parameter",
            "Use constructor with all default arguments",
            "Use default constructor"
        ],
        "explanation": "Explanation: The constructor should use all the default arguments. This will allow the constructor to be called even if no arguments are passed. And if arguments are passed, those will be accepted instead of the default values.",
        "index": 591,
        "difficulty": 1.7523108603210158,
        "correct": 3
    },
    {
        "question": "The Constructors with all the default arguments are similar as default constructors.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The constructors with all the default arguments are similar as the default constructors. Those can be used instead of the default constructors. So defining the default constructor is not mandatory.",
        "index": 592,
        "difficulty": 1.771587476781943,
        "correct": 1
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "The constructors overloading can be done by using different names",
            "The constructors overloading can be done by using different return types",
            "The constructors can be overloaded by using only one argument",
            "The constructors must have the same name as that of class"
        ],
        "explanation": "Explanation: The constructors must have the same name as that of the class name. This is mandatory because only the constructor functions doesn\u2019t have any return type. Also, for overloading all the functions must have the same name.",
        "index": 593,
        "difficulty": 1.8052509811340345,
        "correct": 4
    },
    {
        "question": "Which among the following can be used in place of default constructor?",
        "options": [
            "constructorName(int x, int y=0)",
            "constructorName(int x=0, int y=0)",
            "constructorName(int x=0, int y)",
            "constructorName(int x, int y)"
        ],
        "explanation": "Explanation: For a parameterized constructor to be used as a default constructor, it must have all the default arguments. This makes the constructor to have optional arguments which are not mandatory to be passed.",
        "index": 594,
        "difficulty": 1.8082253559559698,
        "correct": 2
    },
    {
        "question": "Can a class have more than one function with all the default arguments?",
        "options": [
            "Yes, always",
            "Yes, if argument list is different",
            "No, because constructors overloading doesn\u2019t depend on argument list",
            "No, never"
        ],
        "explanation": "Explanation: A single class can never have more than once constructor with all the default arguments. This is because it will make all those constructors as a default constructor. And when an object is created with zero arguments then it will create ambiguity.",
        "index": 595,
        "difficulty": 1.8214026278789426,
        "correct": 4
    },
    {
        "question": "Which is the correct syntax for using default arguments with the constructor?",
        "options": [
            "default constructorName(default int x=0)",
            "constructorName(default int x=0)",
            "constructorName(int x=0)",
            "constructorName()"
        ],
        "explanation": "Explanation: The constructors using the default arguments must initialize the arguments in the argument list. This is to make the constructor use the default value when no arguments are passed. If no arguments are listed then it is a default constructor.",
        "index": 596,
        "difficulty": 1.830172472777038,
        "correct": 3
    },
    {
        "question": "How many parameters must be passed if only the following prototype is given to a constructor?",
        "options": [
            ";",
            "1",
            "2",
            "3",
            "Compile time error"
        ],
        "explanation": "Explanation: In the prototype given, only 2 arguments are mandatory. Since the third argument is default argument, so it is not mandatory to pass the argument.",
        "index": 597,
        "difficulty": 1.8312386709877222,
        "correct": 2
    },
    {
        "question": "If the constructors are overloaded by using the default arguments, which problem may arise?",
        "options": [
            "The constructors might have all the same arguments except the default arguments",
            "The constructors might have same return type",
            "The constructors might have same number of arguments",
            "The constructors can\u2019t be overloaded with respect to default arguments"
        ],
        "explanation": "Explanation: The constructors having same arguments except the default arguments can give rise to errors. If only the mandatory arguments are passed, it will create ambiguity in calling the correct constructor. Hence the mandatory arguments must be different.",
        "index": 598,
        "difficulty": 1.8408133731789418,
        "correct": 1
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "More than one constructors with all default arguments is allowed",
            "More than one constructors with all default arguments can be defined outside the class",
            "More than one constructors can be used with same argument list",
            "More than one constructors with all default arguments can\u2019t exist in same class"
        ],
        "explanation": "Explanation: The constructors must have different argument list. Along that, if all the arguments are default arguments, there can\u2019t be more than once constructor like that in the same class as that will create ambiguity while constructors are being called.",
        "index": 599,
        "difficulty": 1.8510443974423243,
        "correct": 4
    },
    {
        "question": "Which constructor among the following will be called if a call is made like className(5,\u2019a\u2019);?",
        "options": [
            "className(int x=5,char c=\u2019a\u2019);",
            "int className(int x, char c, char d);",
            "className(int x, char c, int y);",
            "char className(char c,int x);"
        ],
        "explanation": "Explanation: The syntax given is passing two parameters to the constructor call. One value is of integer type and another of character type. Hence the constructor with arguments of int and char type should be called. There is only one option that first accepts integer value and then a character value. Hence that constructor will be called.",
        "index": 600,
        "difficulty": 1.8710860598544645,
        "correct": 1
    },
    {
        "question": "Which constructor definition will produce a compile time error?",
        "options": [
            "className(int x=0);",
            "className(char c);",
            "className(int x=0,char c);",
            "className(char c,int x=0);"
        ],
        "explanation": "Explanation: The default arguments, just like with member functions, must be listed at last in the argument list. Hence this will produce a compile time error. The compiler doesn\u2019t allow the definition to be executed.",
        "index": 601,
        "difficulty": 1.8758982987422526,
        "correct": 3
    },
    {
        "question": "If there is a constructor with all the default arguments and arguments are not passed then _________________",
        "options": [
            "The default values given will not be used",
            "Then all the null values will be used",
            "Then all the default values given will be used",
            "Then compiler will produce an error"
        ],
        "explanation": "Explanation: The constructors will use the default values listed for use. The null values are not used because those are not specified. Though if it was compiler provided default constructor, then it would have initialized the members to null or zero values.",
        "index": 602,
        "difficulty": 1.8847331591479133,
        "correct": 3
    },
    {
        "question": "Which is the correct statement for default constructors?",
        "options": [
            "The constructors with all the default arguments",
            "The constructors with all the null and zero values",
            "The constructors which can\u2019t be defined by programmer",
            "The constructors with zero arguments"
        ],
        "explanation": "Explanation: The closest answer to the question is that a default constructor is a constructor with zero arguments. But this is not the actual case. Actually the constructors provided by the compiler are default constructors. And the constructors with zero arguments defined by the programmer are zero argument constructors.",
        "index": 603,
        "difficulty": 1.9007115154667975,
        "correct": 4
    },
    {
        "question": "Which is a good alternative instead of having one zero argument constructor and one single argument constructor with default argument?",
        "options": [
            "No constructor defined",
            "One default value constructor",
            "Defining the default constructor",
            "Using one constructor with two arguments"
        ],
        "explanation": "Explanation: The constructor with one default argument can be the best alternative. This is because the constructor with one default value will do the work for both the default constructor and one argument constructor.",
        "index": 604,
        "difficulty": 1.9048390683854546,
        "correct": 2
    },
    {
        "question": "What is upcasting?",
        "options": [
            "Casting subtype to supertype",
            "Casting super type to subtype",
            "Casting subtype to super type and vice versa",
            "Casting anytype to any other type"
        ],
        "explanation": "Explanation: The upcasting concept includes only the casting of subtypes to the super types. This casting is generally done implicitly. Smaller size types can fit into larger size types implicitly.",
        "index": 605,
        "difficulty": 1.911319689088594,
        "correct": 1
    },
    {
        "question": "Which among the following is true for upcasting in inheritance?",
        "options": [
            "Downward to the inheritance tree",
            "Upward to the inheritance tree",
            "Either upward or downward",
            "Doesn\u2019t apply on inheritance"
        ],
        "explanation": "Explanation: The upcasting concept in inheritance is always applied upward the inheritance tree. The derived class objects can be type casted to any of its parent class type. Since is a relationship applies in general inheritance.",
        "index": 606,
        "difficulty": 1.9120868979156596,
        "correct": 2
    },
    {
        "question": "Which among the following is safe?",
        "options": [
            "Upcasting",
            "Downcasting",
            "Both upcasting and downcasting",
            "If upcasting is safe then downcasting is not, and vice versa"
        ],
        "explanation": "Explanation: The upcasting is always safe since the derived type or the smaller type is converted into the base type or the larger size. This results in allocating a smaller size data into bigger type data. No data is lost in casting, hence safe.",
        "index": 607,
        "difficulty": 1.9213523225463147,
        "correct": 1
    },
    {
        "question": "Which among the following is the best situation to use upcasting?",
        "options": [
            "For general code dealing with only subtype",
            "For general code dealing with only supertype",
            "For general code dealing with both the supertype and subtype",
            "For writing a rigid code with respect to subtype"
        ],
        "explanation": "Explanation: When a general code has to be written where we use only the supertype object or the data of bigger size, then upcasting would be the best option. Since the whole code will require only the supertype name references.",
        "index": 608,
        "difficulty": 1.9231426637648008,
        "correct": 2
    },
    {
        "question": "Which property is shown most when upcasting is used?",
        "options": [
            "Code reusability",
            "Code efficiency",
            "Complex code simple syntax",
            "Encapsulation"
        ],
        "explanation": "Explanation: The code written using upcasting mostly shows complex code in simpler syntax features. This is because the upcasting concept can be applied as polymorphism and to group the similar type of objects.",
        "index": 609,
        "difficulty": 1.9267891377594095,
        "correct": 3
    },
    {
        "question": "Upcasting and downcasting objects are the same as casting primitive types.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: It is a bit confusing concept since both casting concepts are different. Primitive casting depends on the type and size of data being typecast. Whereas in objects casting, the classes and inheritance order plays a big role.",
        "index": 610,
        "difficulty": 1.931048935993708,
        "correct": 2
    },
    {
        "question": "What is downcasting?",
        "options": [
            "Casting subtype to supertype",
            "Casting supertype to subtype",
            "Casting subtype to supertype and vice versa",
            "Casting anytype to any other type"
        ],
        "explanation": "Explanation: The downcasting concept includes only the casting of supertypes to the sub types. This casting is generally done explicitly. Larger size types are made to fit into small size types explicitly.",
        "index": 611,
        "difficulty": 1.9463829692121628,
        "correct": 2
    },
    {
        "question": "Which among the following is a mandatory condition for downcasting?",
        "options": [
            "It must not be done explicitly",
            "It must be done implicitly",
            "It must be done explicitly",
            "It can\u2019t be done explicitly"
        ],
        "explanation": "Explanation: The downcasting of any object must be done explicitly. This is because the compilers don\u2019t support the implicit conversion of a supertype to subtype.",
        "index": 612,
        "difficulty": 1.9497262201401835,
        "correct": 3
    },
    {
        "question": "Downcasting is _______________________",
        "options": [
            "Always safe",
            "Never safe",
            "Safe sometimes",
            "Safe, depending on code"
        ],
        "explanation": "Explanation: The downcasting concept is made for exception cases. When there is a need to represent an entity in the form which is not suitable for it. Representing a base type in derived type is not right but can be done for special cases.",
        "index": 613,
        "difficulty": 1.954055642439684,
        "correct": 2
    },
    {
        "question": "Downcasting ____________________",
        "options": [
            "Can result in unexpected results",
            "Can\u2019t result in unexpected result",
            "Can result only in out of memory error",
            "Can\u2019t result in any error"
        ],
        "explanation": "Explanation: The result of downcasting can be unexpected. This is because downcasting is done on the objects into the objects which doesn\u2019t contain any information of data in lateral object.",
        "index": 614,
        "difficulty": 1.9555381916168812,
        "correct": 1
    },
    {
        "question": "What should be used for safe downcast?",
        "options": [
            "Static cast",
            "Dynamic cast",
            "Manual cast",
            "Implicit cast"
        ],
        "explanation": "Explanation: The dynamic cast can be done using the operator dynamic_cast. This converts one type to another type in a safe way.",
        "index": 615,
        "difficulty": 1.956825520699562,
        "correct": 2
    },
    {
        "question": "What does dynamic_cast return after successful type casting?",
        "options": [
            "Address of object which is converted",
            "Address of object that is used for conversion",
            "Address of object that is mentioned in the syntax",
            "Doesn\u2019t return any address"
        ],
        "explanation": "Explanation: The address of the object which is converted is returned by the dynamic_cast operator. This is done to safely convert the subtype to supertype. This ensures the proper assignment and conversion from one type to another.",
        "index": 616,
        "difficulty": 1.989379953099827,
        "correct": 1
    },
    {
        "question": "If dynamic_cast fails, which value is returned?",
        "options": [
            "void",
            "null",
            "void pointer",
            "null pointer"
        ],
        "explanation": "Explanation: The null pointer is returned by the dynamic_cast, if it fails. The conversion sometimes fails because of too complex type conversion. The conversion may also fail due to memory or some related issues.",
        "index": 617,
        "difficulty": 1.9916330846206556,
        "correct": 4
    },
    {
        "question": "Which is the proper syntax of dynamic_cast?",
        "options": [
            "dynamic_cast(object)",
            "dynamic_cast new (object)",
            "dynamic_cast(object)",
            "dynamic_cast(object)",
            "Answer: c",
            "Explanation: The dynamic_cast is the name of the operator, which is followed by the new type in which the object have to be converted. Then the object name is given. This object name is then used after the type conversion.",
            "9. Which is the exception handler for the exceptions of downcasting?",
            "CastException",
            "ClassCastingExeption",
            "ClassCasting",
            "ClassCastException",
            "View AnswerAnswer: d",
            "Explanation: The exception handler for the exceptions produced during the downcasting exception. This handler can be called during runtime to handle any exception thrown.",
            "advertisement",
            "10. How to prevent the ClassCastExceptions?",
            "By using instanceof",
            "By using is-a check",
            "By using arrow operator with check function",
            "By checking type of conversion",
            "View AnswerAnswer: a",
            "Explanation: The instanceof operator can be used to check the compatibility of the conversion. This has to be done to check whether the casting would be safe or not.",
            "11. Java supports direct downcasting.",
            "True",
            "False",
            "View AnswerAnswer: b",
            "Explanation: The downcasting is not possible in java directly. This has to be done explicitly. The downcasting is not safe but can be checked for safe casting using instanceof function.",
            "12. Which way the downcasting is possible with respect to inheritance?",
            "Upward the inheritance order",
            "Downward the inheritance order",
            "Either upward or downward the inheritance order",
            "Order of inheritance doesn\u2019t matter",
            "View AnswerAnswer: b",
            "Explanation: The downcasting is always downward the inheritance order. Since the base class object have to be casted into derived class type. This is a basic definition of downcasting.",
            "13. What happens when downcasting is done but not explicitly defined in syntax?",
            "Compile time error",
            "Runtime error",
            "Code write time error",
            "Conversion error",
            "View AnswerAnswer: a",
            "Explanation: The implicit downcasting is not possible. If tried, the compiler produces an error. Since the compiler doesn\u2019t allow coasting to a type that is not compatible.",
            "14. When is the downcasting used?",
            "To separate inherited class from base class",
            "To write a more complex code",
            "To compare two objects",
            "To disable one class in inheritance",
            "View AnswerAnswer: c",
            "function can be used to compare whether the objects were of same age. We can use getClass() function too.",
            "15. Why is downcasting possible in any language?",
            "Because inheritance follows has-a relationship",
            "Because inheritance follows is-a relationship",
            "Because inheritance doesn\u2019t follow any relationship",
            "Because inheritance is not involved in casting",
            "View AnswerAnswer: b",
            "Explanation: The downcasting is possible because the classes in inheritance follow is-a relationship. Hence the derived class is a base class. Which in turn make the downcasting possible.",
            ".",
            "using C++, here is complete set of 1000+ Multiple Choice Questions and Answers.",
            "\u00ab Prev - Object Oriented Programming using C++ Questions and Answers \u2013 Upcasting\u00bb Next - Object Oriented Programming using C++ Questions and Answers \u2013 New Operator",
            "Next Steps:",
            "Get Free Certificate of Merit in Object Oriented Programming",
            "Participate in Object Oriented Programming Certification Contest",
            "Become a Top Ranker in Object Oriented ProgrammingApply for Object Oriented Programming Job",
            "Take Object Oriented Programming Tests",
            "Chapterwise Practice Tests: Chapter 1,",
            "2,",
            "3,",
            "4,",
            "5,",
            "6,",
            "7,",
            "8,",
            "9,",
            "10",
            "Chapterwise Mock Tests: Chapter 1,",
            "2,",
            "3,",
            "4,",
            "5,",
            "6,",
            "7,",
            "8,",
            "9,",
            "10",
            "Buy Object Oriented Programming Books",
            "Apply for Object Oriented Programming Internship",
            "Apply for Computer Science Engineering Internship"
        ],
        "explanation": "Explanation: The dynamic_cast is the name of the operator, which is followed by the new type in which the object have to be converted. Then the object name is given. This object name is then used after the type conversion.",
        "index": 618,
        "difficulty": 2.023510278280998,
        "correct": 3
    },
    {
        "question": "Which is the exception handler for the exceptions of downcasting?",
        "options": [
            "CastException",
            "ClassCastingExeption",
            "ClassCasting",
            "ClassCastException"
        ],
        "explanation": "Explanation: The exception handler for the exceptions produced during the downcasting exception. This handler can be called during runtime to handle any exception thrown.",
        "index": 619,
        "difficulty": 2.036784628031726,
        "correct": 4
    },
    {
        "question": "How to prevent the ClassCastExceptions?",
        "options": [
            "By using instanceof",
            "By using is-a check",
            "By using arrow operator with check function",
            "By checking type of conversion"
        ],
        "explanation": "Explanation: The instanceof operator can be used to check the compatibility of the conversion. This has to be done to check whether the casting would be safe or not.",
        "index": 620,
        "difficulty": 2.0422288330756775,
        "correct": 1
    },
    {
        "question": "Java supports direct downcasting.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The downcasting is not possible in java directly. This has to be done explicitly. The downcasting is not safe but can be checked for safe casting using instanceof function.",
        "index": 621,
        "difficulty": 2.0426513802661237,
        "correct": 2
    },
    {
        "question": "Which way the downcasting is possible with respect to inheritance?",
        "options": [
            "Upward the inheritance order",
            "Downward the inheritance order",
            "Either upward or downward the inheritance order",
            "Order of inheritance doesn\u2019t matter"
        ],
        "explanation": "Explanation: The downcasting is always downward the inheritance order. Since the base class object have to be casted into derived class type. This is a basic definition of downcasting.",
        "index": 622,
        "difficulty": 2.0435339677470576,
        "correct": 2
    },
    {
        "question": "What happens when downcasting is done but not explicitly defined in syntax?",
        "options": [
            "Compile time error",
            "Runtime error",
            "Code write time error",
            "Conversion error"
        ],
        "explanation": "Explanation: The implicit downcasting is not possible. If tried, the compiler produces an error. Since the compiler doesn\u2019t allow coasting to a type that is not compatible.",
        "index": 623,
        "difficulty": 2.047338949184084,
        "correct": 1
    },
    {
        "question": "When is the downcasting used?",
        "options": [
            "To separate inherited class from base class",
            "To write a more complex code",
            "To compare two objects",
            "To disable one class in inheritance"
        ],
        "explanation": "Explanation: The downcasting can be used whenever there is a need to compare one object to another. Equals() function can be used to compare whether the objects were of same age. We can use getClass() function too.",
        "index": 624,
        "difficulty": 2.0538603255135666,
        "correct": 3
    },
    {
        "question": "Why is downcasting possible in any language?",
        "options": [
            "Because inheritance follows has-a relationship",
            "Because inheritance follows is-a relationship",
            "Because inheritance doesn\u2019t follow any relationship",
            "Because inheritance is not involved in casting"
        ],
        "explanation": "Explanation: The downcasting is possible because the classes in inheritance follow is-a relationship. Hence the derived class is a base class. Which in turn make the downcasting possible.",
        "index": 625,
        "difficulty": 2.0604088303772503,
        "correct": 2
    },
    {
        "question": "What is the new operator?",
        "options": [
            "Allocates memory for an object or array",
            "Allocates memory for an object or array and returns a particular pointer",
            "Used as return type when an object is created",
            "Used to declare any new thing in a program"
        ],
        "explanation": "Explanation: The new keyword is used to allocate memory of an object or array. The new object or array can be of any type. Then it returns a suitable non zero pointer to the object.",
        "index": 626,
        "difficulty": 2.072690640393432,
        "correct": 2
    },
    {
        "question": "Microsoft C++ Components extensions support new keyword to _____________",
        "options": [
            "Modify a vtable",
            "Replace a vtable slot entry",
            "Add new vtable slot entries",
            "Rearrange vtable slot entries"
        ],
        "explanation": "Explanation: The new keyword is used for adding new vtable slot entries. This is an additional feature in Microsoft C++. It can use predefined class object for this work.",
        "index": 627,
        "difficulty": 2.0889218503324605,
        "correct": 3
    },
    {
        "question": "What happens when new fails?",
        "options": [
            "Returns zero always",
            "Throws an exception always",
            "Either throws an exception or returns zero",
            "Terminates the program"
        ],
        "explanation": "Explanation: While creating new objects, the new operator may fail because of memory errors or due to permissions. At that moment the new operator returns zero or it may throw an exception. The exception can be handled as usual.",
        "index": 628,
        "difficulty": 2.122699768546772,
        "correct": 3
    },
    {
        "question": "If new throws an error, which function can be called to write a custom exception handler?",
        "options": [
            "_set_handler",
            "_new_handler",
            "_handler_setter",
            "_set_new_handler"
        ],
        "explanation": "Explanation: If the default exception handler has to be replaced by a user defined handler, we can call _set_new_handler run-time library function with the function name as an argument. This lets the programmer to give a custom definition for handling new operator failure.",
        "index": 629,
        "difficulty": 2.1258792289205397,
        "correct": 4
    },
    {
        "question": "In C++, if new operator is used, when is the constructor called?",
        "options": [
            "Before the allocation of memory",
            "After the allocation of memory",
            "Constructor is called to allocate memory",
            "Depends on code"
        ],
        "explanation": "Explanation: The constructor function is called after the allocation of memory. In C++ the feature works in a bit different way. The memory for all the data members is allocated first and then the constructor function is called to finalize the memory allocated.",
        "index": 630,
        "difficulty": 2.137281549959269,
        "correct": 2
    },
    {
        "question": "Which among the following is correct syntax to declare a 2D array using new operator?",
        "options": [
            "char (*pchar)[10] = new char[][10];",
            "char (pchar) = new char[][10];",
            "char (*char) = new char[10][];",
            "char (*char)[][10]= new char;"
        ],
        "explanation": "Explanation: The new operator usage to declare a 2D array requires a pointer and size of array to be declared. Data type and then the pointer with size of array. The left index can be left blank or any variable can be assigned to it.",
        "index": 631,
        "difficulty": 2.1420394766634345,
        "correct": 1
    },
    {
        "question": "For declaring data by using new operator ____________________",
        "options": [
            "Type name can\u2019t contain const",
            "Type name can\u2019t contain volatile",
            "Type name can\u2019t contain class declarations",
            "Type name can\u2019t contain const, volatile, class declaration or enumerations"
        ],
        "explanation": "Explanation: The declaration of any data where we use new operator, any of the mentioned types are not allowed. This is because the new operator allocated memory based on the type of data which can be allocated dynamically.",
        "index": 632,
        "difficulty": 2.1443354577870632,
        "correct": 4
    },
    {
        "question": "The new operator _____________",
        "options": [
            "Can allocate reference types too",
            "Doesn\u2019t allocate reference types",
            "Can allocate reference to objects",
            "Doesn\u2019t allocate any data"
        ],
        "explanation": "Explanation: The new operator doesn\u2019t allocate reference types. This is because the reference types are not objects. The new operator is used to allocate memory to the direct objects.",
        "index": 633,
        "difficulty": 2.1481238082820564,
        "correct": 2
    },
    {
        "question": "Which among the following is true?",
        "options": [
            "New operator can\u2019t allocate functions but pointer to functions can be allocated",
            "New operator can allocate functions as well as pointer to functions",
            "New operator can allocate any type of functions",
            "New operator is not applicable with functions allocation"
        ],
        "explanation": "Explanation: The new operator can\u2019t allocate functions but can allocate pointer to the functions. This is a security feature as well as to reduce the ambiguity in code. The new keyword is not given functionality to directly allocate any function.",
        "index": 634,
        "difficulty": 2.1538771822807874,
        "correct": 1
    },
    {
        "question": "Which among the following is added in grammar of new operator?",
        "options": [
            "Finalize",
            "Arg",
            "Initializer",
            "Allocator"
        ],
        "explanation": "Explanation: The new operator grammar is added with an initializer field. This can be used to initialize an object with a user defined constructor. Hence can allocate memory as intended by the programmer.",
        "index": 635,
        "difficulty": 2.1574882128562365,
        "correct": 3
    },
    {
        "question": "Initializers __________________",
        "options": [
            "Are used for specifying arrays",
            "Are used to defined multidimensional arrays",
            "Can\u2019t be specified for arrays",
            "Can\u2019t be specified for any data"
        ],
        "explanation": "Explanation: The initializers can\u2019t be specified for arrays. The initializers can create arrays of object if and only if the class has a default constructor. That is a zero argument constructor so that it can be called without any argument.",
        "index": 636,
        "difficulty": 2.158264166970236,
        "correct": 3
    },
    {
        "question": "The objects allocated using new operator ________________",
        "options": [
            "Are destroyed when they go out of scope",
            "Are not destroyed even if they go out of scope",
            "Are destroyed anytime",
            "Are not destroyed throughout the program execution"
        ],
        "explanation": "Explanation: It is not necessary that the objects get destroyed when they go out of scope if allocated by using new operator. This is because new operator returns a pointer to object that it had allocated. A suitable pointer with proper scope should be defined by the programmer explicitly.",
        "index": 637,
        "difficulty": 2.1819403599630807,
        "correct": 2
    },
    {
        "question": "The new operator _________________",
        "options": [
            "Invokes function operator new",
            "Doesn\u2019t invoke function operator new",
            "Invokes function operator only if required",
            "Can\u2019t invoke function operator new implicitly"
        ],
        "explanation": "Explanation: The new operator invokes function operator new. This is done to allocate the storage to an object. ::operator new is called for storage allocation implicitly.",
        "index": 638,
        "difficulty": 2.187036823830983,
        "correct": 1
    },
    {
        "question": "If a new operator is defined for a class and still global new operator have to be used, which operator should be used with the keyword new?",
        "options": [
            "Colon",
            "Arrow",
            "Dot",
            "Scope resolution"
        ],
        "explanation": "Explanation: As usual, scope resolution operator is used to get the scope of parent or the global entities. Hence we can use scope resolution operator with the new operator to call the global new operator even if new operator is defined for the class explicitly.",
        "index": 639,
        "difficulty": 2.1879236426965925,
        "correct": 4
    },
    {
        "question": "How does compiler convert \u201c::operator new\u201d implicitly?",
        "options": [
            "::operator new( sizeof( type ) )",
            "::operator new( sizeof( ) )",
            "new operator :: type sizeof( type )",
            "new sizeof( type ) operator"
        ],
        "explanation": "Explanation: The compiler implicitly converts the syntax so that the instruction can be understood by the processor and proper machine code can be generated. The conversion is done implicitly and no explicit syntax is required.",
        "index": 640,
        "difficulty": 2.199858307451251,
        "correct": 1
    },
    {
        "question": "What is a delete operator?",
        "options": [
            "Deallocates a block of memory",
            "Deallocates whole program memory",
            "Deallocates only primitive data memory",
            "Deallocates all the data reserved for a class"
        ],
        "explanation": "Explanation: The delete operator is the reverse process of a new operator. It deallocates all the memory allocated for an object. The object can be of any type. The delete operator completely destroys an object so that the resources can be used for other purposes.",
        "index": 641,
        "difficulty": 2.2013690285641463,
        "correct": 1
    },
    {
        "question": "If an object is allocated using new operator ____________",
        "options": [
            "It should be deleted using delete operator",
            "It can\u2019t be deleted using delete operator",
            "It may or may not be deleted using delete operator",
            "The delete operator is not applicable"
        ],
        "explanation": "Explanation: The new operator allocates an object in memory and hence the memory allocation is bit different from usual allocation of an object. The delete operator can be used to delete the memory allocated for an object.",
        "index": 642,
        "difficulty": 2.2019593555331207,
        "correct": 1
    },
    {
        "question": "Does delete return any value?",
        "options": [
            "Yes, positive value",
            "Yes, negative value",
            "Yes, zero value",
            "No"
        ],
        "explanation": "Explanation: The delete operator doesn\u2019t return any value. Its function is to delete the memory allocated for an object. This is done in reverse way as that new operator works.",
        "index": 643,
        "difficulty": 2.2155975225589977,
        "correct": 4
    },
    {
        "question": "Which type of value has resulted from the delete operator?",
        "options": [
            "void",
            "void pointer",
            "null pointer",
            "null"
        ],
        "explanation": "Explanation: The result of the delete operator is void. The values returned is of no use to the program or any other system function hence the return type is not defined for the delete operator.",
        "index": 644,
        "difficulty": 2.2167003218119223,
        "correct": 1
    },
    {
        "question": "If delete is used to delete an object which was not allocated using new _______________",
        "options": [
            "Then out of memory error arises",
            "Then unreachable code error arises",
            "Then unpredictable errors may arise",
            "Then undefined variable error arises"
        ],
        "explanation": "Explanation: When the delete operator is used with the objects that were not allocated using new operator then unpredictable errors may arise. This is because the delete can\u2019t perform the required actions on the type of memory allocated for the object.",
        "index": 645,
        "difficulty": 2.2202264787243973,
        "correct": 3
    },
    {
        "question": "Delete operator _________________",
        "options": [
            "Can be used on pointers with null value",
            "Can be used on pointers with void value",
            "Can be used on pointer with value 0",
            "Can be used on pointer with any value"
        ],
        "explanation": "Explanation: The delete operator can be used on pointers with the value 0. This actually means that when new operator fails and return value 0 then deleting the result of failed new remains harmless. Hence the deletion is possible.",
        "index": 646,
        "difficulty": 2.2290508754022724,
        "correct": 3
    },
    {
        "question": "When delete operator is used ___________________ (If object has a destructor)",
        "options": [
            "Object destructor is called after deallocation",
            "Object destructor is called before deallocation",
            "Object destructor is not used",
            "Object destructor can be called anytime during destruction"
        ],
        "explanation": "Explanation: The destructor is called before the memory is deallocated for any object. The destructor call initiates the destruction process and the deallocation of memory takes place.",
        "index": 647,
        "difficulty": 2.229594500293432,
        "correct": 2
    },
    {
        "question": "If delete is applied to an object whose l-value is modifiable, then _______________ after the object is deleted.",
        "options": [
            "Its value is defined as null",
            "Its value is defined as void",
            "Its value is defined as 0",
            "Its value is undefined"
        ],
        "explanation": "Explanation: After performing delete operation on an object whole l-value is modifiable, its values becomes undefined. This is done so as to denote that the memory space is available to be used for other purposes.",
        "index": 648,
        "difficulty": 2.251524382063499,
        "correct": 4
    },
    {
        "question": "How many variants of delete operator are available?",
        "options": [
            "Only 1",
            "Only 2",
            "Only 3",
            "Only 4"
        ],
        "explanation": "Explanation: There are two variants of delete operator. One is for object deletion. Other is for deletion of object array.",
        "index": 649,
        "difficulty": 2.259004053319517,
        "correct": 2
    },
    {
        "question": "Which is the correct syntax to delete a single object?",
        "options": [
            "delete *objectName;",
            "objectName delete;",
            "delete objectName;",
            "objectName *delete;"
        ],
        "explanation": "Explanation: The object to be deleted is mentioned after the keyword delete. This deletes the object from memory and free up the memory that was acquired by the object.",
        "index": 650,
        "difficulty": 2.2730360863022394,
        "correct": 3
    },
    {
        "question": "Which is the correct syntax to delete an array of objects?",
        "options": [
            "delete [] objectName;",
            "delete * objectName;",
            "objectName[] delete;",
            "delete objectName[];"
        ],
        "explanation": "Explanation: The object array that has to be deleted is mentioned after the keyword delete. But after delete, empty square brackets have to be given to denote that the deletion have to be done on array of objects.",
        "index": 651,
        "difficulty": 2.2922544557277114,
        "correct": 1
    },
    {
        "question": "Which cases among the following produces the undefined result?",
        "options": [
            "delete [] on an independent object",
            "delete on an object array",
            "delete [] on an object and delete on object array",
            "Undefined result is never produced"
        ],
        "explanation": "Explanation: The undefined result is always produced when we try to use delete [] with a single object. Because the type of deletion mismatches. Same in case where we try to apply delete to an object array.",
        "index": 652,
        "difficulty": 2.2940539841818106,
        "correct": 3
    },
    {
        "question": "The delete operator __________________",
        "options": [
            "Invokes function operator delete",
            "Invokes function defined by user to delete",
            "Invokes function defined in global scope to delete object",
            "Doesn\u2019t invoke any function"
        ],
        "explanation": "Explanation: The delete operator invokes the function operator delete. This function in turn performs all the delete operations on the mentioned object. This is ensures safe deletion.",
        "index": 653,
        "difficulty": 2.2947361101453057,
        "correct": 1
    },
    {
        "question": "For objects that are not of class type ______________",
        "options": [
            "Global delete operator is invoked",
            "Local delete operator is invoked",
            "Global user defined function is invoked",
            "Local function to delete object is called"
        ],
        "explanation": "Explanation: The global delete operator is called to delete the objects that are not of class type. Class type includes class, union or struct. All objects of these types can be deleted using the global delete operator.",
        "index": 654,
        "difficulty": 2.2972625636594453,
        "correct": 1
    },
    {
        "question": "The delete operator __________________________",
        "options": [
            "Can be defined for each class",
            "Can\u2019t be defined for each class",
            "Can be defined globally only",
            "Can\u2019t be defined in a program explicitly"
        ],
        "explanation": "Explanation: The delete operator can be defined for each class explicitly. If there is a class for which delete is not defined then the global delete operator is used. The definition of delete operator for each class is not necessary.",
        "index": 655,
        "difficulty": 2.3138454408835445,
        "correct": 1
    },
    {
        "question": "What are automatic variables?",
        "options": [
            "Global variables",
            "Implicit/temporary variables",
            "Local variables",
            "System variables"
        ],
        "explanation": "Explanation: The local variables are also known as automatic variables. The variables in any local scope that are created and destroyed as the program executes its scope.",
        "index": 656,
        "difficulty": 2.3148832816158063,
        "correct": 3
    },
    {
        "question": "The memory for automatic variables ___________________",
        "options": [
            "Have to be allocated and deallocated explicitly",
            "Are allocated and deallocated automatically",
            "Is never actually allocated",
            "Are never safe"
        ],
        "explanation": "Explanation: The memory is allocated and deallocated automatically for the automatic variables. As soon as the variable comes in scope, the memory is allocated. The variables are destroyed as soon as those go out of scope.",
        "index": 657,
        "difficulty": 2.317372688366511,
        "correct": 2
    },
    {
        "question": "Scope of an automatic variable _______________",
        "options": [
            "Is actually the whole program",
            "Is actually never fixed",
            "Is always equal to the whole program execution",
            "Is actually function or block in which it is defined"
        ],
        "explanation": "Explanation: The automatic variables scope is limited only within the block or the function where those are defined. This is the property of all the automatic variables.",
        "index": 658,
        "difficulty": 2.325019622612732,
        "correct": 4
    },
    {
        "question": "Which among the following is true for automatic variables in general?",
        "options": [
            "Automatic variables are invisible to called function",
            "Automatic variables are always visible to the called function",
            "Automatic variables can\u2019t interact with the called function",
            "Automatic variables can\u2019t be variable"
        ],
        "explanation": "Explanation: The automatic variables are hidden from the called function. Even if passed by reference or address, the address of the variable is used and not the actual variable of calling function. Automatic variables can be const or variable.",
        "index": 659,
        "difficulty": 2.330793025338777,
        "correct": 1
    },
    {
        "question": "If an automatic variable is created and then a function is called then ________________",
        "options": [
            "The automatic variable created gets destroyed",
            "The automatic variable doesn\u2019t get destroyed",
            "The automatic variable may or may not get destroyed",
            "The automatic variable can\u2019t be used in this case"
        ],
        "explanation": "Explanation: The automatic variables are saved till the called function gets executed. This is done so as to ensure that the program can continue its execution after the called function is returned. The automatic variables gets destroyed only if those go out of scope.",
        "index": 660,
        "difficulty": 2.37832457472481,
        "correct": 2
    },
    {
        "question": "Where are the automatic variables stored if another function is called in between the execution of the program?",
        "options": [
            "Heap",
            "Queue",
            "Stack",
            "Temp variable"
        ],
        "explanation": "Explanation: All the automatic variables are stored in a new stack entry as soon as their scope is created. If another function is called, the present data is saved in stack and new entry in stack is made for the called function. When the function returns, the automatic variables are used again from where those were left.",
        "index": 661,
        "difficulty": 2.4068285010210246,
        "correct": 3
    },
    {
        "question": "The static variables of a function ________________",
        "options": [
            "Are also automatic variables",
            "Are not automatic variables",
            "Are made automatic by default",
            "Can be made automatic explicitly"
        ],
        "explanation": "Explanation: The static members can\u2019t be automatic. This is because the automatic variables are created and destroyed with each call to a specific function. But the static members remain throughout the execution of program once created.",
        "index": 662,
        "difficulty": 2.425120187982051,
        "correct": 2
    },
    {
        "question": "All variables declared within a block ____________________",
        "options": [
            "Are not always automatic",
            "Can be made non-automatic",
            "Are static by default",
            "Are automatic by default"
        ],
        "explanation": "Explanation: The variables declared inside a block, are make automatic by default. This is to ensure that the variables get destroyed when not required. The variables remain live only till those are required, the life is dependent on the scope of a variable.",
        "index": 663,
        "difficulty": 2.430160050918789,
        "correct": 4
    },
    {
        "question": "What values does uninitialized automatic variables contain?",
        "options": [
            "Null value",
            "Void value",
            "Undefined/Garbage",
            "Zero value"
        ],
        "explanation": "Explanation: The automatic variable which are not initialized, contain garbage value. If we just declare a variable and try to print its value, the result is some unknown value. The value is garbage as that was not expected value.",
        "index": 664,
        "difficulty": 2.4351188905864207,
        "correct": 3
    },
    {
        "question": "Constructor of automatic variables is called ____________________",
        "options": [
            "When execution reaches the place of declaration of automatic variables",
            "When the program is compiled",
            "When the execution is just started",
            "Just before the execution of the program"
        ],
        "explanation": "Explanation: Only when the execution reaches the place where the automatic variable was declared, the constructor is called. This is to ensure that the memory is not allocated if not needed. The memory is allocated and then destroyed as soon as it goes out of scope.",
        "index": 665,
        "difficulty": 2.454899408089993,
        "correct": 1
    },
    {
        "question": "Does java contain auto or register keywords?",
        "options": [
            "Yes, for declaring every type of variable",
            "Yes, only to declare cache registers",
            "No, because java doesn\u2019t support automatic variables",
            "No, java supports local variable concept"
        ],
        "explanation": "Explanation: The auto and register keywords are not supported in java. Though the same is allowed in java without specifying any of those keywords. The variables are local variables. But java makes it mandatory to initialize all of the local variables in a program.",
        "index": 666,
        "difficulty": 2.4585573037663995,
        "correct": 4
    },
    {
        "question": "The automatic variables _________________________",
        "options": [
            "Must be declared after its use",
            "Must be declared before using",
            "Must be declared, can be anytime",
            "Must not be initialized"
        ],
        "explanation": "Explanation: All the automatic variables in a program must be declared before their use. The compiler won\u2019t allow any use of variable if those are not declared before their use.",
        "index": 667,
        "difficulty": 2.5072429468073505,
        "correct": 2
    },
    {
        "question": "Which error is produced if the automatic variables are used without declaration?",
        "options": [
            "Undefined symbol",
            "Memory error",
            "Type mismatch",
            "Statement missing"
        ],
        "explanation": "Explanation: If the automatic variables are used without declaration or are used before the declaration then the compiler throws an error. The error that the symbol is undefined. The compiler must know everything before that can be used.",
        "index": 668,
        "difficulty": 2.531010424264399,
        "correct": 1
    },
    {
        "question": "In Perl, using which operator are the local variables created?",
        "options": [
            "Dot",
            "Arrow",
            "Scope resolution",
            "my"
        ],
        "explanation": "Explanation: The language perl supports local variables but the concept is bit different. And if the values are not assigned to the local variables then it contains undef value.",
        "index": 669,
        "difficulty": 2.5376731932661087,
        "correct": 4
    },
    {
        "question": "How are automatic variables different from the instance variables?",
        "options": [
            "Automatic variables are initialized automatically but instances are not",
            "Automatic variables are given zero values initially and not instances",
            "Instance variables have to be initialized explicitly and automatic implicitly",
            "Instance variables are initialized implicitly while automatic are not"
        ],
        "explanation": "Explanation: The automatic variables have to be initialized explicitly. But in case of instances, those are initialized automatically during execution of the program. The conventions are mandatory.",
        "index": 670,
        "difficulty": 2.56944019083622,
        "correct": 4
    },
    {
        "question": "What is extern variable?",
        "options": [
            "Variables to be used that are declared in another object file",
            "Variables to be used that are declared in another source file",
            "Variables to be used that are declared in another executable file",
            "Variables to be used that are declared in another program"
        ],
        "explanation": "Explanation: The variables that are declared in another source file can be accessed in other files using extern variables. The extern variables must be mentioned explicitly. The source file is included to use its variables.",
        "index": 671,
        "difficulty": 2.5736112175263823,
        "correct": 2
    },
    {
        "question": "Which among the following is a correct statement for variables?",
        "options": [
            "Variable can be declared many times",
            "Variable can be declared only one time",
            "Variable declaration can\u2019t be done more than ones",
            "Variable declaration is always done more than one time"
        ],
        "explanation": "Explanation: The variables can be declared any number of times. There is no restriction on how many times a single variables can be declared. Declaration is just an indication that the variable will be used in the program.",
        "index": 672,
        "difficulty": 2.5771606909028604,
        "correct": 1
    },
    {
        "question": "Which among the following is true for the variables?",
        "options": [
            "Variable can be defined only once",
            "Variable can be defined any number of times",
            "Variable must be defined more than one time",
            "Variable can be defined in different files"
        ],
        "explanation": "Explanation: The variables can be defined only once. Once the variable is defined, then it can\u2019t be declared again. The definition of a variable is actual allocation of memory for the variable.",
        "index": 673,
        "difficulty": 2.6180053568321044,
        "correct": 1
    },
    {
        "question": "To use extern variable _____________________",
        "options": [
            "The source file must not be included in the new file code",
            "The source file itself must be used for a new program",
            "The source file must be included in the new file",
            "The source file doesn\u2019t matter for extern variables"
        ],
        "explanation": "Explanation: The source file must be included in the file which needs to use the extern variable. This is done to ensure that the variables that are already declared can be used again. Only the declarations are used from one file to another.",
        "index": 674,
        "difficulty": 2.625113176414045,
        "correct": 3
    },
    {
        "question": "What does a header file contain for an extern variable?",
        "options": [
            "Only declaration of variables",
            "Only definition of variables",
            "Both declaration and definition of variables",
            "Neither declaration nor definition"
        ],
        "explanation": "Explanation: The header file only contains the declaration of variables that are extern. It doesn\u2019t contain any static variable definitions.",
        "index": 675,
        "difficulty": 2.629290137068545,
        "correct": 1
    },
    {
        "question": "Which condition is true if the extern variable is used in a file?",
        "options": [
            "All the header files declare it",
            "Only few required files declare it",
            "All header files declared it if required",
            "Only one header file should declare it"
        ],
        "explanation": "Explanation: Only one header file should declare the extern variable to be used. There must not be more than one file declaring the same extern variable. This is to ensure that there is no ambiguity in using the extern variable.",
        "index": 676,
        "difficulty": 2.6426363391346452,
        "correct": 4
    },
    {
        "question": "Whenever a function is declared in a program _____________________",
        "options": [
            "extern can be used only in some special cases",
            "extern can\u2019t be used",
            "function is extern by default",
            "it can\u2019t be made extern"
        ],
        "explanation": "Explanation: Even if we don\u2019t specify a function to be extern, by default all the functions are exter. The compiler adds the keyword at the beginning of the function declaration. If there is an extern function to be used then it will be used otherwise the new function only will be used.",
        "index": 677,
        "difficulty": 2.6449521135129164,
        "correct": 3
    },
    {
        "question": "Even if a variable is not declared as extern, it is extern by default.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The statement is false. The variables are not extern by default. If those are made extern by default, then the memory will never be allocated for those extern variables. Hence we make the variables extern explicitly.",
        "index": 678,
        "difficulty": 2.6460087231637486,
        "correct": 2
    },
    {
        "question": "Which of the following results in the allocation of memory for the extern variables?",
        "options": [
            "Declaration",
            "Definition",
            "Including file",
            "Memory is not allocated for extern variables"
        ],
        "explanation": "Explanation: The memory for the extern variables are allocated due to their definition. When the variables are declared, it only indicates the compiler that the variable is going to be used somewhere. But definition makes the compiler to allocate the memory for the variables.",
        "index": 679,
        "difficulty": 2.64680696176303,
        "correct": 2
    },
    {
        "question": "Which is the correct syntax for extern variable declaration?",
        "options": [
            "extern data_type variable_name;",
            "extern variable_name;",
            "data_type variable_name extern;",
            "extern (data_type)variable_name;"
        ],
        "explanation": "Explanation: The syntax firstly contains the keyword extern. Then the data type of the variable is given. Then the variabel name is mentioned by which it will be used in the program.",
        "index": 680,
        "difficulty": 2.6480282639065837,
        "correct": 1
    },
    {
        "question": "Which is the correct syntax for extern function declaration?",
        "options": [
            "extern function_name(argument_list);",
            "extern return_type function_name(argument_list);",
            "extern (return_type)function_name(argument_list);",
            "return_type extern function_name(argument_list);"
        ],
        "explanation": "Explanation: The syntax must contain the keyword extern first, to denote that the function is extern. Though the function are extern by default but among the given choices, it should contain the keyword, for explicit declaration. Then the usual function declaration follows.",
        "index": 681,
        "difficulty": 2.6590671919816113,
        "correct": 2
    },
    {
        "question": "What are inbuilt classes?",
        "options": [
            "The predefined classes in a language",
            "The classes that are defined by the user",
            "The classes which are meant to be modified by the user",
            "The classes which can\u2019t be used by the user"
        ],
        "explanation": "Explanation: The classes that are already provided in a programming language for use are inbuilt classes. These classes provide some functions or objects that can be used by the programmer for easier code.",
        "index": 682,
        "difficulty": 2.662563026889355,
        "correct": 1
    },
    {
        "question": "Inbuilt class __________________________",
        "options": [
            "Must be included before use",
            "Are not necessary to be included for use",
            "Are used by the compiler only",
            "Can be modified by programmer always"
        ],
        "explanation": "Explanation: The inbuilt classes must be included in the program. Whenever some functions are used, they must have a declaration before use. The same is the case with classes.",
        "index": 683,
        "difficulty": 2.6658148186738266,
        "correct": 1
    },
    {
        "question": "What doesn\u2019t inbuilt classes contain?",
        "options": [
            "Function prototype",
            "Function declaration",
            "Function definitions",
            "Objects"
        ],
        "explanation": "Explanation: The classes contain the definitions of the special functions that are provided for the programmers use. Those functions can be used to make the programming easy and to reuse the already existing code.",
        "index": 684,
        "difficulty": 2.6870129716265376,
        "correct": 3
    },
    {
        "question": "Which among the following not an inbuilt class in C++?",
        "options": [
            "System",
            "Color",
            "String",
            "Functions"
        ],
        "explanation": "Explanation: There is no inbuilt class named function in java. The others are classes already provided in java. All those classes contain some special functions to be used in programming.",
        "index": 685,
        "difficulty": 2.6902892894886525,
        "correct": 4
    },
    {
        "question": "What is the InputStream class meant for?",
        "options": [
            "To handle all input streams",
            "To handle all output streams",
            "To handle all input and output streams",
            "To handle only input from file"
        ],
        "explanation": "Explanation: The InputStream is an inbuilt class which is used to handle all the tasks related to input handling. This class extends input from keyboard or file or any other possible input stream.",
        "index": 686,
        "difficulty": 2.691635039349462,
        "correct": 1
    },
    {
        "question": "Which statement is true for the Array class?",
        "options": [
            "Arrays can have variable length",
            "The length array can be changed",
            "Each class has an associated Array class",
            "Arrays can contain different type of values"
        ],
        "explanation": "Explanation: The Array class is associated with all the other classes. This gives us the flexibility to declare an array of any type. The index goes from 0 to n, where n is some fixed size for array.",
        "index": 687,
        "difficulty": 2.6952675128849632,
        "correct": 3
    },
    {
        "question": "What is the use of Math class?",
        "options": [
            "To use the mathematical functions with strings",
            "To use the mathematical functions",
            "To suppress the use of mathematical functions",
            "To complex the calculations"
        ],
        "explanation": "Explanation: The Math class is provided with some special functions. These functions can be used to calculate and get result of some special and usual mathematical functions. We don\u2019t have to write the code to calculate the trigonometric function results, instead we can use Math functions.",
        "index": 688,
        "difficulty": 2.7154827125934506,
        "correct": 2
    },
    {
        "question": "DataInputStream is derived from ______________________",
        "options": [
            "StreamingInput",
            "StreamedInput",
            "StreameInput",
            "StreamInput"
        ],
        "explanation": "Explanation: The DataInputStream is more specific class for operating on specific type of data inputs. This is used to read data of specific type. The same can be used to read data in a specific format.",
        "index": 689,
        "difficulty": 2.7156836405416085,
        "correct": 4
    },
    {
        "question": "Which attribute can be used to get the size of an array?",
        "options": [
            "Size.Array",
            "Array.Size",
            "Array_name.length",
            "length.Array_name"
        ],
        "explanation": "Explanation: The array name is given of which the length have to be calculated. The array length is stored in the attribute length. Hence we access it using dot operator.",
        "index": 690,
        "difficulty": 2.7186474296604377,
        "correct": 3
    },
    {
        "question": "Number class can\u2019t manipulate ____________________",
        "options": [
            "Integer values",
            "Float values",
            "Byte values",
            "Character values"
        ],
        "explanation": "Explanation: The Number class is used to work with all the number type of values. The integers, float, double, byte etc. are all number type values. Character is not a number value.",
        "index": 691,
        "difficulty": 2.7323844656553984,
        "correct": 4
    },
    {
        "question": "Which function should be used to exit from the program that is provided by System class?",
        "options": [
            "exit(int);",
            "gc();",
            "terminate();",
            "halt();"
        ],
        "explanation": "Explanation: The exit function should be used to terminate the program. The function is passed with an argument. The argument indicated the type of error occurred.",
        "index": 692,
        "difficulty": 2.744583973968126,
        "correct": 1
    },
    {
        "question": "Which class contain runFinalization() method?",
        "options": [
            "Finalize",
            "System",
            "Final",
            "SystemFinal"
        ],
        "explanation": "Explanation: The runFinalization() Function is defined in the System class. The function is used to finalize an object which undergo destruction. The action is required to terminate the object properly.",
        "index": 693,
        "difficulty": 2.7453331228896314,
        "correct": 2
    },
    {
        "question": "What does load(String)::= function do, in System class?",
        "options": [
            "Loads dynamic library for a path name",
            "Loads all the dynamic libraries",
            "Loads all the Number in string format",
            "Loads the processor with calculations"
        ],
        "explanation": "Explanation: Only the specified path named dynamic libraries are loaded. All the dynamic libraries can\u2019t be loaded at a time. Hence we use this function for specific libraries.",
        "index": 694,
        "difficulty": 2.768132666436909,
        "correct": 1
    },
    {
        "question": "Which is not a System class variable?",
        "options": [
            "err",
            "out",
            "in",
            "put"
        ],
        "explanation": "Explanation: Put is not a System class variable. The most general and basic variables are err, out and in. The variables can handle most of the tasks performed in a program.",
        "index": 695,
        "difficulty": 2.768307626494223,
        "correct": 4
    },
    {
        "question": "Which package contains the utility classes?",
        "options": [
            "java.lang",
            "java.utility",
            "java.util",
            "java.io"
        ],
        "explanation": "Explanation: The package java.util contains all the utility classes. This package also contains generic data structures, date, time etc. These can be used in any java program, you just have to include java.util package.",
        "index": 696,
        "difficulty": 2.7836369282502504,
        "correct": 3
    },
    {
        "question": "What is the use of IO class?",
        "options": [
            "To handle all the input operations",
            "To handle all the output operations",
            "To handle all the input and output operations",
            "To handle all the input and output to the standard input"
        ],
        "explanation": "Explanation: The IO class provides functions that can be used to handle input and output operations. All the inputs from standard input and standard output, and also from the files can be handled. This gives the flexibility to make the programs more user friendly.",
        "index": 697,
        "difficulty": 2.7974482309091524,
        "correct": 3
    },
    {
        "question": "IO class provides input and output through ______________________",
        "options": [
            "Data streams",
            "Serialization",
            "File system",
            "Data streams, serialization and file system"
        ],
        "explanation": "Explanation: The IO classes are made such that those can support the input and output from any type of source or destination. The input can be taken from system file and standard input and also some special devices if conned. Same is case to show the output.",
        "index": 698,
        "difficulty": 2.803273148986099,
        "correct": 4
    },
    {
        "question": "Which among the following class contains the methods to access character based console device?",
        "options": [
            "Console",
            "File",
            "Device",
            "Pipe"
        ],
        "explanation": "Explanation: The Console class contains the methods to access the character based devices. The devices which can stream the data as character set. All those devices can be made use of by using the methods of class Console.",
        "index": 699,
        "difficulty": 2.8060854487662006,
        "correct": 1
    },
    {
        "question": "File class is ____________________________",
        "options": [
            "An abstract of file representation only",
            "An abstract of path names only",
            "An abstract which can be used to represent path names or file",
            "An abstract which can represent a file in any format"
        ],
        "explanation": "Explanation: The File class is made to operate with the files. The file can be of any type. All the input and output operations that have to be performed on a file can be done using File class object.",
        "index": 700,
        "difficulty": 2.8089007381659616,
        "correct": 3
    },
    {
        "question": "What is a FileDescriptor?",
        "options": [
            "A handle for machine specific structure of an open file",
            "A handle for program specific structure of an open file",
            "A handle for compiler specific structure of an open file",
            "A handle for representing device files structure"
        ],
        "explanation": "Explanation: The machine specific structure of an open file have to be handled in some special ways. FileDescriptor class can handle those files. The FileDescriptor can also handle open socket, another source, sink of bytes.",
        "index": 701,
        "difficulty": 2.8138199641635566,
        "correct": 1
    },
    {
        "question": "FileInputStream _________________________",
        "options": [
            "Gets the input stream from any device file",
            "Gets the input stream from any open socket",
            "Gets the input stream from any cache",
            "Gets the input stream from any open file only"
        ],
        "explanation": "Explanation: The most specific answer is that the FileInputStream can only be used for the opened files. The class can work only for the file type. No socket or another source are allowed to be accessed.",
        "index": 702,
        "difficulty": 2.82652494663769,
        "correct": 4
    },
    {
        "question": "What does FilePermission class do?",
        "options": [
            "This class is used to give permission rights to a file",
            "This class is used to restrict the use of permissions",
            "This class is used to represent device access permissions",
            "This class is used to represent file access permissions"
        ],
        "explanation": "Explanation: The FilePermission can\u2019t get access to the device access permissions. The Permission is given to a file when it is created or otherwise when a privileged user changes it. Then these permission rights can be accessed using the FilePermission class.",
        "index": 703,
        "difficulty": 2.8465345991484154,
        "correct": 4
    },
    {
        "question": "Which class among the following makes incorrect assumptions?",
        "options": [
            "LineNumberInputStream",
            "LineNumberReader",
            "LineReader",
            "LineBuffer"
        ],
        "explanation": "Explanation: The LineNumberInputStream class makes false assumptions. The false assumption is that it assumes, all the byte data is a character. Which is actually not the case, instead the character have one byte memory space.",
        "index": 704,
        "difficulty": 2.847566890807413,
        "correct": 1
    },
    {
        "question": "Reader class is _________________",
        "options": [
            "Used to read from files",
            "Abstract class to read character streams",
            "Abstract class to input character streams",
            "Used to take input from standard input stream"
        ],
        "explanation": "Explanation: The Reader class is an abstract class that can be used to read characters stream. It can\u2019t be used for any kind of input. It can just read the existing data.",
        "index": 705,
        "difficulty": 2.8525562800857696,
        "correct": 2
    },
    {
        "question": "Which class can handle IO class interrupt?",
        "options": [
            "ExceptionIO",
            "InteruptedIO",
            "InteruptedIOException",
            "IOInteruptException"
        ],
        "explanation": "Explanation: The only class which handles the IO class interrupts is InteruptedIOException class. This class is specially provided to handle any case that involves the execution interrupt.",
        "index": 706,
        "difficulty": 2.8529270840704433,
        "correct": 3
    },
    {
        "question": "StringReader handles _____________________",
        "options": [
            "Any character stream",
            "A character stream whose source is an array",
            "A character stream whose source is character array",
            "A character stream whose source is String only"
        ],
        "explanation": "Explanation: The StringReader can only work with the string type data. Even if a character array is given, it might produce some errors in code. Hence only the string values can be handled properly.",
        "index": 707,
        "difficulty": 2.8604384213821534,
        "correct": 4
    },
    {
        "question": "Which exception handler can be used when character encoding is not supported?",
        "options": [
            "UnsupportedException",
            "UnsupportedEncodingException",
            "SupportException",
            "EncodingException"
        ],
        "explanation": "Explanation: The encoding that is unsupported in a system can be handled. The exception handler is UnSupportedEncodingException class. An object of this class can be created which will catch the exception and handle it.",
        "index": 708,
        "difficulty": 2.864736713285721,
        "correct": 2
    },
    {
        "question": "PushBackReader allows the streams to be pushed back to the stream.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The PushBackReader allows the character streams handling. The main feature is that the stream can be pushed back to the stream. This is used in special cases of handling input stream.",
        "index": 709,
        "difficulty": 2.8711484100239275,
        "correct": 1
    },
    {
        "question": "RandomAccessFile can be used to _______________________",
        "options": [
            "Read from a random access file",
            "Write to a random access file",
            "Read and write to a random access file",
            "Restricts read and write to a random access file"
        ],
        "explanation": "Explanation: The RandomAccessFile class instance can be created to handle input and output operations to a random access file. It first checks the permissions on the file and then any required operation can be done on a random access file. Comparatively faster than other files access.",
        "index": 710,
        "difficulty": 2.8787887952110207,
        "correct": 3
    },
    {
        "question": "Which among the following is a serialization descriptor for any class?",
        "options": [
            "StreamClass",
            "ObjectStreamClass",
            "ObjectStream",
            "StreamObjectClass"
        ],
        "explanation": "Explanation: The ObjectStreamClass object can be created to handle serializations. The class is provided specially for the serializations. It is descriptor like we have a file descriptor to handle/access files.",
        "index": 711,
        "difficulty": 2.8805185942172766,
        "correct": 2
    },
    {
        "question": "Which is a true statement for object of String class?",
        "options": [
            "Object are immutable",
            "Object are mutable",
            "Object are created only once",
            "Object can\u2019t be created"
        ],
        "explanation": "Explanation: The object of string class are mostly immutable. This means that the String objects are constant. These can\u2019t be changed once created.",
        "index": 712,
        "difficulty": 2.8876850535529375,
        "correct": 1
    },
    {
        "question": "How to declare an object of class String?",
        "options": [
            "String object_Name = value;",
            "String object_name = new;",
            "String object_name= new value;",
            "String object_name= value new;"
        ],
        "explanation": "Explanation: The class name String is given. And then the object name is mentioned. There are two ways to declare and initialize the string. Either by giving direct string value or by using new keyword. But if new operator is used, constructor of String class have to be called. From the given options, the direct string value declaration is correct.",
        "index": 713,
        "difficulty": 2.8910220278665513,
        "correct": 1
    },
    {
        "question": "What does function length do in String class?",
        "options": [
            "Returns length of string including null character",
            "Returns length of string excluding null character",
            "Returns length of substring",
            "Returns size of string in bytes"
        ],
        "explanation": "Explanation: The length function returns the length of string. The length is the number of characters in the string but the last null character is not counted. The string length can be used to loop through each character in the string.",
        "index": 714,
        "difficulty": 2.8931756050837283,
        "correct": 2
    },
    {
        "question": "Which is the function to get the character present at a particular index in the string?",
        "options": [
            "char charAt(index);",
            "char charIn(StringName);",
            "char charAt(StringName);",
            "char charIn(index);"
        ],
        "explanation": "Explanation: The function can be called using dot operator with the string object. Char is the return type of the function to return the character at specified position. The index must be an integer value, less than the length of string.",
        "index": 715,
        "difficulty": 2.8959852008569733,
        "correct": 1
    },
    {
        "question": "If only one parameter is passed to substring function then __________________",
        "options": [
            "It returns the character at the specified position",
            "It returns the string of length 1 from the specified index",
            "It returns the string from specified index till the end",
            "It returns the string from starting of string till the specified index"
        ],
        "explanation": "Explanation: The substring function returns a string value. The string is the substring starting from the specified index till the end. The substring function have to be called with the object of string class.",
        "index": 716,
        "difficulty": 2.900091235232477,
        "correct": 3
    },
    {
        "question": "If two index are given as argument to substring function then ___________________",
        "options": [
            "String of length equal to sum of two arguments is returned",
            "String starting from first index and of length equal to send argument",
            "String starting from first index and of length equal to sum of two arguments",
            "String starting from first index and ending at second index position"
        ],
        "explanation": "Explanation: A value of string type is returned from this function. The returned string is a substring that starts from the first argument position, till the second index position. The indices must be less than the length of actual string.",
        "index": 717,
        "difficulty": 2.904001990941655,
        "correct": 4
    },
    {
        "question": "String class have a concat() function that is used to _____________________",
        "options": [
            "Replace old string by new string",
            "Add two strings",
            "Append one string at end of another string",
            "Remove a string from end of one string"
        ],
        "explanation": "Explanation: The concat function is used to append string into another string. The new string is always appended at the end of source string. The target string is appended as it is and the whole string is then ended by null character.",
        "index": 718,
        "difficulty": 2.912553729406395,
        "correct": 3
    },
    {
        "question": "The function lastIndexOf() is used to ___________________",
        "options": [
            "Get the index of last occurrence of specified character in argument",
            "Get the index of first occurrence of specified character in argument",
            "Get the index of last occurrence of first character in string",
            "Get the index of last occurrence of last character of string"
        ],
        "explanation": "Explanation: The function is used to get the last occurrence index of a character present in a string. The return type is char. Single character is returned. The function is used with a string object and the target character is passed as its argument.",
        "index": 719,
        "difficulty": 2.914084807112129,
        "correct": 1
    },
    {
        "question": "Function equals() is _______________ and equalIgnoreCase() is _________________",
        "options": [
            "Case Insensitive, case insensitive",
            "Case sensitive, Case insensitive",
            "Case sensitive, case sensitive",
            "Case insensitive, case sensitive"
        ],
        "explanation": "Explanation: Both the functions return Boolean value. The function equal() is case sensitive and returns false even if a single character is case different in two strings. The other function ignores the case sensitivity and only checks if the spellings are same.",
        "index": 720,
        "difficulty": 2.918460615001437,
        "correct": 2
    },
    {
        "question": "The compareTo() function is used to ________________",
        "options": [
            "Compare strings value to string object",
            "Compare string value to string value",
            "Compare string object to another string object",
            "Compare string object to another string value"
        ],
        "explanation": "Explanation: The source and target must be objects of the string class. The compare is always case sensitive. To compare two string objects without case sensitivity then we can use compareToIgnoreCase() function.",
        "index": 721,
        "difficulty": 2.9336637071122817,
        "correct": 3
    },
    {
        "question": "String class provides function toUpper() to _____________________",
        "options": [
            "Convert first character to uppercase",
            "Convert last character to uppercase",
            "Convert the whole string characters to uppercase",
            "Convert uppercase to lower and lower to uppercases"
        ],
        "explanation": "Explanation: The function is used to convert each character of the string. If the character is already uppercase then it remains the same. But if some character is in lowercase then it will be converted to uppercase.",
        "index": 722,
        "difficulty": 2.9500644106616427,
        "correct": 3
    },
    {
        "question": "String trim() function is used to _______________________",
        "options": [
            "Remove all the white spaces from the string",
            "Remove white space from start of string",
            "Remove white space at end of string",
            "Remove white space from both the ends of string"
        ],
        "explanation": "Explanation: The function is used to remove any white space from both the ends of a given string. The white space include space, tab, next line etc. It will be removed both from the starting of string and from the end of string.",
        "index": 723,
        "difficulty": 2.9636014337356427,
        "correct": 4
    },
    {
        "question": "Function replace() accepts _____________ arguments.",
        "options": [
            "1",
            "2",
            "3",
            "4"
        ],
        "explanation": "Explanation: The first argument is the target character. This target character will be replaced by another character. The new character is the second argument to the function. Only the characters can be passed as argument, not a string.",
        "index": 724,
        "difficulty": 2.965360056485034,
        "correct": 2
    },
    {
        "question": "If two arguments are passed to the indexOf() function then ___________________",
        "options": [
            "Second argument indicates the occurrence number of specified character from starting",
            "Second argument indicates the occurrence number of specified character from end",
            "Second argument indicates the index of the character in first argument",
            "Second argument indicates the index of the character from the last of the string"
        ],
        "explanation": "Explanation: The string may have more than one occurrence of a character. We use this function to get the index at which the specified number of times a specific character has occurred in a string. For example, we can get the index of 5th occurrence of character \u201cj\u201d in a string.",
        "index": 725,
        "difficulty": 2.971901816494224,
        "correct": 1
    },
    {
        "question": "The string class deals with string of only character type.",
        "options": [
            "True",
            "False"
        ],
        "explanation": "Explanation: The string class objects can be used for any string consisting of characters. The characters include numbers, alphabets and few special characters. String class is not necessary to be used but provides a huge set of inbuilt functions to make the string operations easier.",
        "index": 726,
        "difficulty": 2.9763135638344815,
        "correct": 1
    }
]